<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="keywords" content="linux c++">
<meta property="og:type" content="website">
<meta property="og:title" content="扫地小道童">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="扫地小道童">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="扫地小道童">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>扫地小道童</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扫地小道童</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/27/win10使用问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/27/win10使用问题/" itemprop="url">win10使用问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-27T11:50:13+08:00">
                2019-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件安装/" itemprop="url" rel="index">
                    <span itemprop="name">软件安装</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/12/27/win10使用问题/" class="leancloud_visitors" data-flag-title="win10使用问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="删除国际键盘"><a href="#删除国际键盘" class="headerlink" title="删除国际键盘"></a>删除国际键盘</h2><p>输入法切换时，英语-美式/英语-国际/中文。</p>
<p>设置=&gt;时间和语言=&gt;区域和语言=&gt;管理语言设置</p>
<p><img src="/2019/12/27/win10使用问题/image-20191227115449769.png" alt="image-20191227115449769"></p>
<h2 id="取消FN键盘"><a href="#取消FN键盘" class="headerlink" title="取消FN键盘"></a>取消FN键盘</h2><p>Fn + Esc 恢复或取消F1~F12</p>
<h2 id="WLAN不见了"><a href="#WLAN不见了" class="headerlink" title="WLAN不见了"></a>WLAN不见了</h2><p>麻烦右键1535驱动，选择卸载设备，不要勾选对话框，直接点击卸载</p>
<p>完成后，机器关机，然后开机后，马上连续敲击F2，进入后点击右下角restore setting，选择bios default，选择OK，然后点击右下角exit</p>
<p>重启电脑后，进入系统里查看wifi情况</p>
<p>选择网络还是没有无线，接下来考虑的是驱动或者系统问题</p>
<p>麻烦您右键左下角开始按钮–选择windows powershell（管理员 win+x），输入：netsh winsock  reset，回车运行，成功后，重启电脑</p>
<h2 id="充电设置"><a href="#充电设置" class="headerlink" title="充电设置"></a>充电设置</h2><p>开机F2进入BIOS设置，选择Power Managerment，选择Primary Battery Charge Configuration</p>
<h2 id="系统清理"><a href="#系统清理" class="headerlink" title="系统清理"></a>系统清理</h2><p>C:\Users\zhangbb\AppData</p>
<p>C:\Windows\Installer</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>win + d  窗口最小化，显示桌面</p>
<p>win + e 打开我的电脑</p>
<p>win + x 设备管理器，任务管理器，磁盘管理，设置</p>
<p>win + r 运行。。。</p>
<p> <strong>ctrl + alt + delete</strong> 注销，切换用户，任务管理器</p>
<p> <strong>ctrl + shift + delete</strong> 快速清除浏览器缓存</p>
<h2 id="github无法访问"><a href="#github无法访问" class="headerlink" title="github无法访问"></a>github无法访问</h2><p>电脑管家=&gt;工具箱=&gt;DNS优选</p>
<p>常用DNS：<br>阿里云 (223.5.5.5,  223.6.6.6 )<br>Google Public DNS （8.8.8.8， 8.8.4.4）<br>腾讯 119.29.29.29</p>
<p>C:\Windows\System32\drivers\etc 一般用不到，能访问的指定合适的DNS肯定可以访问</p>
<h2 id="c盘清理"><a href="#c盘清理" class="headerlink" title="c盘清理"></a>c盘清理</h2><p>C:\Users\zhangbb\AppData\Roaming\PCDr    dell诊断支持使用</p>
<p>C:\Program Files\WindowsApps   应用商店，不用可删除</p>
<blockquote>
<p>windows.old 升级备份，可删除</p>
</blockquote>
<blockquote>
<p> 删除应用qq/微信缓存</p>
</blockquote>
<blockquote>
<p>关闭休眠：Cortana=&gt;cmd=&gt;以管理员身份运行=&gt;powercfg /h off </p>
</blockquote>
<blockquote>
<p>删除临时文件：设置=&gt;系统=&gt;存储=&gt;C盘=&gt;临时文件=&gt;删除文件</p>
</blockquote>
<blockquote>
<p>虚拟内存更改：我的电脑=&gt;右键属性=&gt;高级系统设置=&gt;高级=&gt;（视觉效果)设置=&gt;高级=&gt;(虚拟内存)更改</p>
</blockquote>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p><a href="https://chocolatey.org/" target="_blank" rel="noopener">Chocolatey Software | Chocolatey - The package manager for Windows</a></p>
<h2 id="网络适配器不见了"><a href="#网络适配器不见了" class="headerlink" title="网络适配器不见了"></a>网络适配器不见了</h2><p>网络相关服务被禁止了</p>
<ol>
<li>win+R =&gt; msconfig =&gt; 服务 =&gt; 全部启用</li>
</ol>
<h2 id="禁止MaxxAudio图标"><a href="#禁止MaxxAudio图标" class="headerlink" title="禁止MaxxAudio图标"></a>禁止MaxxAudio图标</h2><p>任务管理器 =&gt;　启动　=&gt;  禁止</p>
<h2 id="进入安全模式"><a href="#进入安全模式" class="headerlink" title="进入安全模式"></a>进入安全模式</h2><p>win + R =&gt;　msconfig ，选择  引导=&gt; 安全引导=＞最小 =&gt; 确定</p>
<p><img src="/2019/12/27/win10使用问题/image-20201218101725735.png" alt="image-20201218101725735"></p>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>win + PrtScr ， 截取最前面的窗口，图片保存在我的电脑=》图片=》屏幕截图</p>
<p>win + shift + s , 区域截图，Ctrl+V 可以粘贴</p>
<p>win + w 屏幕绘图 ， 叫出Windows Ink工作区， 自己绘图，非常给力</p>
<p>edge 截取长图，F12=》切换仿真设备(元素旁边按钮) =》捕获全尺寸屏幕截图</p>
<p><img src="/2019/12/27/win10使用问题/2.png" alt=""></p>
<h2 id="chrome-edge"><a href="#chrome-edge" class="headerlink" title="chrome/edge"></a>chrome/edge</h2><p>拖入.crx开启功能</p>
<ul>
<li>Chrome 浏览器，地址栏输入并回车：<ul>
<li><code>chrome://flags/#extensions-on-chrome-urls</code></li>
</ul>
</li>
<li>Edge 新版浏览器，地址栏输入并回车：<ul>
<li><code>edge://flags/#extensions-on-edge-urls</code></li>
</ul>
</li>
</ul>
<p><img src="/2019/12/27/win10使用问题/image-20210124125714869.png" alt="image-20210124125714869"></p>
<h2 id="开启多线程下载"><a href="#开启多线程下载" class="headerlink" title="开启多线程下载"></a>开启多线程下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://flags/#enable-parallel-downloading</span><br></pre></td></tr></table></figure>
<h2 id="无线投屏到电视"><a href="#无线投屏到电视" class="headerlink" title="无线投屏到电视"></a>无线投屏到电视</h2><p>设置=&gt; 系统</p>
<p><img src="/2019/12/27/win10使用问题/image-20210129155340049.png" alt="image-20210129155340049"></p>
<h2 id="windows镜像下载"><a href="#windows镜像下载" class="headerlink" title="windows镜像下载"></a>windows镜像下载</h2><p><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></p>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>下载工具<br><a href="https://zhuanlan.zhihu.com/p/28370071" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28370071</a><br>m3u8下载工具<br><a href="https://sspai.com/post/61738" target="_blank" rel="noopener">https://sspai.com/post/61738</a></p>
<h2 id="便签"><a href="#便签" class="headerlink" title="便签"></a>便签</h2><p>搜索 <strong>Sticky Notes</strong> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/13/load-balance问题分分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/13/load-balance问题分分析/" itemprop="url">load-balance问题分分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-13T13:55:49+08:00">
                2019-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/12/13/load-balance问题分分析/" class="leancloud_visitors" data-flag-title="load-balance问题分分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/11/brief/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/11/brief/" itemprop="url">brief</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-11T09:59:29+08:00">
                2019-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/12/11/brief/" class="leancloud_visitors" data-flag-title="brief">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><ul>
<li>姓名：</li>
<li>出生年月：1988.12</li>
<li>学历：本科/自动化专业/浙江工业大学之江学院</li>
<li>毕业时间：2011.7</li>
<li>期望职位: Linux c++ 开发</li>
<li>手机: </li>
<li>Email: </li>
</ul>
<h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="亚信软件-2016-4-至今"><a href="#亚信软件-2016-4-至今" class="headerlink" title="亚信软件(2016.4~至今)"></a>亚信软件(2016.4~至今)</h2><ul>
<li>负责计费系统xxx</li>
<li>主要参与了北京物联网, 浙江计费中心建设, 5G等项目</li>
<li>具体技术: Linux c++, zk, docker, rpc, http2, mysql</li>
</ul>
<h2 id="浙江大华技术股份有限公司-2015-10-2016-4"><a href="#浙江大华技术股份有限公司-2015-10-2016-4" class="headerlink" title="浙江大华技术股份有限公司(2015.10~2016.4)"></a>浙江大华技术股份有限公司(2015.10~2016.4)</h2><ul>
<li>在网络平台部负责定制化需求开发<br>车载设备/监控设备: 定位, 路况汇报, 抓拍, 测速, 音视频控制等业务功能</li>
<li>具体技术：Linux c++</li>
</ul>
<h2 id="亚信软件-2012-7-2015-10"><a href="#亚信软件-2012-7-2015-10" class="headerlink" title="亚信软件(2012.7~2015.10)"></a>亚信软件(2012.7~2015.10)</h2><ul>
<li>负责计费系统部分模块开发运维 及 需求设计分析</li>
<li>主要参与了在线计费, 贵州双中心等项目</li>
<li>具体技术：Linux c++ , Lua, Oracle</li>
</ul>
<h2 id="杭州凯宇信息技术有限公司-2010-12-2012-6"><a href="#杭州凯宇信息技术有限公司-2010-12-2012-6" class="headerlink" title="杭州凯宇信息技术有限公司(2010.12~2012.6)"></a>杭州凯宇信息技术有限公司(2010.12~2012.6)</h2><ul>
<li>负责IM服务器后端开发, 完成乐聊/百视汇多媒体社交APP服务端开发</li>
<li>具体技术：Linux c++, libevent/spserver, postgresql, memcached, tcpdump/wireshark工具</li>
</ul>
<h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><h2 id="浙江5G项目"><a href="#浙江5G项目" class="headerlink" title="浙江5G项目"></a>浙江5G项目</h2><p>负责系统中解码，将JSON消息格式转换成内部消息格式<br>负载均衡模块开发，线程池/对象池</p>
<h2 id="浙江计费中心建设项目"><a href="#浙江计费中心建设项目" class="headerlink" title="浙江计费中心建设项目"></a>浙江计费中心建设项目</h2><p>服务化架构升级，负责系统业务模块改造方案及部分模块设计开发<br>重构资费引擎批价模块, (引入c++11新特性, 设计模式, 资费数据用共享内存), 提高可维护性<br>查询服务模块，高并发的网络服务库, (查询量和性能)<br>内存数据库 插件开发(服务接口和路由和导出)和优化(查重优化)</p>
<h2 id="北京物联网项目"><a href="#北京物联网项目" class="headerlink" title="北京物联网项目"></a>北京物联网项目</h2><p>负责系统总体设计方案和实施, 计费流程引入乐观锁和流量分片, 性能提升了多少</p>
<h2 id="在线计费项目"><a href="#在线计费项目" class="headerlink" title="在线计费项目"></a>在线计费项目</h2><p>负责在线计费流程优化, 压力测试和优化，增加KPI指标模块衡量各个模块性能</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/v8实施经验分享/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/v8实施经验分享/" itemprop="url">v8实施经验分享</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-09T11:14:30+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目经验/" itemprop="url" rel="index">
                    <span itemprop="name">项目经验</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/12/09/v8实施经验分享/" class="leancloud_visitors" data-flag-title="v8实施经验分享">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h1><p>照搬浙江V8代码，做适配修改，具体要点如下：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>xc</td>
<td>xcd模板实现</td>
</tr>
<tr>
<td>批价</td>
<td>结构调整(接口离线/在线/漫游/回退/5G融合计费)，去掉按量接口，提醒等相关功能；                                    xc查询接口，在线冲销(最好封装成接口)，科目转换，新增业务功能</td>
</tr>
<tr>
<td>计费mdb</td>
<td>调整上下行包定义，表定义，业务接口具体逻辑                                                                                   mapreduce 路由适配</td>
</tr>
<tr>
<td>查询代理</td>
<td>TG(socket消息收发) 和 工具(压测和对账) 直接用，TP 业务接口做调整</td>
</tr>
</tbody>
</table>
<h1 id="数据割接"><a href="#数据割接" class="headerlink" title="数据割接"></a>数据割接</h1><p>1）PM_EXPRESSIONS 条件表达式，USE_TRIGGER按模块区分<br>2）科目转换</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>1）V5/V8 自测流程搭建，便于开发去复现问题<br>2）编译时去掉O2，便于GDB调试</p>
<h1 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h1><h2 id="1）xc"><a href="#1）xc" class="headerlink" title="1）xc"></a>1）xc</h2><p>a）建议 index 定义尽量显示，少用indexs=“KEY”，查询sqlite文件时方便点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;container indexs=<span class="string">"PROD_PROP_ID"</span> name=<span class="string">"PM_PROD_BILL_EXT_PROP"</span> type=<span class="string">"hash_multimap"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>b） PM_CURVE_SEGMENT.TAIL_ROUND 等 小数精度加载到xc时转换成了整数，注意下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TO_CHAR(A.RATE_ROUND, '0D99') AS RATE_ROUND</span><br></pre></td></tr></table></figure>
<h2 id="2）批价"><a href="#2）批价" class="headerlink" title="2）批价"></a>2）批价</h2><p>对账问题，没有太大参考意义，具体情况具体分析。基本都是某个字段的差异(STD_UNIT, CHARGE1) </p>
<h2 id="3）计费mdb"><a href="#3）计费mdb" class="headerlink" title="3）计费mdb"></a>3）计费mdb</h2><p>a）mdb无缝ck，代码中去掉sleep相关操作</p>
<p>b)   统一设置 MDB CK 后缀名，主端格式为 <em>.mdb.xy.yyyymmdd  , 备端 </em>.mdb.stb.xy.yyyymmdd </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RATMDB_CAMTFreeResource.mdb<span class="number">.01</span><span class="number">.20191115</span></span><br></pre></td></tr></table></figure>
<p>c）批价查询接口，查多个mdb时，一个查询/接收完后再顺序处理下一个mdb(mapreduce 重载ReqAndRes4Queryratingmdb)</p>
<p>d）mapreduce 在gmake clean_all  会删除rdl 对应的<em>h/</em>cpp 文件，gmake install_headers 后自动重新生成，覆盖掉了开发提交的修改。在mapreduce 的Makefile中去掉IMPL_RDL = .rdl 依赖，由开发提交和控制rdl 对应的h/cpp 文件。后续QA编译不会再自动生成rdl接口代码文件。</p>
<p>e）计费MDB A2 HA和容 在binlog乱序时 异常退出，主端先执行truncate(告警导出)，再执行insert(批价更新) ，备端先执行了insert ，导致出错。</p>
<p><img src="/2019/12/09/v8实施经验分享/image-20191209112959060.png" alt="image-20191209112959060"></p>
<h2 id="4）查询代理"><a href="#4）查询代理" class="headerlink" title="4）查询代理"></a>4）查询代理</h2><p>对账一把，具体问题具体分析</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/备战2020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/11/备战2020/" itemprop="url">备战2020</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-11T00:00:44+08:00">
                2019-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/11/11/备战2020/" class="leancloud_visitors" data-flag-title="备战2020">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简历重构"><a href="#简历重构" class="headerlink" title="简历重构"></a>简历重构</h1><p><a href="https://www.zhihu.com/question/29693016" target="_blank" rel="noopener">经验</a></p>
<h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>项目描述两三行，然后概括下我大概做了哪几个模块，完了。 </p>
<p>找2-3个亮点, 一句话高度概括，突出亮点。</p>
<p>比如：</p>
<blockquote>
<p> 我负责这个系统中爬虫的开发，终端控制管理，店铺管理</p>
</blockquote>
<blockquote>
<p>负责系统中爬虫模块的开发，用于爬取影片的各种信息，包括年份，介绍，主演信息等</p>
</blockquote>
<blockquote>
<p>独立开发多线程影片信息爬虫工具， 并针对线程池性能、网络异常以及反爬虫措施进行多次优化，容错性良好并达到并发请求30+的QPS</p>
</blockquote>
<p>面试的人有问题可以提，自己也可以掌握主动权，把握方向。</p>
<h1 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h1><p>1 简历一行行看，不要给自己挖坑</p>
<p>2 心态平和，正常表达，逻辑清晰有条理</p>
<p>3 缘分和运气</p>
<p>4 要有信念， 努力+坚持</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p><img src="/2019/11/11/备战2020/image-20191111152712592.png" alt="image-20191111152712592"></p>
<h1 id="学习准备"><a href="#学习准备" class="headerlink" title="学习准备"></a>学习准备</h1><p><a href="https://github.com/huihut/interview" target="_blank" rel="noopener"> C/C++ 技术面试基础知识总结 </a></p>
<p><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener"> 技术面试必备基础 </a></p>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><p>const / static / this / inline / volatile / assert / sizeof / #program pack(n) / 位域 </p>
<p>extern / struct class union / explicit / friend / using / enum / decltype </p>
<p>引用 / 成员初始化列表  / 面向对象 / 虚析构函数 / 纯虚函数 / 虚函数 纯虚函数 </p>
<p>虚函数表 指针 / 虚继承 / 模板类 函数 虚函数 / 抽象类 接口类 聚合类 / 内存分配管理 </p>
<p>delete this / 定义只能在堆或栈上生成的类 / 智能指针 / 强制类型转换运算符号 </p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>(stack overflow 难题清单)</p>
<p>[<a href="https://github.com/ethsonliu/stackoverflow-top-cpp/tree/master/question]" target="_blank" rel="noopener">https://github.com/ethsonliu/stackoverflow-top-cpp/tree/master/question]</a></p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>修饰指针，分为指向常量的指针和指针常量</p>
<p>修改是引用，常量引用，避免拷贝和修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p <span class="comment">//指针常量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> a，b；</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a; <span class="comment">//常量指针</span></span><br><span class="line"><span class="keyword">int</span> a，b；</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> b = &amp;a;<span class="comment">//指向常量的指针常量</span></span><br></pre></td></tr></table></figure>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li><p>修饰变量，存储在静态区，在main函数前分配了空间</p>
</li>
<li><p>修饰函数，表明函数作用范围，仅在定义该函数的文件内使用。一般为了避免与其他命名空间函数重名</p>
</li>
<li><p>修饰成员变量，不需要生成对象就能访问，只保存一份</p>
</li>
<li><p>修饰成员函数，不需要生成对象就能访问，在static函数内不能访问非静态成员</p>
</li>
</ol>
<h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol>
<li><p>定义：隐含于非静态成员函数的特殊指针，指向调用该函数的对象</p>
</li>
<li><p>当一个对象调用成员函数时，编译程序先将对象地址赋值给this指针，存取数据成员都隐式使用this指针</p>
</li>
<li><p>当一个成员函数被调用时，自动向它传递一个隐含的参数(指向成员函数所在对象的指针)</p>
</li>
<li><p>this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（ 不能对这种对象的数据成员进行赋值操作 ）</p>
</li>
<li><p>this指针是一个右值，不能取地址 , 不能操作(&amp;this)</p>
</li>
<li><p>应用场景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用, 返回本对象的引用</span></span><br><span class="line"><span class="function">A&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_a += a;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免对同一对象赋值</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;other) </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 实现数据结构，如list</span></span><br><span class="line"></span><br><span class="line">_reverse_iterator_impl <span class="keyword">operator</span>++()</span><br><span class="line">&#123; </span><br><span class="line">    _M_value = _M_value-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><h4 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a><strong>为什么需要</strong></h4><p>效率高，省去函数调用开销，内联函数会在调用时 “内联的” 展开</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">则调用： <span class="built_in">cout</span>&lt;&lt;max(a, b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">在编译时展开为： <span class="built_in">cout</span>&lt;&lt;(a &gt; b ? a : b)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h4><p>1)相当于把内联函数里面的内容写在调用内联函数处</p>
<p>2)相当于不用执行进入函数的步骤，直接执行函数体 </p>
<p>3)相当于宏定义，比宏多了类型检查，具有函数特征</p>
<p>4)编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数 </p>
<p>5)在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数 </p>
<h4 id="编译器对内联的处理"><a href="#编译器对内联的处理" class="headerlink" title="编译器对内联的处理"></a>编译器对内联的处理</h4><p>1）将内联函数体复制到调用点处</p>
<p>2）为内联函数中的局部变量分配空间</p>
<p>3）将内联函数的输入参数和返回值映射到调用方法的局部变量空间中</p>
<p>4） 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO） </p>
<p>5） 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数 </p>
<p>6） 在类声明中定义的函数(函数实现)，除了虚函数的其他函数都会自动隐式地当成内联函数 </p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<p>1） 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度 </p>
<p>2） 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会 </p>
<p>3） 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能 </p>
<p>4） 内联函数在运行时可调试，而宏定义不可以 </p>
<p>缺点：</p>
<p>1） 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间 </p>
<p>2） inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接 </p>
<p>3）是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器    </p>
<h4 id="虚函数可以内联吗"><a href="#虚函数可以内联吗" class="headerlink" title="虚函数可以内联吗"></a>虚函数可以内联吗</h4><p>1） 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联 </p>
<p>2） 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联 </p>
<p>3）  inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>1）volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p>
<p>2）const 可以是 volatile （如只读的状态寄存器）</p>
<p>3）指针可以是volatile </p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p> 断言，是宏，而非函数。</p>
<p> assert 宏的原型定义在 <code>（C）、</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include</code> 之前 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define NDEBUG          // 加上这行，则 assert 不可用</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">assert( p != NULL );    // assert 不可用</span><br></pre></td></tr></table></figure>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p> sizeof 对数组，得到整个数组所占空间大小 ; sizeof 对指针，得到指针本身所占空间大小。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p> 设定结构体、联合以及类成员变量以 n 字节方式对齐 。</p>
<p>  一般编译器会处理内存对齐，为什么需要？</p>
<blockquote>
<p>平台移植，一些平台只能取某些特定地址处取特定类型数据 </p>
<p>硬件原因，对齐后CPU访问内存速度提升，读取按2/4/8/16读取到寄存器中，不对齐多次读取特殊处理</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"><span class="comment">// #pragma pack(push,4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(test)=<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line">#pragma pack(push,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">typedef</span> struct &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>	Rate;				<span class="comment">// Playback rate (hertz).</span></span><br><span class="line">	<span class="keyword">long</span>	Size;				<span class="comment">// Size of data (bytes).</span></span><br><span class="line">	<span class="keyword">long</span>	UncompSize;				<span class="comment">// Size of data (bytes).</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> Flags;	<span class="comment">// Holds flags for info</span></span><br><span class="line">								<span class="comment">//  1: Is the sample stereo?</span></span><br><span class="line">								<span class="comment">//  2: Is the sample 16 bits?</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> Compression;	<span class="comment">// What kind of compression for this sample?</span></span><br><span class="line">&#125; AUDHeaderType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>
<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 </p>
<ul>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a:<span class="number">4</span>;    </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> :<span class="number">0</span>;  <span class="comment">/* 空域, 剩余28bit补全0 */</span>     </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b:<span class="number">4</span>; <span class="comment">/* 从下一单元开始存放 */</span>     </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c:<span class="number">4</span>;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 整个结构体的总大小为最宽基本类型成员大小的整数倍</span></span><br><span class="line"><span class="keyword">sizeof</span>(bs)=<span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>)=<span class="number">4</span></span><br><span class="line">    </span><br><span class="line">#include &lt;<span class="built_in">bitset</span>&gt;</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">2</span>&gt; foo(<span class="number">12</span>);　　<span class="comment">//12的二进制为1100（长度为４），但foo的size=2，只取后面部分，即00</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"100101"</span>;　　</span><br><span class="line"><span class="built_in">bitset</span>&lt;4&gt; bar(s);　　<span class="comment">//s的size=6，而bitset的size=4，只取前面部分，即1001</span></span><br><span class="line">foo&amp;bar;</span><br><span class="line">foo^bar;</span><br><span class="line">foo|bar;</span><br><span class="line">~foo;</span><br><span class="line"><span class="keyword">if</span>(foo[<span class="number">0</span>] == <span class="literal">false</span>);</span><br><span class="line">foo.to_string();</span><br><span class="line">foo.to_ullong();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">bitset</span>&gt;(C++<span class="number">11</span>)散列支持</span><br></pre></td></tr></table></figure>
<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>1）被 extern 限定的函数或变量是 extern 类型的（ 不能和static同时修饰 ）。 B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可, 在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数 </p>
<p>2）被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">NAMESPACE_BILLING40_FRAME CThread* <span class="title">create_instanceRating</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="struct-class"><a href="#struct-class" class="headerlink" title="struct/class"></a>struct/class</h3><p>struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ 可以省略struct</span></span><br></pre></td></tr></table></figure>
<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态 。具有如下特点：</p>
<p>1）默认访问控制符为 public，不能包含 protected 成员或 private 成员<br>2）可以含有构造函数、析构函数<br>3）不能继承自其他类，不能作为基类，不能含有虚函数，不能含有引用类型的成员<br>4）匿名 union 在定义所在作用域可直接访问 union 成员<br>5）全局匿名联合必须是静态（static）的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="explicit-显示-关键字"><a href="#explicit-显示-关键字" class="headerlink" title="explicit(显示)关键字"></a>explicit(显示)关键字</h3><p>1）修饰构造函数时，可以防止隐式转换和复制初始化<br>2）修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	A a2 = <span class="number">1</span>;		<span class="comment">// OK：复制初始化</span></span><br><span class="line">	A a3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	A a4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">	A a5 = (A)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换 </span></span><br><span class="line">	doA(<span class="number">1</span>);			<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (a1);		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a6（a1）;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a7 = a1;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	B b2 = <span class="number">1</span>;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">	B b3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	B b4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">	B b5 = (B)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">	doB(<span class="number">1</span>);			<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (b1);		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="keyword">bool</span> b7 = b1;		<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="friend友元类和友元函数"><a href="#friend友元类和友元函数" class="headerlink" title="friend友元类和友元函数"></a>friend友元类和友元函数</h3><p>1）能访问私有函数</p>
<p>2）破坏封装性</p>
<p>3）友元关系单向不可传递</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; pOut, <span class="keyword">const</span> CBSPkgDetail&amp; pElement )</span><br><span class="line">	&#123;</span><br><span class="line">		pOut &lt;&lt; <span class="string">" CBSPkgDetail -- pkg_id:"</span> &lt;&lt; pElement.m_nPkgId</span><br><span class="line">			&lt;&lt; <span class="string">" numerrator:"</span>&lt;&lt;pElement.m_nNumerator</span><br><span class="line">			&lt;&lt; <span class="string">" denominator:"</span>&lt;&lt;pElement.m_nDenominator;</span><br><span class="line">		<span class="keyword">return</span> pOut;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_nPkgId;</span><br><span class="line">	<span class="keyword">int</span> m_nNumerator;</span><br><span class="line">	<span class="keyword">int</span> m_nDenominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">set_show</span><span class="params">(<span class="keyword">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_show</span><span class="params">(<span class="keyword">int</span> x, A &amp;a)</span>  <span class="comment">//友元函数定义，为了访问类A中的成员</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">    set_show(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span>                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>             //友元类定义，为了访问类<span class="title">A</span>中的成员</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_show</span><span class="params">(<span class="keyword">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; <span class="built_in">cout</span>&lt;&lt;a.data&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">c</span>;</span></span><br><span class="line">    c.set_show(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p>1）使用namespace<br>2） 在 C++11 中，派生类能够重用其直接基类定义的构造函数<br>3）在 C++11 中，定义别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。</span></span><br><span class="line"><span class="comment">// 生成如下类型构造函数：</span></span><br><span class="line">Derived(parms) : Base(args) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++11</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>
<h3 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><h3 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定作用域的枚举类型. </span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> :</span> <span class="keyword">int</span>&#123; <span class="comment">//这里的:int指出了该enum的潜在类型. </span></span><br><span class="line"> Iphone,</span><br><span class="line"> Nokia,</span><br><span class="line"> Moto</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定类型</span></span><br><span class="line"><span class="keyword">enum</span> AttachType : <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;</span><br><span class="line">	ATTACH_NONE=<span class="number">0x00</span>,				</span><br><span class="line">	ATTACH_CELL=<span class="number">0x01</span>,	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不限定</span></span><br><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p> 用于检查实体的声明类型或表达式的类型及值分类 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>左值引用，常规引用，一般表示对象的身份。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;    <span class="comment">// 将左值看成是一个可以获取地址的量，它可以用来标识一个对象或函数</span></span><br><span class="line"><span class="keyword">int</span>&amp; rx = x;   <span class="comment">// 定义引用时必须初始化</span></span><br></pre></td></tr></table></figure>
<p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; rrx = 200; // 右值定义在c++11中用&amp;&amp;</span><br><span class="line">int x = 20;    // 左值</span><br><span class="line">int&amp;&amp; rx = x * 2;  // x*2的结果是一个右值，rx延长其生命周期</span><br><span class="line">int&amp;&amp; rrx1 = x;   // 非法：右值引用无法被左值初始化, 因为左值不需要延长生命周期</span><br><span class="line">const int&amp;&amp; rrx2 = x;  // 非法：右值引用无法被左值初始化</span><br></pre></td></tr></table></figure>
<p>右值引用，可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding）：</p>
<ul>
<li>将内存的所有权从一个对象转移动另一个对象，高效的移动来替换低效率的复制，对象的移<br>动语义需要实现移动构造函数和移动赋值运算符(默认生成), STL等模板库(vector,list)已支持</li>
<li>定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其他函数，且保证<br>目标函数接受的参数的类型与传递给模板函数的类型相同。</li>
</ul>
<p>引用折叠规则(用于参数类型推导，参数可能是左值或右值)</p>
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查类是否有移动语义</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_move_constructible&lt;MyString&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器区分了左值和右值，对右值调用了转移构造函数和转移赋值操作符</span></span><br><span class="line">MyString(MyString&amp;&amp; str) &#123; </span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Constructor is called! source: "</span> &lt;&lt; str._data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">   _len = str._len; </span><br><span class="line">   _data = str._data; </span><br><span class="line">   str._len = <span class="number">0</span>; </span><br><span class="line">   str._data = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) &#123; </span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Assignment is called! source: "</span> &lt;&lt; str._data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123; </span><br><span class="line">     _len = str._len; </span><br><span class="line">     _data = str._data; </span><br><span class="line">     str._len = <span class="number">0</span>; </span><br><span class="line">     str._data = <span class="literal">NULL</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> MyString a; </span><br><span class="line"> a = MyString(<span class="string">"Hello"</span>); </span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MyString&gt; vec; </span><br><span class="line"> vec.push_back(MyString(<span class="string">"World"</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Move Assignment is called! source: Hello </span><br><span class="line">Move Constructor is called! source: World</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值引用当做右值引用来使用，使用std::move</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  T tmp(std::move(a));</span><br><span class="line">  a = <span class="built_in">std</span>::move(b); </span><br><span class="line">  b = <span class="built_in">std</span>::move(tmp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>;   <span class="comment">// 接收左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">string</span>&amp;&amp; str)</span></span>;        <span class="comment">// 接收右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确传递，定义一次，接受一个右值引用的参数，就能够将所有的参数类型原封不动的传递给目标函数</span></span><br><span class="line"><span class="comment">// std::forward</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(T&amp;&amp; val)</span> </span>&#123; </span><br><span class="line">	process_value(val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右值实参为右值引用，左值实参仍然为左值引用（就是参数的属性不变）</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">1</span>; </span><br><span class="line">forward_value(a); <span class="comment">// int&amp; </span></span><br><span class="line">forward_value(b); <span class="comment">// const int&amp; </span></span><br><span class="line">forward_value(<span class="number">2</span>); <span class="comment">// int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><p>好处</p>
<p>1）更高效：少了一次调用默认构造函数的过程。</p>
<p>2）有些场合必须要用初始化列表：</p>
<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化 </li>
</ol>
<h3 id="initializer-list-列表初始化"><a href="#initializer-list-列表初始化" class="headerlink" title="initializer_list 列表初始化"></a>initializer_list 列表初始化</h3><p> 用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li><p><code>public</code> 成员：可以被任意实体访问</p>
</li>
<li><p><code>protected</code> 成员：只允许被子类及本类的成员函数访问</p>
</li>
<li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有继承</td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td>私有继承</td>
<td>private</td>
<td>private</td>
<td>不可见</td>
</tr>
<tr>
<td>保护继承</td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
</tr>
</tbody>
</table>
<p>私有继承子类也不能转换成相应的基类。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态是以封装和继承为基础的，c++多态分类及实现：<br>1）重载多态（编译期）：函数重载，运算符重载<br>2）子类型多态（运行期）：虚函数<br>3）参数多态性(编译期)：类模板，函数模板<br>4）强制多态(运行/编译期)：基本类型转换，自定义类型转换</p>
<p>静态多态就是函数重载</p>
<p>动态多态</p>
<ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
</ul>
<p>注意：<br>1）非类成员函数不能是虚函数<br>2）静态函数(static)不能是虚函数<br>3）构造函数不能是虚函数(因为在调用构造函数时，虚表指针还没有在对象空间中，必须要调用完构造函数后才会生成虚表指针)<br>4）内联函数不能是表现多态时的虚函数，详见内联说明</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的函数，在基类中没有实现，留给派生类去实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h3><p>1）虚函数在子类里面可以不重写，但纯虚函数必须在子类实现才可以实例化类<br>2）虚函数的类用于“实现继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现有子类完成<br>3）带纯虚函数的叫抽象类，这种类不能直接生成对象，而只有被继承实现其虚函数后才能被使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</p>
<h3 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h3><p>1）虚函数指针：在含有虚函数的类对象中，指向虚函数表，在运行时确定。<br>2）虚函数表：在程序只读数据段（ .rodata section ），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个指针，在编译时间根据类的声明创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g++ dump出的名称是其内部继承结构</span></span><br><span class="line">g++ -fdump-<span class="class"><span class="keyword">class</span>-<span class="title">hierarchy</span> -<span class="title">std</span>=<span class="title">c</span>++11 -<span class="title">c</span> <span class="title">test</span>.<span class="title">cpp</span></span></span><br><span class="line"><span class="class">// <span class="title">c</span>++<span class="title">filt</span>导出具有一定可读性的文档 <span class="title">test</span>.<span class="title">cpp</span>.002<span class="title">t</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">cat</span> [<span class="title">g</span>++导出的文档] | <span class="title">c</span>++<span class="title">filt</span> -<span class="title">n</span> &gt; [具有一定可读性的输出文档]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 单继承</span></span><br><span class="line"><span class="class">// 按函数声明顺序，父类虚函数放在子类函数前</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ax;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> bx;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cx;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> override </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">                                                      C VTable（不完整)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>                                              +------------+</span></span><br><span class="line"><span class="class"><span class="title">object</span>                                                | <span class="title">RTTI</span> <span class="title">for</span> <span class="title">C</span> |</span></span><br><span class="line"><span class="class">    0 - <span class="title">struct</span> <span class="title">B</span>                            +-------&gt; +------------+</span></span><br><span class="line"><span class="class">    0 -   <span class="title">struct</span> <span class="title">A</span>                          |         |   <span class="title">C</span>:</span>:f0()  |</span><br><span class="line">    <span class="number">0</span> -     vptr_A -------------------------+         +------------+</span><br><span class="line">    <span class="number">8</span> -     <span class="keyword">int</span> ax                                    |   B::f1()  |</span><br><span class="line">   <span class="number">12</span> -   <span class="keyword">int</span> bx                                      +------------+</span><br><span class="line">   <span class="number">16</span> - <span class="keyword">int</span> cx                                        |   C::f2()  |</span><br><span class="line"><span class="keyword">sizeof</span>(C): <span class="number">24</span>    align: <span class="number">8</span>                             +------------+</span><br><span class="line">                                                   </span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="comment">// 每个父类都有一个虚函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ax;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> bx;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cx;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> override </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> override </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">                                                <span class="function">C <span class="title">Vtable</span> <span class="params">(<span class="number">7</span> entities)</span></span></span><br><span class="line">                                                +--------------------+</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>                                        | <span class="title">offset_to_top</span> (0)  |</span></span><br><span class="line"><span class="class"><span class="title">object</span>                                          +--------------------+</span></span><br><span class="line"><span class="class">    0 - <span class="title">struct</span> <span class="title">A</span> (<span class="title">primary</span> <span class="title">base</span>)                 |     <span class="title">RTTI</span> <span class="title">for</span> <span class="title">C</span>     |</span></span><br><span class="line"><span class="class">    0 -   <span class="title">vptr_A</span> -----------------------------&gt; +--------------------+       </span></span><br><span class="line"><span class="class">    8 -   <span class="title">int</span> <span class="title">ax</span>                                |       <span class="title">C</span>:</span>:f0()      |</span><br><span class="line">   <span class="number">16</span> - <span class="class"><span class="keyword">struct</span> <span class="title">B</span>                                +--------------------+</span></span><br><span class="line"><span class="class">   16 -   <span class="title">vptr_B</span> ----------------------+        |       <span class="title">C</span>:</span>:f1()      |</span><br><span class="line">   <span class="number">24</span> -   <span class="keyword">int</span> bx                       |        +--------------------+</span><br><span class="line">   <span class="number">28</span> - <span class="keyword">int</span> cx                         |        | offset_to_top (<span class="number">-16</span>)|</span><br><span class="line"><span class="keyword">sizeof</span>(C): <span class="number">32</span>    align: <span class="number">8</span>              |        +--------------------+</span><br><span class="line">                                       |        |     RTTI <span class="keyword">for</span> C     |</span><br><span class="line">                                       +------&gt; +--------------------+</span><br><span class="line">                                                |    Thunk C::f1()   |</span><br><span class="line">                                                +--------------------+</span><br><span class="line"><span class="comment">// Thunk 作用是找到C::f1()的地址(偏移地址-16)</span></span><br><span class="line"><span class="comment">// 构造顺序A,B,C，析构C,B,A</span></span><br><span class="line">B* pb = <span class="keyword">new</span> C();</span><br><span class="line">pb-&gt;f1();</span><br><span class="line">                                           </span><br><span class="line">-----多重继承</span><br><span class="line"><span class="number">3340</span> Vtable <span class="keyword">for</span> A                                                                                                       </span><br><span class="line"><span class="number">3341</span> A::vtable <span class="keyword">for</span> A: <span class="number">3u</span> entries</span><br><span class="line"><span class="number">3342</span> <span class="number">0</span>     (<span class="keyword">int</span> (*)(...))<span class="number">0</span></span><br><span class="line"><span class="number">3343</span> <span class="number">8</span>     (<span class="keyword">int</span> (*)(...))(&amp; typeinfo <span class="keyword">for</span> A)</span><br><span class="line"><span class="number">3344</span> <span class="number">16</span>    (<span class="keyword">int</span> (*)(...))A::f0</span><br><span class="line"><span class="number">3345</span> </span><br><span class="line"><span class="number">3346</span> Class A</span><br><span class="line"><span class="number">3347</span>    size=<span class="number">16</span> align=<span class="number">8</span></span><br><span class="line"><span class="number">3348</span>    base size=<span class="number">12</span> base align=<span class="number">8</span></span><br><span class="line"><span class="number">3349</span> A (<span class="number">0x0</span>x2b37ee087600) <span class="number">0</span></span><br><span class="line"><span class="number">3350</span>     vptr=((&amp; A::vtable <span class="keyword">for</span> A) + <span class="number">16u</span>)</span><br><span class="line"><span class="number">3351</span> </span><br><span class="line"><span class="number">3352</span> Vtable <span class="keyword">for</span> B</span><br><span class="line"><span class="number">3353</span> B::vtable <span class="keyword">for</span> B: <span class="number">3u</span> entries</span><br><span class="line"><span class="number">3354</span> <span class="number">0</span>     (<span class="keyword">int</span> (*)(...))<span class="number">0</span></span><br><span class="line"><span class="number">3355</span> <span class="number">8</span>     (<span class="keyword">int</span> (*)(...))(&amp; typeinfo <span class="keyword">for</span> B)</span><br><span class="line"><span class="number">3356</span> <span class="number">16</span>    (<span class="keyword">int</span> (*)(...))B::f1</span><br><span class="line"><span class="number">3357</span> </span><br><span class="line"><span class="number">3358</span> Class B</span><br><span class="line"><span class="number">3359</span>    size=<span class="number">16</span> align=<span class="number">8</span></span><br><span class="line"><span class="number">3360</span>    base size=<span class="number">12</span> base align=<span class="number">8</span></span><br><span class="line"><span class="number">3361</span> B (<span class="number">0x0</span>x2b37ee087660) <span class="number">0</span></span><br><span class="line"><span class="number">3362</span>     vptr=((&amp; B::vtable <span class="keyword">for</span> B) + <span class="number">16u</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3364</span> Vtable <span class="keyword">for</span> C</span><br><span class="line"><span class="number">3365</span> C::vtable <span class="keyword">for</span> C: <span class="number">7u</span> entries</span><br><span class="line"><span class="number">3366</span> <span class="number">0</span>     (<span class="keyword">int</span> (*)(...))<span class="number">0</span></span><br><span class="line"><span class="number">3367</span> <span class="number">8</span>     (<span class="keyword">int</span> (*)(...))(&amp; typeinfo <span class="keyword">for</span> C)</span><br><span class="line"><span class="number">3368</span> <span class="number">16</span>    (<span class="keyword">int</span> (*)(...))C::f0</span><br><span class="line"><span class="number">3369</span> <span class="number">24</span>    (<span class="keyword">int</span> (*)(...))C::f1</span><br><span class="line"><span class="number">3370</span> <span class="number">32</span>    (<span class="keyword">int</span> (*)(...))<span class="number">-16</span></span><br><span class="line"><span class="number">3371</span> <span class="number">40</span>    (<span class="keyword">int</span> (*)(...))(&amp; typeinfo <span class="keyword">for</span> C)</span><br><span class="line"><span class="number">3372</span> <span class="number">48</span>    (<span class="keyword">int</span> (*)(...))C::non-<span class="keyword">virtual</span> thunk to C::f1()</span><br><span class="line"><span class="number">3373</span> </span><br><span class="line"><span class="number">3374</span> Class C</span><br><span class="line"><span class="number">3375</span>    size=<span class="number">32</span> align=<span class="number">8</span></span><br><span class="line"><span class="number">3376</span>    base size=<span class="number">32</span> base align=<span class="number">8</span></span><br><span class="line"><span class="number">3377</span> C (<span class="number">0x0</span>x2b37ee120700) <span class="number">0</span></span><br><span class="line"><span class="number">3378</span>     vptr=((&amp; C::vtable <span class="keyword">for</span> C) + <span class="number">16u</span>)</span><br><span class="line"><span class="number">3379</span>   A (<span class="number">0x0</span>x2b37ee0876c0) <span class="number">0</span></span><br><span class="line"><span class="number">3380</span>       primary-<span class="keyword">for</span> C (<span class="number">0x0</span>x2b37ee120700)</span><br><span class="line"><span class="number">3381</span>   B (<span class="number">0x0</span>x2b37ee087720) <span class="number">16</span></span><br><span class="line"><span class="number">3382</span>       vptr=((&amp; C::vtable <span class="keyword">for</span> C) + <span class="number">48u</span>)</span><br><span class="line">-----</span><br></pre></td></tr></table></figure>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>A=&gt;Base, B=&gt;Base, C=&gt;A,B  Base存储了2份， C对象调用Base方法会有二义性问题。</p>
<p>虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态(公共基类存储1份)。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型应用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ios&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ios&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span> :</span> <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><p>1）相同之处：都使用虚指针（占用类存储空间）和虚表（不占类存储空间）</p>
<p>2）不同之处：<br>    虚继承，虚基类存储在在继承类中，只占用存储空间；虚基类表存储的是虚基类相对直接继承类的偏移<br>    虚函数，虚函数不占用类存储空间，虚函数表存储的是虚函数地址</p>
<h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><p>1）模板类中可以使用虚函数<br>2）一个类的成员模板(本身是模板的成员函数)不能是虚函数，不管是普通类还是类模；<br>    因为虚函数表里的虚函数指针是确定的，成员模板无法确定</p>
<h3 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h3><p>1）抽象类：含有纯虚函数的类<br>2）接口类：只含有纯虚函数的抽象类<br>3）聚合类：用户可以直接访问成员，并且具有特殊的初始化语法形式。满足如下特点：<br>    a）所有成员都是public<br>    b）没有定义任何构造函数<br>    c）没有类内初始化<br>    d）没有基类，也没有virtual函数</p>
<h3 id="内存分配管理"><a href="#内存分配管理" class="headerlink" title="内存分配管理"></a>内存分配管理</h3><p>C++内存分配：堆/栈/全局(静态)/常量/ 自由存储区(通过new,delete动态分配和释放对象的抽象概念）</p>
<p>1）malloc：申请指定字节数内存，申请到内存中的初始值不确定<br>2）calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存初始化为0<br>3）realloc：更改以前分配内存长度(增加或减少）。当增加长度时，将以前分配区的内容移动到一个足够大的区域，新增区域内的初始值不确定<br>4）alloca：在栈上申请内存。程序在出栈的时候，会自动释放。但需要注意的是alloca不可移植，在没有传统堆栈的机器上很难实现，所以不宜用在需要广泛移植的程序中。C99中支持变长数组(VLA)可以用来替代alloca</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span> <span class="params">(<span class="keyword">size_t</span> num, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span> <span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * __<span class="function">cdecl <span class="title">alloca</span><span class="params">(<span class="keyword">size_t</span>)</span></span>; <span class="comment">// 有些函数定义成__cdecl宏</span></span><br></pre></td></tr></table></figure>
<p>5) new/delete<br>    a）new/new [] 完成两件事，先调用malloc分配内存，然后调用构造函数创建对象<br>    b）delete/delete [] 完成两件事, 先调用析构函数(清理资源)，再调用free释放空间<br>    c）new 在申请内存时会自动计算所需字节数，而malloc需要我们自己指定</p>
<p>6）定位new  允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// place_address 内存地址指针</span></span><br><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="keyword">new</span> (place_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size]</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test(<span class="keyword">int</span> i): m_i(i) &#123;&#125;</span><br><span class="line">~Test()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"~Test."</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"p="</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  Test* ptr = <span class="keyword">new</span>(p) Test(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; <span class="string">"ptr-&gt;m_i="</span> &lt;&lt; ptr-&gt;m_i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; <span class="string">"ptr="</span> &lt;&lt; ptr&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  ptr = <span class="keyword">new</span>(p+<span class="keyword">sizeof</span>(Test)) Test(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; <span class="string">"ptr-&gt;m_i="</span> &lt;&lt; ptr-&gt;m_i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; <span class="string">"ptr="</span> &lt;&lt; ptr&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h3><p>合法，但：<br>1） 必须保证 this 对象是通过 <code>new</code> 分配的 （不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）<br>2）必须保证是最后一个调用this的成员函数，后面没有继续调用this了</p>
<h3 id="如何定义一个只能在堆上-栈上-生成对象的类"><a href="#如何定义一个只能在堆上-栈上-生成对象的类" class="headerlink" title="如何定义一个只能在堆上(栈上)生成对象的类"></a>如何定义一个只能在堆上(栈上)生成对象的类</h3><p><strong>只能在堆上</strong></p>
<p>1）方法：将析构函数设置为私有<br>2）原因：c++是静态绑定语言，编译器管理栈上的生命周期，编译器在为对象分配栈空间时，会先检查类的析构函数的访问性，若析构函数不能访问，则不能在栈上创建</p>
<p><strong>只能在栈上</strong></p>
<p>1）方法：将new/delete重载为私有<br>2）原因：在堆上生成对象，用new关键字，过程分为两个阶段：new 在堆上找可用内存，分配对象；调用构造函数生成对象。new 设为私有，第一步无法完成</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++标准库STL中，头文件#include <memory><br><strong>1) shared_ptr</strong><br>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</memory></p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 </li>
</ul>
<p><strong>2) weak_ptr</strong><br>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 </p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<p><strong>3) unique_ptr</strong><br> unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 </p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<p><strong>4) auto_ptr</strong><br> 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵(不支持数组和容器)。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr</span></span><br><span class="line">get() <span class="comment">// 获取原始指针</span></span><br><span class="line">reset() <span class="comment">// 释放关联内存块的所有权，计数减一, 如果是最后一个指向该资源的shared_ptr, 就释放这块内存</span></span><br><span class="line">unique() <span class="comment">// 判断是否是唯一指向当前内存的shared_ptr</span></span><br><span class="line">use_count() <span class="comment">// 返回引用计数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// weak_ptr</span></span><br><span class="line">use_count() <span class="comment">// 返回管理该对象的 shared_ptr 对象数量</span></span><br><span class="line">expire()  <span class="comment">// 检查被引用的对象是否已删除 </span></span><br><span class="line">lock() <span class="comment">// 创建管理被引用的对象的shared_ptr </span></span><br><span class="line">reset() <span class="comment">// 将本身设置为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sh_ptr.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sh_ptr);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!wp.expired())&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr2 = wp.lock(); <span class="comment">//get another shared_ptr</span></span><br><span class="line">		*sh_ptr = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">        wp.reset();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sh_ptr2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//delete memory</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unique_ptr </span></span><br><span class="line">release() <span class="comment">// 返回一个指向被管理对象的指针，并释放所有权 </span></span><br><span class="line">reset()  <span class="comment">// 参数可以为 空、内置指针，先将原来对象释放，再重新设置新对象</span></span><br><span class="line">swap() <span class="comment">// 交换被管理对象 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::bar\n"</span>; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~B() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B</span><br><span class="line">&#123;</span><br><span class="line">    D() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::D\n"</span>;  &#125;</span><br><span class="line">    ~D() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::~D\n"</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> override </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::bar\n"</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// a function consuming a unique_ptr can take it by value or by rvalue reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;D&gt; pass_through(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;D&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;bar();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_file</span><span class="params">(<span class="built_in">std</span>::FILE* fp)</span> </span>&#123; <span class="built_in">std</span>::fclose(fp); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"unique ownership semantics demo\n"</span>;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">auto</span> p = <span class="built_in">std</span>::make_unique&lt;D&gt;(); <span class="comment">// p is a unique_ptr that owns a D</span></span><br><span class="line">      <span class="keyword">auto</span> q = pass_through(<span class="built_in">std</span>::move(p)); </span><br><span class="line">      assert(!p); <span class="comment">// now p owns nothing and holds a null pointer</span></span><br><span class="line">      q-&gt;bar();   <span class="comment">// and q owns the D object</span></span><br><span class="line">  &#125; <span class="comment">// ~D called here</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Runtime polymorphism demo\n"</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;B&gt; p = <span class="built_in">std</span>::make_unique&lt;D&gt;(); <span class="comment">// p is a unique_ptr that owns a D</span></span><br><span class="line">                                                  <span class="comment">// as a pointer to base</span></span><br><span class="line">    p-&gt;bar(); <span class="comment">// virtual dispatch</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;B&gt;&gt; v;  <span class="comment">// unique_ptr can be stored in a container</span></span><br><span class="line">    v.push_back(<span class="built_in">std</span>::make_unique&lt;D&gt;());</span><br><span class="line">    v.push_back(<span class="built_in">std</span>::move(p));</span><br><span class="line">    v.emplace_back(<span class="keyword">new</span> D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: v) p-&gt;bar(); <span class="comment">// virtual dispatch</span></span><br><span class="line">  &#125; <span class="comment">// ~D called 3 times</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Custom deleter demo\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::ofstream(<span class="string">"demo.txt"</span>) &lt;&lt; <span class="string">'x'</span>; <span class="comment">// prepare the file to read</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::FILE, <span class="keyword">decltype</span>(&amp;close_file)&gt; fp(<span class="built_in">std</span>::fopen(<span class="string">"demo.txt"</span>, <span class="string">"r"</span>),</span><br><span class="line">                                                           &amp;close_file);</span><br><span class="line">      <span class="keyword">if</span>(fp) <span class="comment">// fopen could have failed; in which case fp holds a null pointer</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)<span class="built_in">std</span>::fgetc(fp.get()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="comment">// fclose() called here, but only if FILE* is not a null pointer</span></span><br><span class="line">    <span class="comment">// (that is, if fopen succeeded)</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Custom lambda-expression deleter demo\n"</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;D, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(D*)&gt;&gt; p(<span class="keyword">new</span> D, [](D* ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying from a custom deleter...\n"</span>;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;);  <span class="comment">// p owns D</span></span><br><span class="line">    p-&gt;bar();</span><br><span class="line">  &#125; <span class="comment">// the lambda above is called and D is destroyed</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Array form of unique_ptr demo\n"</span>;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;D[]&gt; p&#123;<span class="keyword">new</span> D[<span class="number">3</span>]&#125;;</span><br><span class="line">  &#125; <span class="comment">// calls ~D 3 times</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><p><strong>static_cast</strong></p>
<ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<blockquote>
<p> 向上转换是一种隐式转换 </p>
</blockquote>
<p><strong>dynamic_cast</strong></p>
<ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<p><strong>const_cast</strong></p>
<ul>
<li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li>
</ul>
<p><strong>reinterpret_cast</strong></p>
<ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<p><strong>bad_cast</strong></p>
<ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<p>bad_cast 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught: "</span> &lt;&lt; b.what();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><p>typeid/typeinfo</p>
<h3 id="编译器默认生成的函数"><a href="#编译器默认生成的函数" class="headerlink" title="编译器默认生成的函数"></a>编译器默认生成的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">构造函数或拷贝构造函数生成条件：</span><br><span class="line"><span class="comment">// 1. 调用对象成员或基类的默认构造函数</span></span><br><span class="line"><span class="comment">// 2. 初始化虚表指针或许基类指针</span></span><br><span class="line"></span><br><span class="line">赋值函数生成条件：有默认构造函数</span><br><span class="line"></span><br><span class="line">析构函数，默认主动生成，但没实际汇编代码</span><br><span class="line">    </span><br><span class="line"><span class="comment">// A如果没有默认构造函数，对象只是声明，没有真正的实例初始化&lt;深度探索c++模型&gt;</span></span><br><span class="line">A obj;</span><br><span class="line">A* p = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="comment">// nm + c++filt 可以看生成了哪些默函数</span></span><br></pre></td></tr></table></figure>
<h2 id="Effictive-C"><a href="#Effictive-C" class="headerlink" title="Effictive C++"></a>Effictive C++</h2><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>array / vector / deque / forward_list / list / stack / queue / priority_queue / set / map</p>
<p>find / sort </p>
<blockquote>
<p>1周补充源码阅读, 11.11~11.17</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>顺序结构：stack / queue / list / 链队列，单链表，双向链表，循环链表 / </p>
<p>树：二叉/红黑/AVL/B/B+</p>
<h3 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1-顺序结构"></a>1-顺序结构</h3><h4 id="1-1-顺序栈-Sequence-Stack"><a href="#1-1-顺序栈-Sequence-Stack" class="headerlink" title="1.1-顺序栈(Sequence Stack)"></a>1.1-顺序栈(Sequence Stack)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-队列-Sqeuence-Queue"><a href="#1-2-队列-Sqeuence-Queue" class="headerlink" title="1.2-队列(Sqeuence Queue)"></a>1.2-队列(Sqeuence Queue)</h4><h4 id="1-3-顺序表-Sequence-List"><a href="#1-3-顺序表-Sequence-List" class="headerlink" title="1.3-顺序表(Sequence List)"></a>1.3-顺序表(Sequence List)</h4><h3 id="2-链式结构"><a href="#2-链式结构" class="headerlink" title="2-链式结构"></a>2-链式结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-链队列-Link-Queue"><a href="#2-1-链队列-Link-Queue" class="headerlink" title="2.1-链队列(Link Queue)"></a>2.1-链队列(Link Queue)</h4><h4 id="2-2-线性表的链式表示"><a href="#2-2-线性表的链式表示" class="headerlink" title="2.2-线性表的链式表示"></a>2.2-线性表的链式表示</h4><p>单链表(Link List)</p>
<p>双向链表(Du-Link-List)</p>
<p>循环链表(Cri-Link-List)</p>
<h3 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3-哈希表"></a>3-哈希表</h3><p>插入和查找的时间复杂度O(1)，也叫散列表<br><strong>哈希函数</strong>  查找某个元素时减少比较次数<br><strong>构造方法 </strong><br>    1）直接定址， 取关键字或某个线性函数值为散列地址， H(key) = key 或 H(key) = a*key + b<br>    2）除留余数， 求余， H(key) = key % p, p &lt; m<br>    3）数字分析，选出某几个关键字作为地址<br>    4）折叠， 将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址<br>    5）平方取中， 先计算出关键字值的平方，然后取平方值中间几位作为散列地址<br><strong>冲突处理方法</strong><br>    1）链地址法：key值相同的用单链表链接<br>    2）开放定址法：<br>            a）线性探测法，key值相同=&gt;放到key值的下一个位置 Hi = (H(key)+i)%m<br>            b）二次探测法：key值相同=&gt;  探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1^2]，<br>                T[d+2^2]，T[d+3^2],…，等，直到探查到 <strong>有空余地址</strong> 或者到 T[d-1]为止 , 无法探查到整个散列空间<br>            c）随机探测法：H = (H(key) + 伪随机数)%m</p>
<blockquote>
<p>网络环境下的分布式缓存系统一般基于一致性哈希（Consistent hashing）。简单的说，一致性哈希将哈希值取值空间组织成一个虚拟的环，各个服务器与数据关键字K使用相同的哈希函数映射到这个环上，数据会存储在它顺时针“游走”遇到的第一个服务器。可以使每个服务器节点的负载相对均衡，很大程度上避免资源的浪费。</p>
</blockquote>
<blockquote>
<p>在动态分布式缓存系统中，哈希算法的设计是关键点。使用分布更合理的算法可以使得多个服务节点间的负载相对均衡，可以很大程度上避免资源的浪费以及部分服务器过载。 使用带虚拟节点的一致性哈希算法，可以有效地降低服务硬件环境变化带来的数据迁移代价和风险，从而使分布式缓存系统更加高效稳定。</p>
</blockquote>
<p><strong>线性探测的哈希表数据结构和图片</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	KeyType key;</span><br><span class="line">&#125;RcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	RcdType *rcd;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">bool</span> *tag;</span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure>
<p> <img src="/2019/11/11/备战2020/HashTable.png" alt="img"> </p>
<h3 id="4-递归"><a href="#4-递归" class="headerlink" title="4-递归"></a>4-递归</h3><p>函数间接或直接的调用自身<br><strong>递归与分治</strong><br>分治法：问题的分解，问题规模的分解<br>递归：折半查找，归并查找，快速排序</p>
<p><strong>递归与迭代</strong><br>迭代：反复用旧变量推出新值<br>折半查找，归并查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找（分治）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin_search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; key)</span><br><span class="line">            high = mid <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并查找</span></span><br><span class="line">merge_sort</span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line">quick_sort</span><br></pre></td></tr></table></figure>
<h3 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5-二叉树"></a>5-二叉树</h3><p><strong>性质</strong><br>1）非空二叉树第 i 层最多 $$ 2^(i-1)  $$ 个结点(i&gt;=1)<br>2）深度为k的二叉树最多 $$ 2^(k) -1 $$ 个结点<br>3）包含n个元素的二叉树最大高度为n, 最小为log2^(n+1)<br>4）设完全二叉树中一元素序号为i, 1&lt;=i&lt;=n, 则有以下关系:<br>    1) 当i=1时, 该元素为二叉树的根; 若i&gt;1, 则该元素的父节点编号i/2<br>    2) 当2i&gt;n时, 该元素无左孩子; 否则其左孩子编号为2i<br>    3) 当2i+1&gt;n时, 该元素无右孩子; 否则该右孩子编号为2i+1</p>
<p><strong>存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p><strong>遍历方式</strong></p>
<p>先序遍历，中序遍历，后序遍历，层级遍历</p>
<p><strong>分类</strong><br>1）满二叉树<br>2）完全二叉树(堆)，大顶堆(根&gt;=左 &amp;&amp; 根&gt;= 右)，小顶堆(根&lt;=左 &amp;&amp; 根&lt;= 右)<br>3）二叉查找树(二叉排序树)，左&lt;根&lt;右<br>4）平衡二叉树(AVL树)，|左子树高 - 右子树高| &lt;= 1<br>5）最小失衡树：平衡二叉树插入新结点导致失衡，调整：<br>    a）LL型：根的左孩子右旋<br>    b）RR型：根的右孩子左旋<br>    c）LR型：根的左孩子左旋，再右旋<br>    d）RL型：右孩子的左子树，先右旋，再左旋</p>
<h3 id="6-其他树"><a href="#6-其他树" class="headerlink" title="6-其他树"></a>6-其他树</h3><p>图：</p>
<blockquote>
<p>１周补充, 11.18~11.24</p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>排序 / 查找 / 图搜索 / 其他(分治、动态规划、贪心) </p>
<blockquote>
<p>１周补充 , 11.24~12.1</p>
</blockquote>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>23种设计模式 / 设计原则</p>
<blockquote>
<p>1周补充，抽空</p>
</blockquote>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>对于有线程的系统：进程是资源分配的独立单位，线程是资源调度的独立单位。<br>对于没有线程的系统：进程是资源分配和调用的单位</p>
<h3 id="进程间通信及优缺点"><a href="#进程间通信及优缺点" class="headerlink" title="进程间通信及优缺点"></a>进程间通信及优缺点</h3><h4 id="1-管道-Pipe"><a href="#1-管道-Pipe" class="headerlink" title="1-管道(Pipe)"></a>1-管道(Pipe)</h4><p>1）有名管道：一种半双工通信方式，它允许无亲缘关系进程的通信<br>        优点：可以实现任意进程间通信<br>        缺点：长期存在于系统，使用不当容易出错；缓冲区有限</p>
<p>2）无名管道： 一种半双工的通信方式， 只能在有亲缘关系的进程间通信<br>        优点：简单方便<br>        缺点：局限于单向通信；只能创建在亲缘进程之间；缓冲区有限( 在管道创建时，为缓冲区分配一个页面大小 )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-信号量-Semaphore"><a href="#2-信号量-Semaphore" class="headerlink" title="2-信号量(Semaphore)"></a>2-信号量(Semaphore)</h4><p>一个计数器，可以用来多个线程对共享资源的访问<br>优点：可以同步进程<br>缺点：信号量有限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1-----文件名到键值------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok (<span class="keyword">char</span>*pathname, <span class="keyword">char</span> proj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统V信号灯API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-----创建一个信号量------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span> </span></span><br><span class="line"><span class="function"><span class="comment">/*nsems 信号量集中信号量的个数</span></span></span><br><span class="line"><span class="function"><span class="comment">semflg IPC_CREAT 存在则返回该信号量集标识符, 不存在则创建</span></span></span><br><span class="line"><span class="function"><span class="comment">	   IPC_CREAT|IPC_EXCL 不存在则创建, 否则返回错误*/</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 3-----信号量值操作, 成功返回0，否则返回-1-----</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span></span><br><span class="line"><span class="function"><span class="comment">//&#123;0,-1,SEM_UNDO&#125;; 	/*将信号量对象中序号为0的信号量减1，申请资源*/</span></span></span><br><span class="line"><span class="function"><span class="comment">//&#123;0,1,SEM_UNDO&#125;;  	/*将信号量对象中序号为0的信号量加1，释放资源*/</span></span></span><br><span class="line"><span class="function"><span class="comment">//&#123;0,0,0&#125;;           /*进程被阻塞，直到对应的信号量值为0*/</span></span></span><br><span class="line"><span class="function">struct sembuf </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>      sem_num;        <span class="comment">/* semaphore index in array */</span></span><br><span class="line">    <span class="keyword">short</span>           sem_op;     		<span class="comment">/* semaphore operation */</span></span><br><span class="line">    <span class="keyword">short</span>           sem_flg;        	<span class="comment">/* operation flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*sem_op 大于0表示释放sem_op个数的共享资源, 小于0表示申请-sem_op个数的资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sem_flg IPC_NOWAIT 释放资源不够时直接返回EAGAIN错误，不会睡眠</span></span><br><span class="line"><span class="comment">    	SEM_UNDO 进程崩溃时，内核自动恢复计数值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">nsops  一般是1，只完成对一个信号量的操作*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4-----创建，获取，删除, 设置值-----</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, <span class="keyword">union</span> semun arg)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">union</span> semun </span>&#123;</span><br><span class="line">   <span class="keyword">short</span> val;          <span class="comment">/*SETVAL用的值*/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span> <span class="comment">/*IPC_STAT、IPC_SET用的semid_ds结构*/</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span>* <span class="built_in">array</span>; <span class="comment">/*SETALL、GETALL用的数组值*/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *<span class="title">buf</span>;</span>   <span class="comment">/*为控制IPC_INFO提供的缓存*/</span></span><br><span class="line">&#125; arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*cmd IPC_RMID 删除, SETVAL 设置初始值*/</span></span><br></pre></td></tr></table></figure>
<h4 id="3-信号-Signal"><a href="#3-信号-Signal" class="headerlink" title="3-信号(Signal)"></a>3-信号(Signal)</h4><p>信号是在软件层次上对中断机制的模拟。信号来源：硬件来源（按键盘或其他硬件故障），软件来源(kill,raise).<br>信号的分类：可靠信号(支持排队，不会丢失)和不可靠信号(小于32)。实时信号(0～63，可靠)和非实时信号(不支持排队)<br>信号发送</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval val)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">union</span> sigval </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  sival_int;</span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">&#125;<span class="keyword">sigval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line">int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue)); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>信号的安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int)； </span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler)); </span><br><span class="line"></span><br><span class="line">int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</span><br></pre></td></tr></table></figure>
<h4 id="4-消息队列-Message-Queue"><a href="#4-消息队列-Message-Queue" class="headerlink" title="4-消息队列(Message Queue)"></a>4-消息队列(Message Queue)</h4><p>是消息的链表，存放在内核中并由消息队列标识符标识<br>优点：任意进程间通信，通过系统调用函数实现消息发送和接收同步，使用方便<br>缺点：信息的复制额外消耗CPU的时间，不适合信息量大或操作频繁的场合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="comment">// 文件名到键值</span></span><br><span class="line"><span class="keyword">key_t</span> ftok (<span class="keyword">char</span>*pathname, <span class="keyword">char</span> proj)</span><br><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 收</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 发</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function">struct msgbuf</span>&#123;</span><br><span class="line"><span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置或删除消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 注意 msgbuf 可以是自定义结构</span></span></span><br><span class="line"><span class="function">struct S_PUBLISH_DATA</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int32 topic;			<span class="comment">//! 发布标题</span></span><br><span class="line">	int32 biz_id;			<span class="comment">//! 业务流程ID</span></span><br><span class="line">	int32 flow_id;			<span class="comment">//! 流程ID</span></span><br><span class="line">	int32 pid;				<span class="comment">//! 进程ID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span>;</span>			<span class="comment">//! 发布时间</span></span><br><span class="line">	int32 content_len;		<span class="comment">//! 内容长度</span></span><br><span class="line">	<span class="keyword">char</span> content[<span class="number">0</span>];		<span class="comment">//! 发布内容(变长)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-共享内存-Shared-Memory"><a href="#5-共享内存-Shared-Memory" class="headerlink" title="5-共享内存(Shared Memory)"></a>5-共享内存(Shared Memory)</h4><p>映射到一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程可以访问。</p>
<p>进程间需要共享的数据被放在一个叫做IPC共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。 </p>
<p>优点：无需复制，快捷，信息量大<br>缺点：a)通信是通过将共享空间缓存区直接附加到进程的虚拟地址空间中来实现，因此进程间读写操作有同步问题<br>            b)利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的多个进程共享，不方便网络通信</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 文件名到键值</span></span><br><span class="line"><span class="keyword">key_t</span> ftok (<span class="keyword">char</span>*pathname, <span class="keyword">char</span> proj)</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">// 相当于attatch</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">// 相当于detach</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line"><span class="comment">// 控制操作，设置和删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="6-套接字-Socket"><a href="#6-套接字-Socket" class="headerlink" title="6-套接字(Socket)"></a>6-套接字(Socket)</h4><p>用于不同进程和主机间通信</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述套接口通用地址的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;  	<span class="comment">/* address family, AF_xxx   */</span></span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>];    <span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述因特网地址结构的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family;   	<span class="comment">/* 描述协议族 编程中只能是AF_INET*/</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;         	<span class="comment">/* 端口号 使用网络字节顺序*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>        <span class="comment">/* 因特网地址 */</span></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];      <span class="comment">/* 为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保										留的空字节 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;		<span class="comment">/*网络字节顺序存储IP地址*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> ptotocol)</span></span></span><br><span class="line">参数：domain 创建网际Ipv4域PF_INET, type SOCK_STREAM或SOCK_DGRAM，ptotocol一般填0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * my_addr, <span class="keyword">socklen_t</span> my_addr_len)</span></span></span><br><span class="line">参数：</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span>  sockfd, <span class="keyword">int</span>  backlog)</span></span></span><br><span class="line">参数： backlog 三次握手通过后，Accept queue 队列长度，最终取 min(128,backlog)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">( <span class="keyword">int</span> sockfd, struct sockaddr * cliaddr, <span class="keyword">socklen_t</span> * addrlen)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// example</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nSock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">-1</span> == nSock )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> iOpt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(setsockopt(nSock,SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;iOpt, <span class="keyword">sizeof</span>(iOpt) ) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// setsockopt( m_nSock, IPPROTO_TCP, TCP_NODELAY, (const char*)&amp;iOpt, sizeof(iOpt) ) </span></span><br><span class="line">    <span class="comment">// setsockopt(nSock, SOL_SOCKET, SO_KEEPALIVE, (const char*)&amp;iOpt, sizeof(iOpt) )</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">sin</span>;</span></span><br><span class="line">	<span class="built_in">sin</span>.sin_family		= AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, " 192.168.0.11", &amp;serv_addr.sin_sddr) ;</span></span><br><span class="line">	<span class="built_in">sin</span>.sin_port		= htons(nPort);</span><br><span class="line">    <span class="keyword">if</span>( bind( nSock, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    ::listen( nSock, <span class="number">256</span>);</span><br><span class="line">    </span><br><span class="line">    nClientSock = ::accept( m_nSock, </span><br><span class="line">				(struct sockaddr*)&amp;clientAddr, </span><br><span class="line">				&amp;nClientLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。<br>锁机制：<br>    1）互斥锁，以排他方式防止数据结构被并发修改的方法<br>    2）读写锁，允许多个线程同时读共享数据，而对写操作是互斥的<br>    3）自旋锁， 互斥锁是当资源被占用，申请者进入睡眠状态 ；循环检测锁释放已经释放<br>    4）条件变量，阻塞进程，直到某个特定条件为真</p>
<p>信号量机制或信号机制</p>
<table>
<thead>
<tr>
<th></th>
<th>私有</th>
<th>共享</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程</td>
<td>线程栈，寄存器，程序计数器</td>
<td>堆，地址空间，全局变量，静态变量</td>
</tr>
<tr>
<td>进程</td>
<td>堆，栈，寄存器，全局变量，地址空间</td>
<td>代码段，公共数据，进程目录，进程ID</td>
</tr>
</tbody>
</table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>避免死锁的方法：有序分配</p>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p> 大端字节序：高位字节在前, 低位字节在后, 是人类读取字节的方法 (网络字节序)<br> 小端字节序：低位字节在前, 高位字节在后 </p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>全局置换：在整个内存空间置换</li>
<li>局部置换：在本进程中进行置换</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>全局：</p>
<ul>
<li>工作集算法</li>
<li>缺页率置换算法</li>
</ul>
<p>局部：</p>
<ul>
<li>最佳置换算法（OPT）</li>
<li>先进先出置换算法（FIFO）</li>
<li>最近最久未使用（LRU）算法</li>
<li>时钟（Clock）置换算法</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h3><table>
<thead>
<tr>
<th style="text-align:left">OSI七层</th>
<th style="text-align:left">功能</th>
<th style="text-align:left">协议</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">应用层</td>
<td style="text-align:left">负责为程序提供统一的接口</td>
<td style="text-align:left">ftp telnet http dns</td>
</tr>
<tr>
<td style="text-align:left">表示层</td>
<td style="text-align:left">负责把数据转换成兼容接收系统的格式</td>
<td style="text-align:left">NULL(JPEG、MPEG、ASII)</td>
</tr>
<tr>
<td style="text-align:left">会话层</td>
<td style="text-align:left">负责维护计算机之间的通信连接</td>
<td style="text-align:left">NULL(NFS、SQL、NETBIOS、RPC)</td>
</tr>
<tr>
<td style="text-align:left">传输层</td>
<td style="text-align:left">负责为数据加上传输表头(包含port), 形成数据包</td>
<td style="text-align:left">TCP UDP</td>
</tr>
<tr>
<td style="text-align:left">网路层</td>
<td style="text-align:left">负责数据的路由和转发</td>
<td style="text-align:left">IP ICMP IGMP（路由器） RIP</td>
</tr>
<tr>
<td style="text-align:left">数据链路层</td>
<td style="text-align:left">负责MAC寻址, 错误侦测和改错</td>
<td style="text-align:left">ARP RARP MTU PPP（网桥，交换机）</td>
</tr>
<tr>
<td style="text-align:left">物理层</td>
<td style="text-align:left">负责在物理网络中传输数据帧</td>
<td style="text-align:left">RJ45、CLOCK、IEEE802.3(中继器，集线器)</td>
</tr>
</tbody>
</table>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>DNS ，FTP ，TELNET<br>URL统一资源定位符 格式：<code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code><br>HTTP 请求方法和状态码</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><strong>传输层</strong></h4><p>TCP（Transmission Control Protocol，传输控制协议），UDP（User Datagram Protocol，用户数据报协议）</p>
<h5 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h5><p>ack确认，超时重传，流量控制，拥塞控制，<br>数据校验：TCP首部和IP首部都有校验和，范围不同。<br>数据合理分片和排序：IP分片 在以太网上，由于电气限制，一帧不能超过1518字节，除去以太网帧头14字节（mac地址等）和帧尾4字节校验，还剩1500字节，这个大小称为MTU（最大传输单元）。另外在TCP层有MSS协商，数据会分段，一般约定1460，这样就不会超过MTU。因此TCP传输不会造成IP层分片，在TCP层就分段好了，IP分片一般是给UDP和ICMP使用。</p>
<h5 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h5><p><strong>最大24个字节，一般没有选项20个字节</strong></p>
<p><img src="/2019/11/11/备战2020/4.png" alt="4"></p>
<h5 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h5><p><img src="/2019/11/11/备战2020/5.png" alt="5"></p>
<h5 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h5><p>1）TCP是面向连接的，UDP是无连接的<br>2）TCP的逻辑通信是全双工的可靠信道，UDP是不可靠信道<br>3）TCP只能是点对点，UDP可以一对多，一对一，多对一的交互通信<br>4）TCP面向字节流， 实际上是 TCP 把数据看成一连串无结构的字节流 ；UDP面向报文（不会拈包）<br>5）UDP没有拥塞控制， 因此网络出现拥塞不会使源主机的发送速率降低<br>6）TCP首部开销20个字节，UDP首部开销8个字节</p>
<h5 id="TCP粘包问题"><a href="#TCP粘包问题" class="headerlink" title="TCP粘包问题"></a>TCP粘包问题</h5><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的 。<br><strong>产生原因</strong>：1） 发送方 TCP默认会使用Nagle算法: 只有上一个分组得到确认，才会发送下一个分组; 收集多个小分组，在一个确认到来时一起发送 。2） 接受方 没有立即处理, TCP将收到的分组保存至接收缓存里, 缓冲区会存在多个包 。<br><strong>解决办法</strong>：1） 发送发关闭Nagle算法, TCP_NODELAY选项 。2） 接受方 TCP协议没有处理机制, 通过应用层来处理。3） 应用层 定义消息包头(len+type)和包体(data), 收包时循环处理。</p>
<h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h5><p> 让发送方的发送速率不要太快，要让接收方来得及接收 ，利用可变窗口进行流量控制。</p>
<h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><p> 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载 。</p>
<p>方法：慢开始，拥塞避免，快重传，快恢复。</p>
<h5 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h5><p><img src="/2019/11/11/备战2020/握手分手.jpg" alt="握手分手"></p>
<p>为什么需要三次握手？ </p>
<blockquote>
<p>全双工, 告诉对方 发送/接受数据 能力OK </p>
</blockquote>
<p>为什么需要四次分手？ </p>
<blockquote>
<p>为了确保数据能够完成传输(确保对端收完数据)</p>
</blockquote>
<p>为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？ </p>
<blockquote>
<p>因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p>
</blockquote>
<h5 id="TCP的四种定时器"><a href="#TCP的四种定时器" class="headerlink" title="TCP的四种定时器"></a>TCP的四种定时器</h5><p>a）重传定时器，<br>b）坚持定时器，窗口探查， 解决零窗口大小通知可能导致的死锁问题<br>c）保活定时器，keep-alive<br>d）2MSL定时器，time_wait保持2MSL：<br>    1）是为了保证客户端发送的最后一个 ACK 报文能够到达服务端。 若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时<br>    2） 防止已失效的连接请求报文段出现在本连接中 。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段 </p>
<h5 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h5><p><img src="/2019/11/11/备战2020/TCP的有限状态机.png" alt="TCP的有限状态机"></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h4><p>IP ，<br>ARP 工作原理<br>ICMP，网际控制报文协议，用于PING<br>IGMP，网际组管理协议 ，用于多播<br>IP 地址分类：</p>
<ul>
<li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li>
</ul>
<table>
<thead>
<tr>
<th>IP 地址类别</th>
<th>网络号</th>
<th>网络范围</th>
<th>主机号</th>
<th>IP 地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>A 类</td>
<td>8bit，第一位固定为 0</td>
<td>0 —— 127</td>
<td>24bit</td>
<td>1.0.0.0 —— 127.255.255.255</td>
</tr>
<tr>
<td>B 类</td>
<td>16bit，前两位固定为 10</td>
<td>128.0 —— 191.255</td>
<td>16bit</td>
<td>128.0.0.0 —— 191.255.255.255</td>
</tr>
<tr>
<td>C 类</td>
<td>24bit，前三位固定为 110</td>
<td>192.0.0 —— 223.255.255</td>
<td>8bit</td>
<td>192.0.0.0 —— 223.255.255.255</td>
</tr>
<tr>
<td>D 类</td>
<td>前四位固定为 1110，后面为多播地址</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E 类</td>
<td>前五位固定为 11110，后面保留为今后所用</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="IP头部格式"><a href="#IP头部格式" class="headerlink" title="IP头部格式"></a>IP头部格式</h5><p>最大24个字节，一般没有选项20个字节</p>
<p><img src="/2019/11/11/备战2020/6.png" alt="6"></p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><strong>数据链路层</strong></h4><p>主要信道：点对点信道，广播信道。数据单元：帧。<br>1）点对点信道：<br>        三个基本问题： 封装成帧 , 透明传输 ,  差错检测<br>        点对点协议( Point-to-Point Protocol )： 用户计算机和 ISP 通信时所使用的协议 </p>
<p>2）广播信道：<br>        单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同<br>        广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧<br>        多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><strong>物理层</strong></h4><p>传输单位是比特<br>通道：<br>    a）单向通道(单工通道)：只有一个方向通信，没有反向交互，如广播<br>    b）双向交替通信(半双工通信)：双发可以发消息，但不能同时发送或接收<br>    c）双向同时通信(全双工通信)：通信双发可以同时发送和接收<br>通道复用技术：<br>    a） 频分复用： 不同用户在不同频带，所用用户在同样时间占用不同带宽资源<br>    b） 时分复用 ： 不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度<br>    c） 波分复用 ： 光的频分复用<br>    d） 码分复用 ： 不同用户使用不同的码，可以在同样时间使用同样频带通信 </p>
<h3 id="TCP-IP四层"><a href="#TCP-IP四层" class="headerlink" title="TCP/IP四层"></a>TCP/IP四层</h3><table>
<thead>
<tr>
<th style="text-align:left">TCP/IP四层</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">应用层</td>
<td style="text-align:left">负责向用户提供一组应用程序, 比如HTTP/DNS/FTP</td>
</tr>
<tr>
<td style="text-align:left">传输层</td>
<td style="text-align:left">负责端到端的通信, 比如TCP/UDP</td>
</tr>
<tr>
<td style="text-align:left">网络层</td>
<td style="text-align:left">负责网络包的封装、寻址和路哟, 比如IP/ICMP</td>
</tr>
<tr>
<td style="text-align:left">网络接口层</td>
<td style="text-align:left">负责在物理网络中传输数据帧, 比如MAC寻址, 错误侦测和改错</td>
</tr>
</tbody>
</table>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><h4 id="read-write"><a href="#read-write" class="headerlink" title="read/write"></a>read/write</h4><p>socket </p>
<h4 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h4><p><a href="https://tiedan.website/2018/11/01/网络编程实践/" target="_blank" rel="noopener">参考</a> </p>
<h4 id="TCP队列"><a href="#TCP队列" class="headerlink" title="TCP队列"></a>TCP队列</h4><p><a href=""></a></p>
<h4 id="发送大文件缓冲区满"><a href="#发送大文件缓冲区满" class="headerlink" title="发送大文件缓冲区满"></a>发送大文件缓冲区满</h4><h4 id="TCP-keep-alive"><a href="#TCP-keep-alive" class="headerlink" title="TCP keep-alive"></a>TCP keep-alive</h4><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h4><p>层次模型，<br>网状模型，<br>关系模型，<br>    a）关系，一个关系对应通常说的一张表<br>    b）元组，表中的一行即为一个元组<br>    c）属性，表中的一列即为一个属性<br>    d）码，表中可以唯一确定一个元组的的某个属性组<br>    e）域，一组具有相同数据类型的值的集合<br>    f）分量，元组中的一个属性值<br>    g）关系模型，对关系的描述，一般表示为 关系名(属性1，属性2 ……)<br>面向对象数据模型，<br>对象关系数据模型，<br>半结构化数据模型，非关系模型的、有基本固定结构模式的数据，例如日志文件、XML文档、JSON文档、Email等</p>
<h4 id="数据库常用操作"><a href="#数据库常用操作" class="headerlink" title="数据库常用操作"></a>数据库常用操作</h4><p>查询（选择，投影，链接【等值，自然，左外连接，右外连接】）、除、并、差、交、<br>笛卡尔积)、插入、删除、修改<br>关系模型中的三类完整性约束：实体完整性，参照完整性，用户定义完整性</p>
<h4 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h4><p>数据库的完整性是指数据的正确性和相容性？<br>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p><a href="https://tiedan.website/2018/11/13/数据库设计三范式/" target="_blank" rel="noopener">参考</a> </p>
<p>1NF：属性(字段)是最小单位不可分割<br>2NF：满足1NF，每个非主属性完全依赖于主键(消除1NF非主属性对码的函数依赖)<br>3NF：满足2NF，任何非主属性不依赖于其他非主属性(消除2NF主属性对码的传递函数依赖)<br>BCNF（ 鲍依斯-科得范式 ）：满足3NF，任何非主属性不能对主键子集依赖( 消除 3NF 主属性对码的部分和传递函数依赖 )<br>4NF：满足3NF， 属性之间不能有非平凡且非函数依赖的多值依赖 </p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p><a href="https://tiedan.website/2018/10/23/数据库事务及锁/" target="_blank" rel="noopener">参考</a> </p>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="分析与设计数据库模型过程"><a href="#分析与设计数据库模型过程" class="headerlink" title="分析与设计数据库模型过程"></a>分析与设计数据库模型过程</h4><h4 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h4><p><a href="https://tiedan.website/2019/06/04/mysql深入浅出-笔记/" target="_blank" rel="noopener">参考</a> </p>
<h2 id="库与链接"><a href="#库与链接" class="headerlink" title="库与链接"></a>库与链接</h2><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p><a href="https://tiedan.website/2019/11/07/gdb-command/" target="_blank" rel="noopener">command</a></p>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>概念 / 实践 / CAP/BASE/RPC/分布式锁</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>linux命令</p>
<p><a href="https://tiedan.website/2019/03/05/linux性能优化之网络-笔记/" target="_blank" rel="noopener">网络</a> </p>
<p><a href="https://tiedan.website/2019/02/27/linux性能优化之内存-笔记/" target="_blank" rel="noopener">内存</a> </p>
<p><a href="https://tiedan.website/2019/02/28/linux性能优化之磁盘文件-笔记/" target="_blank" rel="noopener">磁盘</a> </p>
<p><a href="https://tiedan.website/2019/02/20/linux性能优化-笔记/" target="_blank" rel="noopener">性能</a> </p>
<h2 id="3rd"><a href="#3rd" class="headerlink" title="3rd"></a>3rd</h2><p>tcmalloc / libevent / boost </p>
<blockquote>
<p>2周补充</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p> 系统设计</p>
</blockquote>
<p><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a></p>
<blockquote>
<p>他人经验</p>
</blockquote>
<p><a href="https://github.com/aylei/interview" target="_blank" rel="noopener">https://github.com/aylei/interview</a></p>
<h2 id="网上搜集"><a href="#网上搜集" class="headerlink" title="网上搜集"></a>网上搜集</h2><p>字节跳动：</p>
<p><a href="https://leetcode-cn.com/circle/discuss/mSAtnq/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/discuss/mSAtnq/</a></p>
<p><a href="https://blog.csdn.net/weixin_37645543/article/details/103878665" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37645543/article/details/103878665</a></p>
<p><a href="https://www.jb51.net/it/718242.html" target="_blank" rel="noopener">https://www.jb51.net/it/718242.html</a></p>
<p><a href="https://blog.csdn.net/qq_37763130/article/details/94357770" target="_blank" rel="noopener">https://blog.csdn.net/qq_37763130/article/details/94357770</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1415120" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1415120</a></p>
<p><a href="https://www.nowcoder.com/discuss/208173?type=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/208173?type=2</a></p>
<p><a href="https://www.nowcoder.com/discuss/382896" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/382896</a></p>
<p><a href="https://blog.csdn.net/weixin_44289697/article/details/105832455" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44289697/article/details/105832455</a></p>
<p><a href="https://www.nowcoder.com/discuss/397726" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/397726</a></p>
<p><a href="https://www.nowcoder.com/discuss/559563?type=post&amp;order=time&amp;pos=&amp;page=0&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/559563?type=post&amp;order=time&amp;pos=&amp;page=0&amp;channel=-1&amp;source_id=search_post_nctrack</a></p>
<p><a href="https://www.cnblogs.com/gdjk/p/10469028.html" target="_blank" rel="noopener">https://www.cnblogs.com/gdjk/p/10469028.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/yhULcP0kas4WfhCxJ6JN9A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yhULcP0kas4WfhCxJ6JN9A</a></p>
<p><a href="https://mp.weixin.qq.com/s/PE8YEY-z7q1lPTKikreUOw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PE8YEY-z7q1lPTKikreUOw</a></p>
<p>包邮送10本《labuladong的算法小抄》</p>
<p><a href="https://www.nowcoder.com/discuss/592048?type=0&amp;order=3&amp;pos=45&amp;page=0&amp;channel=-1&amp;source_id=discuss_center_0_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/592048?type=0&amp;order=3&amp;pos=45&amp;page=0&amp;channel=-1&amp;source_id=discuss_center_0_nctrack</a></p>
<p>东半球最酷算法</p>
<p><a href="https://github.com/geekxh/hello-algorithm" target="_blank" rel="noopener">https://github.com/geekxh/hello-algorithm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/07/gdb-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/07/gdb-command/" itemprop="url">gdb  command</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-07T11:28:24+08:00">
                2019-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gdb/" itemprop="url" rel="index">
                    <span itemprop="name">gdb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/11/07/gdb-command/" class="leancloud_visitors" data-flag-title="gdb  command">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://github.com/hellogcc/100-gdb-tips" target="_blank" rel="noopener">参考地址</a></p>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>用户目录下 .gdbinit 文件, 启动gdb时默认加载</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/11/07/gdb-command/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/费曼技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/08/费曼技巧/" itemprop="url">费曼技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-08T09:59:21+08:00">
                2019-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/10/08/费曼技巧/" class="leancloud_visitors" data-flag-title="费曼技巧">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一种学习方法, 更快地学习, 更好地理解</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><blockquote>
<ol>
<li>向不熟悉某议题的人解释该议题，用他们能理解的方式及最简单的语言向他们解释</li>
<li>发现自己不能理解的地方或不能简单解释某议题的地方并记录</li>
<li>回头查看资讯来源并研读自己薄弱的地方直到能用简单的语言来解释</li>
<li>为了讲解通俗易懂, 简化表达语言(直接表达)</li>
</ol>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/CDN技术详解-笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/16/CDN技术详解-笔记/" itemprop="url">CDN技术详解 笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-16T14:56:03+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/09/16/CDN技术详解-笔记/" class="leancloud_visitors" data-flag-title="CDN技术详解 笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>CDN基本概念, Content Distribute Network, 内容分发网络。<br>产生背景, 为解决网络拥塞问题：第一公里/最后一公里/对等互联网关/长途骨干传输<br>CDN的基本工作过程<br><img src="/2019/09/16/CDN技术详解-笔记/1.png" alt=""><br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/09/16/CDN技术详解-笔记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/06/lua应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/06/lua应用/" itemprop="url">lua应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T09:28:52+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/3rd/" itemprop="url" rel="index">
                    <span itemprop="name">3rd</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/09/06/lua应用/" class="leancloud_visitors" data-flag-title="lua应用">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>全文基于lua5.1</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>Lua和C语言数据交换, 有两个问题, 动态和静态类型之间区别, 自动和手动内存管理的区别<br>Lua设计了一个抽象的栈, 用于与其他语言数据交换, 栈中元素可以保存任何Lua类型的值</p>
<p><img src="/2019/09/06/lua应用/image-20200526173904275.png" alt="image-20200526173904275"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/09/06/lua应用/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/git操作命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="扫地小道童">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扫地小道童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/git操作命令/" itemprop="url">git操作命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T09:44:48+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/14/git操作命令/" class="leancloud_visitors" data-flag-title="git操作命令">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="/2019/08/14/git操作命令/1-1596006424936.png" alt="1"></p>
<ul>
<li>Workspace：工作区，能看到的目录</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<p><strong>HEAD</strong>: 指向该分支上的最后一次提交，待补充</p>
<p><strong>master</strong>: 只是这个repository中默认创建的第一个branch</p>
<p><strong>origin</strong>: 远程仓库在本地的标签或者别名，git clone url 默认创建的指向这个远程代码库的标签</p>
<h1 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h1><!--�147-->
<!--�148-->
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/08/14/git操作命令/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">扫地小道童</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">133</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">扫地小道童</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("qtaCLPFG2dC4WHDCx7CXHF86-gzGzoHsz", "o0aO4phM2twpBXHNnXD4keF5");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
