<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[备战]]></title>
    <url>%2F2020%2F03%2F04%2F%E5%A4%87%E6%88%98%2F</url>
    <content type="text"><![CDATA[C++语言 static 作用 this指针定义和作用 内联函数的优缺点 虚函数可以内联吗 volatile作用 assert作用 sizeof数组和指针区别 内存对齐 位域 extern作用 struct和class区别 union explicit关键字 友元函数和友元类 using用法 enum枚举类型 类型萃取decltype 左值引用和右值引用 成员初始化列表好处 initializer_list 列表初始化 面向对象，封装/继承/多态 (构造函数/static函数/普通函数 不能是虚函数) 为什么需要虚析构函数 什么是纯虚函数 虚函数指针和虚函数表定义 虚继承是什么，解决了什么问题 虚继承和虚函数差异 虚函数在模板类中可以使用吗 内存分配管理有哪些函数 delete this合法吗 如何定义一个只能在堆或栈上生成对象的类 智能指针优缺点 强制类型转换符 编译器默认生成的函数(C++98/C++11) 设计模式UML关系图 创建模式 结构模式 行为模式 操作系统 进程和线程区别 进程间通信及有缺点 线程间同步方式有哪些 大小字节序区分 网络 OSI七层是哪七层，分别什么功能和协议 TCP首部和UDP首部结构 TCP是如何保证可靠传输的 TCP三次握手和四次挥手过程 为什么需要三次和四次 为什么TCP链接时可以ACK和SYNC一起发，而释放时ACK和FIN则要分开发送 TCP拈包问题 TCP四种定时器 TCP状态机 IP头部格式 ARP工作原理 IP地址分类 网络模型有哪些 read/write 函数返回值 及封装 select/poll/epoll 区别 TCP队列问题 发送大文件缓冲区满问题 数据库 有哪些范式 事务的特性ACID 索引原理 分库分表 mysql存储引擎，索引，锁，优化 库与链接gdb分布式系统 CAP理论 BASE 2PC 3PC RPC 一致性算法Paxos 一致性算法Raft 一致性hash算法 问题 性能优化3rd]]></content>
  </entry>
  <entry>
    <title><![CDATA[centos 常见问题]]></title>
    <url>%2F2020%2F02%2F26%2Fcentos-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装软件1234567891011121314151617181920# 安装ifconfig, 搜错找到安装包, : 前面的就是yum search ifconfigyum install -y net-tools.x86_64# vim 安装yum install -y vim# git 安装yum install -y git# gcc/g++ 安装yum install -y gcc-c++.x86_64# 手动安装增强包mkdir -p /media/cdrommount -t auto /dev/cdrom /media/cdromcd /media/cdrom# 依赖 gcc/kernel-devel/bzip2/xorg-x11-server-Xorg# 更新下 yum updatesh ./VBoxLinuxAdditions.run DNS被自动修改1234567891011121314151617[root@localhost ~]# cat /etc/resolv.conf; generated by /usr/sbin/dhclient-scriptnameserver 10.1.1.8nameserver 10.1.1.7nameserver 10.1.1.8nameserver 10.1.1.7nameserver 223.5.5.5nameserver 223.6.6.6search localhost// 1. 强制修改 resolv.conf 的文件flag，设定为不可被更改.// +&lt;属性&gt;：开启文件或目录的该项属性；// -&lt;属性&gt;：关闭文件或目录的该项属性；chattr +i /etc/resolv.conf// 2. 修改 /sbin/dhclient-script 把 make_resolv_conf 这个函数的调用都给注释掉 ftp1234567891011121314151617181920212223242526272829// 安装yum install -y vsftpd// 配置vi /etc/vsftpd/vsftpd.conf# 不允许匿名访问anonymous_enable=NO # 允许本地账户登录local_enable=YES# 在文件中的用户能离开主目录chroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_list# 500 OOPS: vsftpd: refusing to run with writable root inside chroot()allow_writeable_chroot=YES# 支持ASCII模式的上传和下载功能ascii_upload_enable=YESascii_download_enable=YES // 重启systemctl restart vsftpd.service// 新建ftp用户 ftpuseruseradd -d /var/ftp/public_root -g ftp -s /sbin/nologin ftpuser// 修改密码passwd ftpuser]]></content>
  </entry>
  <entry>
    <title><![CDATA[cosmic 培训]]></title>
    <url>%2F2020%2F02%2F17%2Fcosmic-%E5%9F%B9%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[易混淆概念：cosmic不等于传统的功能点cosmic条数不等于项目工作人天cosmic包含了整个软件工程的工作量 度量范围：功能相需求(包含环境) 度量策略阶段：用来预算和结算 层：一个软件体系结构的功能划分 分层视角：应用成应用程序的三层架构的部件业务规则的SOA构件层次 拆分文档是从需求文档来的，需求文档中描述的功能和架构图，否则最终会被砍掉 功能用户， 如何识别？ 功能过程：(越多越好) 子过程描述：描述对应功能过程的 数据移动类型：R 读规则和数据 W 临时数据，E 输入， X 输出 (解析和组装数据不算有效移动）输入输出只有一条，获取其他数据就是读，比如读取规则 数据组：集合，先查A数据，再查B数据，可以多谢几条 非功能性系数：性能等]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql深入浅出2 笔记]]></title>
    <url>%2F2020%2F01%2F19%2Fmysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA2-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[普通索引和唯一索引, 怎么选择查询select id from T where k=5普通索引找到(5,100)后, 继续找直到遇到第一个不满足k=5; 唯一索引找到了就返回. 性能差异可忽略因为InnoDB按照数据页为单位读写, 默认一个页大小16KB, 一般只要多一次计算就可。 更新change buffer 如果数据不在内存中, 更新操作缓存, 等下次查询时再更新(merge), 适用于读少写多; 在内存中有拷贝, 会被写到磁盘上;目的是为了减少磁盘读写次数, 通过innodb_change_buffer_max_size动态设置, 50表示最大占buffer pool 50% 只适用于普通索引, 因为唯一索引数据会读入内存要判断唯一性, 不会存在change buffer. 为什么会选错索引123set long_query_time=0;select * from t where a between 10000 and 20000; /*Q1*/select * from t force index(a) where a between 10000 and 20000;/*Q2*/ 不断删除历史数据, 导致全表扫描, 优化器选错了索引 12345explain select * from tshow index from tanalyze table t 查看预计扫描行数, 查看索引基数, 重新统计索引信息 怎么给字符串加索引12345678910mysql&gt; select count(distinct left(email,4)）as L4, count(distinct left(email,5)）as L5, count(distinct left(email,6)）as L6, count(distinct left(email,7)）as L7,from SUser;mysql&gt; alter table SUser add index index1(email);或指定前缀长度mysql&gt; alter table SUser add index index2(email(6)); 没索引匹配时全表扫描, 统计后选择合适的前缀索引, 使用后就不会再有索引覆盖 1 直接创建索引, 会比较占空间2 创建索引前缀, 节省空间, 但会增加扫描次数(区分度不高), 并且不能使用覆盖索引;3 倒序存储, 再创建前缀索引(省份证后6位), 饶过字符串本身区分度不够问题4 hash索引, 使用crc32()函数定义校验码, 查询性能稳定, 有额外的存储和计算消耗, 和3一样不支持范围扫描 为什么mysql会抖一下影响性能场景redo log 写满了, 刷脏页, 这个时候更新是被阻塞的内存不够用, 要先将脏也写入磁盘, 淘汰脏页 InnoDB刷脏页控制策略需要测试磁盘读写能力, 再设置innodb_io_capacity参数 1fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 刷脏页策略, 关注脏页比例, 尽量不要接口75% 123mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &apos;Innodb_buffer_pool_pages_dirty&apos;;select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &apos;Innodb_buffer_pool_pages_total&apos;;select @a/@b; innodb_flush_neighbors 参数控制是否只刷当前脏页, 0表示不带上邻居; SSD一般设置成0 为什么表数据删掉一半, 表文件大小没有变数据表空间回收, 设计表定义和数据innodb_file_per_table, on 表示InnoDB表数据存储在一个.idb为后缀的文件中, off 放在系统表共享空间 数据删除delete 只是把数据页标记可复用, 磁盘文件大小不会变;增删操作量大的表, 会存在空洞, 重建表可以收缩表空间 重建表alter table A engine=InnoDB Online DDL新建临时表=&gt; 扫描表A数据=&gt; 生成B+树,存储到临时文件=&gt; 记录更新操作row log=&gt; 更新数据, 替换表A的数据文件 optimize table t 等于 recreate+analyze count(*) 为什么这么慢MyISAM 是直接返回, InnoDB 会遍历全表 用缓存来保存计数, 或者在mysql里先更新再插入 效率count(*) ~= count(1) &gt; count(主键ID) &gt; count(字段) order by 是怎么工作的]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[awk]]></title>
    <url>%2F2020%2F01%2F09%2Fawk%2F</url>
    <content type="text"><![CDATA[调用方法123456// -F 每次读取一行，未设置-F默认用空格为域分隔符awk [-F field-separator] 'commands' input-file(s)awk -f awk-script-file input-file(s)awk-script-file 直接执行 AWK模式和操作1awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' file 第一步：执行BEGIN{commands}语句块中的语句，可选的语句块，比如变量初始化、打印输出表格的表头等语句。 第二步：循环从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块; 通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 第三步：从输入流中读取完所有的行之后即被执行 END{ commands }。 脚本通常是被单引号或双引号中 。 123// 统计文件行数awk 'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;' fileawk "BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;" file awk内置变量 说明：[A][N][P][G]表示第一个支持变量的工具，[A]=awk、[N]=nawk、[P]=POSIXawk、[G]=gawk 12345678910111213141516171819202122$n 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 $0 这个变量包含执行过程中当前行的文本内容。[N] ARGC 命令行参数的数目。[G] ARGIND 命令行中当前文件的位置（从0开始算）。[N] ARGV 包含命令行参数的数组。[G] CONVFMT 数字转换格式（默认值为%.6g）。[P] ENVIRON 环境变量关联数组。[N] ERRNO 最后一个系统错误的描述。[G] FIELDWIDTHS 字段宽度列表（用空格键分隔）。[A] FILENAME 当前输入文件的名。[P] FNR 同NR，但相对于当前文件。[A] FS 字段分隔符（默认是任何空格）。[G] IGNORECASE 如果为真，则进行忽略大小写的匹配。[A] NF 表示字段数，在执行过程中对应于当前的字段数。[A] NR 表示记录数，在执行过程中对应于当前的行号。[A] OFMT 数字的输出格式（默认值是%.6g）。[A] OFS 输出字段分隔符（默认值是一个空格）。[A] ORS 输出记录分隔符（默认值是一个换行符）。[A] RS 记录分隔符（默认是一个换行符）。[N] RSTART 由match函数所匹配的字符串的第一个位置。[N] RLENGTH 由match函数所匹配的字符串的长度。[N] SUBSEP 数组下标分隔符（默认值是34）。 12345// 统计文件行号awk 'END&#123; print NR &#125;' file // 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它awk 'BEGIN&#123; "date" | getline out; print out &#125;' 流程控制语句 每条命令语句后面可以用;分号结尾。 1234567891011121314151617181920212223if(表达式) &#123;语句1&#125;else if(表达式) &#123;语句2&#125;else &#123;语句3&#125;while(表达式) &#123;语句&#125; for(变量 in 数组) &#123;语句&#125; for(变量;条件;表达式) &#123;语句&#125;do&#123;语句&#125; while(条件)break 当 break 语句用于 while 或 for 语句时，导致退出程序循环。continue 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。next 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。exit 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。 123456789awk 'BEGIN&#123;test=100;total=0;while(i&lt;=test)&#123; total+=i; i++;&#125;print total;&#125;' 内置函数一般函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux多线程服务端编程]]></title>
    <url>%2F2020%2F01%2F06%2Flinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程安全的对象生命管理周期weak_ptr 与 shared_ptr 搭档RAII 资源获取即初始化写个对象池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104template &lt;class T, class L&gt;class TObjectPool&#123;private: int m_capacity = 1024; // 容量，默认1024 int m_offset; // 偏移量，栈顶为0 T* m_objects; // 对象存储空间 L m_lock; // 锁对象，压栈出栈时加锁 public: TObjectPool() &#123; m_offset = 0; m_objects = new T[m_capacity]; &#125; TObjectPool(int capacity) &#123; m_capacity = capacity; m_offset = 0; m_objects = new T[m_capacity]; &#125; ~TObjectPool() &#123; while(m_offset &gt; 0) m_objects[--m_offset].~T(); delete[] m_objects; m_capacity = 0; &#125; /*int Length() &#123; ScopeLock lock(m_lock); return m_offset; &#125; int Capacity() &#123; ScopeLock lock(m_lock); return m_capacity; &#125; bool Empty() &#123; ScopeLock lock(m_lock); return m_capacity == 0; &#125; bool Full() &#123; ScopeLock lock(m_lock); return m_capacity == m_offset; &#125;*/ bool Push(T &amp;obj) &#123; ScopeLock lock(m_lock); if(m_capacity &gt; m_offset) &#123; new (&amp;(m_objects[m_offset++])) T(obj); // 拷贝构造 return true; &#125; return false; &#125; bool Pop(T &amp;obj) &#123; ScopeLock lock(m_lock); if(m_offset &gt; 0) &#123; obj = m_objects[--m_offset]; m_objects[m_offset].~T(); // 析构掉 return true; &#125; return false; &#125; void Clear() &#123; &#125; bool Reserve(int newCap) &#123; if(m_capacity &lt; newCap) &#123; T * objs = new T[nNewCap]; // 逐个复制 if(m_objects != nullptr) &#123; while(m_offset &gt; 0) &#123; --m_offset; objs[m_offset] = m_objects[m_offset]; m_objects[m_offset].~T(); &#125; delete[] m_objects; &#125; m_objects = objs; &#125; else if(m_offset &gt; newCap) &#123; while(m_offset &gt; newCap) &#123; m_objects[--m_offset].~T(); // 析构多余的 &#125; &#125; m_capacity = newCap; &#125;&#125;; 线程同步精要尽量使用高层同步设施（线程池，队列，）使用普通互斥锁和条件变量来同步，采用RAII和Scoped Locking写个安全的Singleton, 用shared_ptr来实现copy-on-write 12345678910111213141516171819202122232425template &lt;class T&gt;class Singleton&#123;public: T* Get() &#123; phtread_once(&amp;once, &amp;init); return m_pObj; &#125; void init() &#123; m_pObj = new T; &#125; T* m_pObj; pthread_once_t once;&#125;;/* example */class Test&#123; static Test* Instance() &#123; static Singleton&lt;Test&gt; test; return test.Get(); &#125;&#125; 常用变成模型单线程服务器模型，“non-blocking IO + IO multiplexing” ， 即Reactor模式。程序基本结构一个事件驱动，以事件驱动和回调方式实现。 12345678910111213// 缺点：回调函数必须非阻塞，割裂了业务逻辑不易于维护while(!bStop)&#123; switch(poll()) &#123; case 0: break; // 超时 case -1: break; // 出错 default: break; // IO事件回调 accept或read &#125;&#125; 多线程服务器模型: 1 阻塞IO, 一个请求一个连接（V4查询代理）2 阻塞IO，线程池，是对1的优化3 non-blocking IO + one loop per thread， 即JAVA NIO4 Leader/Flower等高级模式 one loop per thread优点: 1 线程数据固定，启动时创建好，不会频繁创建和销毁2 方便线程间调配负载，Eventloop代表线程主循环，把IOChannel(如TCP连接)注册到需要干活的线程。3 IO事件的发生是固定的，同一个TCP链接不需要考虑并发 同步，调用者主动等待返回结果；异步，调用发出之后，调用就直接返回了，所以没有返回结果。但是在处理IO的时候，阻塞/非阻塞/IO复用(select/epoll)，都属于同步IO，异步IO有专门的API接口。 消息队列和线程池，参考Java的Arrary和Linked，线程分类(IO线程，计算线程，第三方库如log，数据库连接线程) 适用场景，具体分析，IO密集型和计算密集型，链接数 多线程系统编程精要__thread 只能修饰非POD类型，不能修饰class，可以修饰全局或函数内的静态变量epoll增删改fd需要在同一个线程中进行，所以Eventloop需要wakeup()Socket对象包装文件描述符fd，便于读写不串话及生命周期管理(shared_ptr)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[win10使用问题]]></title>
    <url>%2F2019%2F12%2F27%2Fwin10%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[删除国际键盘输入法切换时，英语-美式/英语-国际/中文。 设置=&gt;时间和语言=&gt;区域和语言=&gt;管理语言设置 取消FN键盘Fn + Esc 恢复或取消F1~F12 WLAN不见了麻烦右键1535驱动，选择卸载设备，不要勾选对话框，直接点击卸载 完成后，机器关机，然后开机后，马上连续敲击F2，进入后点击右下角restore setting，选择bios default，选择OK，然后点击右下角exit 重启电脑后，进入系统里查看wifi情况 选择网络还是没有无线，接下来考虑的是驱动或者系统问题 麻烦您右键左下角开始按钮–选择windows powershell（管理员 win+x），输入：netsh winsock reset，回车运行，成功后，重启电脑 充电设置开机F2进入BIOS设置，选择Power Managerment，选择Primary Battery Charge Configuration 系统清理C:\Users\zhangbb\AppData C:\Windows\Installer 快捷键win + d 窗口最小化 win + e 打开我的电脑 win + x 设备管理器，任务管理器，磁盘管理，设置 win + r 运行。。。 ctrl + alt + delete 注销，切换用户，任务管理器 ctrl + shift + delete 快速清除浏览器缓存 github无法访问电脑管家=&gt;工具箱=&gt;DNS优选 常用DNS：阿里云 (223.5.5.5, 223.6.6.6 )Google Public DNS （8.8.8.8， 8.8.4.4）腾讯 119.29.29.29 C:\Windows\System32\drivers\etc 一般用不到，能访问的指定合适的DNS肯定可以访问 c盘清理C:\Users\zhangbb\AppData\Roaming\PCDr dell诊断支持使用 C:\Program Files\WindowsApps 应用商店，不用可删除 windows.old 升级备份，可删除 删除应用qq/微信缓存 关闭休眠：Cortana=&gt;cmd=&gt;以管理员身份运行=&gt;powercfg /h off 删除临时文件：设置=&gt;系统=&gt;存储=&gt;C盘=&gt;临时文件=&gt;删除文件 虚拟内存更改：我的电脑=&gt;右键属性=&gt;高级系统设置=&gt;高级=&gt;（视觉效果)设置=&gt;高级=&gt;(虚拟内存)更改]]></content>
  </entry>
  <entry>
    <title><![CDATA[load-balance问题分分析]]></title>
    <url>%2F2019%2F12%2F13%2Fload-balance%E9%97%AE%E9%A2%98%E5%88%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[brief]]></title>
    <url>%2F2019%2F12%2F11%2Fbrief%2F</url>
    <content type="text"><![CDATA[基本情况 姓名： 出生年月：1988.12 学历：本科/自动化专业/浙江工业大学之江学院 毕业时间：2011.7 期望职位: Linux c++ 开发 手机: Email: 工作经历亚信软件(2016.4~至今) 负责计费系统xxx 主要参与了北京物联网, 浙江计费中心建设, 5G等项目 具体技术: Linux c++, zk, docker, rpc, http2, mysql 浙江大华技术股份有限公司(2015.10~2016.4) 在网络平台部负责定制化需求开发车载设备/监控设备: 定位, 路况汇报, 抓拍, 测速, 音视频控制等业务功能 具体技术：Linux c++ 亚信软件(2012.7~2015.10) 负责计费系统部分模块开发运维 及 需求设计分析 主要参与了在线计费, 贵州双中心等项目 具体技术：Linux c++ , Lua, Oracle 杭州凯宇信息技术有限公司(2010.12~2012.6) 负责IM服务器后端开发, 完成乐聊/百视汇多媒体社交APP服务端开发 具体技术：Linux c++, libevent/spserver, postgresql, memcached, tcpdump/wireshark工具 项目经历浙江5G项目负责系统中解码，将JSON消息格式转换成内部消息格式负载均衡模块开发，线程池/对象池 浙江计费中心建设项目服务化架构升级，负责系统业务模块改造方案及部分模块设计开发重构资费引擎批价模块, (引入c++11新特性, 设计模式, 资费数据用共享内存), 提高可维护性查询服务模块，高并发的网络服务库, (查询量和性能)内存数据库 插件开发(服务接口和路由和导出)和优化(查重优化) 北京物联网项目负责系统总体设计方案和实施, 计费流程引入乐观锁和流量分片, 性能提升了多少 在线计费项目负责在线计费流程优化, 压力测试和优化，增加KPI指标模块衡量各个模块性能]]></content>
  </entry>
  <entry>
    <title><![CDATA[v8实施经验分享]]></title>
    <url>%2F2019%2F12%2F09%2Fv8%E5%AE%9E%E6%96%BD%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[代码开发照搬浙江V8代码，做适配修改，具体要点如下： 模块 说明 xc xcd模板实现 批价 结构调整(接口离线/在线/漫游/回退/5G融合计费)，去掉按量接口，提醒等相关功能； xc查询接口，在线冲销(最好封装成接口)，科目转换，新增业务功能 计费mdb 调整上下行包定义，表定义，业务接口具体逻辑 mapreduce 路由适配 查询代理 TG(socket消息收发) 和 工具(压测和对账) 直接用，TP 业务接口做调整 数据割接1）PM_EXPRESSIONS 条件表达式，USE_TRIGGER按模块区分2）科目转换 环境准备1）V5/V8 自测流程搭建，便于开发去复现问题2）编译时去掉O2，便于GDB调试 遇到过的问题1）xca）建议 index 定义尽量显示，少用indexs=“KEY”，查询sqlite文件时方便点 1&lt;container indexs="PROD_PROP_ID" name="PM_PROD_BILL_EXT_PROP" type="hash_multimap"&gt; b） PM_CURVE_SEGMENT.TAIL_ROUND 等 小数精度加载到xc时转换成了整数，注意下 1TO_CHAR(A.RATE_ROUND, '0D99') AS RATE_ROUND 2）批价对账问题，没有太大参考意义，具体情况具体分析。基本都是某个字段的差异(STD_UNIT, CHARGE1) 3）计费mdba）mdb无缝ck，代码中去掉sleep相关操作 b) 统一设置 MDB CK 后缀名，主端格式为 .mdb.xy.yyyymmdd , 备端 .mdb.stb.xy.yyyymmdd 1RATMDB_CAMTFreeResource.mdb.01.20191115 c）批价查询接口，查多个mdb时，一个查询/接收完后再顺序处理下一个mdb(mapreduce 重载ReqAndRes4Queryratingmdb) d）mapreduce 在gmake clean_all 会删除rdl 对应的h/cpp 文件，gmake install_headers 后自动重新生成，覆盖掉了开发提交的修改。在mapreduce 的Makefile中去掉IMPL_RDL = .rdl 依赖，由开发提交和控制rdl 对应的h/cpp 文件。后续QA编译不会再自动生成rdl接口代码文件。 e）计费MDB A2 HA和容 在binlog乱序时 异常退出，主端先执行truncate(告警导出)，再执行insert(批价更新) ，备端先执行了insert ，导致出错。 4）查询代理对账一把，具体问题具体分析]]></content>
  </entry>
  <entry>
    <title><![CDATA[备战2020]]></title>
    <url>%2F2019%2F11%2F11%2F%E5%A4%87%E6%88%982020%2F</url>
    <content type="text"><![CDATA[简历重构经验 项目描述项目描述两三行，然后概括下我大概做了哪几个模块，完了。 找2-3个亮点, 一句话高度概括，突出亮点。 比如： 我负责这个系统中爬虫的开发，终端控制管理，店铺管理 负责系统中爬虫模块的开发，用于爬取影片的各种信息，包括年份，介绍，主演信息等 独立开发多线程影片信息爬虫工具， 并针对线程池性能、网络异常以及反爬虫措施进行多次优化，容错性良好并达到并发请求30+的QPS 面试的人有问题可以提，自己也可以掌握主动权，把握方向。 面试技巧1 简历一行行看，不要给自己挖坑 2 心态平和，正常表达，逻辑清晰有条理 3 缘分和运气 4 要有信念， 努力+坚持 目标 学习准备 C/C++ 技术面试基础知识总结 技术面试必备基础 C/C++const / static / this / inline / volatile / assert / sizeof / #program pack(n) / 位域 extern / struct class union / explicit / friend / using / enum / decltype 引用 / 成员初始化列表 / 面向对象 / 虚析构函数 / 纯虚函数 / 虚函数 纯虚函数 虚函数表 指针 / 虚继承 / 模板类 函数 虚函数 / 抽象类 接口类 聚合类 / 内存分配管理 delete this / 定义只能在堆或栈上生成的类 / 智能指针 / 强制类型转换运算符号 conststatic 修饰变量，存储在静态区，在main函数前分配了空间 修饰函数，表明函数作用范围，仅在定义该函数的文件内使用。一般为了避免与其他命名空间函数重名 修饰成员变量，不需要生成对象就能访问，只保存一份 修饰成员函数，不需要生成对象就能访问，在static函数内不能访问非静态成员 this 指针 定义：隐含于非静态成员函数的特殊指针，指向调用该函数的对象 当一个对象调用成员函数时，编译程序先将对象地址赋值给this指针，存取数据成员都隐式使用this指针 当一个成员函数被调用时，自动向它传递一个隐含的参数(指向成员函数所在对象的指针) this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（ 不能对这种对象的数据成员进行赋值操作 ） 应用场景：if(this == &amp;other) 避免对同一对象赋值 inline 内联函数为什么需要效率高，省去函数调用开销，内联函数会在调用时 “内联的” 展开 1234567inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;则调用： cout&lt;&lt;max(a, b)&lt;&lt;endl;在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl; 特征1)相当于把内联函数里面的内容写在调用内联函数处 2)相当于不用执行进入函数的步骤，直接执行函数体 3)相当于宏定义，比宏多了类型检查，具有函数特征 4)编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数 5)在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数 编译器对内联的处理1）将内联函数体复制到调用点处 2）为内联函数中的局部变量分配空间 3）将内联函数的输入参数和返回值映射到调用方法的局部变量空间中 4） 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO） 5） 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数 6） 在类声明中定义的函数(函数实现)，除了虚函数的其他函数都会自动隐式地当成内联函数 优缺点优点： 1） 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度 2） 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会 3） 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能 4） 内联函数在运行时可调试，而宏定义不可以 缺点： 1） 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间 2） inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接 3）是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器 虚函数可以内联吗1） 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联 2） 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联 3） inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生 volatile1）volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） 2）const 可以是 volatile （如只读的状态寄存器） 3）指针可以是volatile assert 断言，是宏，而非函数。 assert 宏的原型定义在 （C）、（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include 之前 1234#define NDEBUG // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL ); // assert 不可用 sizeof sizeof 对数组，得到整个数组所占空间大小 ; sizeof 对指针，得到指针本身所占空间大小。 #program pack(n) 设定结构体、联合以及类成员变量以 n 字节方式对齐 1234567891011121314151617181920212223242526#pragma pack(push) // 保存对齐状态#pragma pack(4) // 设定为 4 字节对齐struct test&#123; char m1; double m4; int m3;&#125;;#pragma pack(pop) // 恢复对齐状态sizeof(test)=16// 其他#pragma pack(push,1)typedef struct &#123; unsigned short int Rate; // Playback rate (hertz). long Size; // Size of data (bytes). long UncompSize; // Size of data (bytes). unsigned char Flags; // Holds flags for info // 1: Is the sample stereo? // 2: Is the sample 16 bits? unsigned char Compression; // What kind of compression for this sample?&#125; AUDHeaderType;#pragma pack(pop) 位域类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域 123456789101112131415161718192021222324struct bs &#123; unsigned int a:4; unsigned int :0; /* 空域, 剩余28bit补全0 */ unsigned int b:4; /* 从下一单元开始存放 */ unsigned int c:4; &#125;;// 整个结构体的总大小为最宽基本类型成员大小的整数倍sizeof(bs)=8sizeof(unsigned int)=4 #include &lt;bitset&gt;bitset&lt;2&gt; foo(12); //12的二进制为1100（长度为４），但foo的size=2，只取后面部分，即00string s = "100101"; bitset&lt;4&gt; bar(s); //s的size=6，而bitset的size=4，只取前面部分，即1001foo&amp;bar;foo^bar;foo|bar;~foo;if(foo[0] == false);foo.to_string();foo.to_ullong();std::hash&lt;std::bitset&gt;(C++11)散列支持 extern1）被 extern 限定的函数或变量是 extern 类型的（ 不能和static同时修饰 ）。 B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可, 在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数 2）被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的 123456789#ifdef __cplusplusextern "C" &#123;#endifNAMESPACE_BILLING40_FRAME CThread* create_instanceRating();#ifdef __cplusplus&#125;#endif struct/classstruct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 123456789101112// ctypedef struct Student &#123; int age; &#125; S;// cstruct Student &#123; int age; &#125;;typedef struct Student S;// c++ 可以省略struct union联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态 。具有如下特点： 1）默认访问控制符为 public，不能包含 protected 成员或 private 成员2）可以含有构造函数、析构函数3）不能继承自其他类，不能作为基类，不能含有虚函数，不能含有引用类型的成员4）匿名 union 在定义所在作用域可直接访问 union 成员5）全局匿名联合必须是静态（static）的 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;union UnionTest &#123; UnionTest() : i(10) &#123;&#125;; int i; double d;&#125;;static union &#123; int i; double d;&#125;;int main() &#123; UnionTest u; union &#123; int i; double d; &#125;; std::cout &lt;&lt; u.i &lt;&lt; std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout &lt;&lt; ::i &lt;&lt; std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout &lt;&lt; i &lt;&lt; std::endl; // 输出局部匿名联合的 30 return 0;&#125; explicit(显示)关键字1）修饰构造函数时，可以防止隐式转换和复制初始化2）修饰转换函数时，可以防止隐式转换，但 按语境转换 除外 123456789101112131415161718192021222324252627282930313233343536373839404142struct A&#123; A(int) &#123; &#125; operator bool() const &#123; return true; &#125;&#125;;struct B&#123; explicit B(int) &#123;&#125; explicit operator bool() const &#123; return true; &#125;&#125;;void doA(A a) &#123;&#125;void doB(B b) &#123;&#125;int main()&#123; A a1(1); // OK：直接初始化 A a2 = 1; // OK：复制初始化 A a3&#123; 1 &#125;; // OK：直接列表初始化 A a4 = &#123; 1 &#125;; // OK：复制列表初始化 A a5 = (A)1; // OK：允许 static_cast 的显式转换 doA(1); // OK：允许从 int 到 A 的隐式转换 if (a1); // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a6（a1）; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a7 = a1; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1); // OK ：static_cast 进行直接初始化 B b1(1); // OK：直接初始化 B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以复制初始化 B b3&#123; 1 &#125;; // OK：直接列表初始化 B b4 = &#123; 1 &#125;; // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化 B b5 = (B)1; // OK：允许 static_cast 的显式转换 doB(1); // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换 if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换 bool b8 = static_cast&lt;bool&gt;(b1); // OK：static_cast 进行直接初始化 return 0;&#125; friend友元类和友元函数1）能访问私有函数 2）破坏封装性 3）友元关系单向不可传递 123456789101112131415class A&#123;public: friend ostream&amp; operator&lt;&lt;( ostream&amp; pOut, const CBSPkgDetail&amp; pElement ) &#123; pOut &lt;&lt; " CBSPkgDetail -- pkg_id:" &lt;&lt; pElement.m_nPkgId &lt;&lt; " numerrator:"&lt;&lt;pElement.m_nNumerator &lt;&lt; " denominator:"&lt;&lt;pElement.m_nDenominator; return pOut; &#125;private: int m_nPkgId; int m_nNumerator; int m_nDenominator;&#125; using1）使用namespace2） 在 C++11 中，派生类能够重用其直接基类定义的构造函数3）在 C++11 中，定义别名 12345678910111213class Derived : Base &#123;public: using Base::Base; /* ... */&#125;;// 对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。// 生成如下类型构造函数：Derived(parms) : Base(args) &#123; &#125;// c++11template &lt;typename T&gt;using Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;Vec&lt;int&gt; vec; :: 范围解析运算符enum 枚举类型12345678910111213141516//限定作用域的枚举类型. enum class Phone : int&#123; //这里的:int指出了该enum的潜在类型. Iphone, Nokia, Moto&#125;;// 限定类型enum AttachType : unsigned char &#123; ATTACH_NONE=0x00, ATTACH_CELL=0x01, &#125;// 不限定enum color &#123; red, yellow, green &#125;;enum &#123; floatPrec = 6, doublePrec = 10 &#125;; decltype 用于检查实体的声明类型或表达式的类型及值分类 1234567891011121314// 尾置返回允许我们在参数列表之后声明返回类型template &lt;typename It&gt;auto fcn(It beg, It end) -&gt; decltype(*beg)&#123; // 处理序列 return *beg; // 返回序列中一个元素的引用&#125;// 为了使用模板参数成员，必须用 typenametemplate &lt;typename It&gt;auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type&#123; // 处理序列 return *beg; // 返回序列中一个元素的拷贝&#125; 引用左值引用，常规引用，一般表示对象的身份。 12int x = 20; // 将左值看成是一个可以获取地址的量，它可以用来标识一个对象或函数int&amp; rx = x; // 定义引用时必须初始化 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 12345int&amp;&amp; rrx = 200; // 右值定义在c++11中用&amp;&amp;int x = 20; // 左值int&amp;&amp; rx = x * 2; // x*2的结果是一个右值，rx延长其生命周期int&amp;&amp; rrx1 = x; // 非法：右值引用无法被左值初始化, 因为左值不需要延长生命周期const int&amp;&amp; rrx2 = x; // 非法：右值引用无法被左值初始化 右值引用，可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding）： 将内存的所有权从一个对象转移动另一个对象，高效的移动来替换低效率的复制，对象的移动语义需要实现移动构造函数和移动赋值运算符(默认生成), STL等模板库(vector,list)已支持 定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其他函数，且保证目标函数接受的参数的类型与传递给模板函数的类型相同。 引用折叠规则(用于参数类型推导) X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp; X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 检查类是否有移动语义std::cout &lt;&lt; std::is_move_constructible&lt;MyString&gt;::value &lt;&lt; '\n';// 编译器区分了左值和右值，对右值调用了转移构造函数和转移赋值操作符MyString(MyString&amp;&amp; str) &#123; std::cout &lt;&lt; "Move Constructor is called! source: " &lt;&lt; str._data &lt;&lt; std::endl; _len = str._len; _data = str._data; str._len = 0; str._data = NULL; &#125;MyString&amp; operator=(MyString&amp;&amp; str) &#123; std::cout &lt;&lt; "Move Assignment is called! source: " &lt;&lt; str._data &lt;&lt; std::endl; if (this != &amp;str) &#123; _len = str._len; _data = str._data; str._len = 0; str._data = NULL; &#125; return *this; &#125;int main() &#123; MyString a; a = MyString("Hello"); std::vector&lt;MyString&gt; vec; vec.push_back(MyString("World")); &#125;Move Assignment is called! source: Hello Move Constructor is called! source: World// 左值引用当做右值引用来使用，使用std::movetemplate&lt;class T&gt; void swap(T&amp; a, T&amp; b) &#123; T tmp(std::move(a)); a = std::move(b); b = std::move(tmp);&#125; // 目标函数void foo(const string&amp; str); // 接收左值void foo(string&amp;&amp; str); // 接收右值// 精确传递，定义一次，接受一个右值引用的参数，就能够将所有的参数类型原封不动的传递给目标函数// std::forwardtemplate &lt;typename T&gt; void forward_value(T&amp;&amp; val) &#123; process_value(val); &#125;// 右值实参为右值引用，左值实参仍然为左值引用（就是参数的属性不变）int a = 0; const int &amp;b = 1; forward_value(a); // int&amp; forward_value(b); // const int&amp; forward_value(2); // int&amp;&amp; 参考 宏12 成员初始化列表好处 1）更高效：少了一次调用默认构造函数的过程。 2）有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化 initializer_list 列表初始化 用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt; template &lt;class T&gt;struct S &#123; std::vector&lt;T&gt; v; S(std::initializer_list&lt;T&gt; l) : v(l) &#123; std::cout &lt;&lt; "constructed with a " &lt;&lt; l.size() &lt;&lt; "-element list\n"; &#125; void append(std::initializer_list&lt;T&gt; l) &#123; v.insert(v.end(), l.begin(), l.end()); &#125;&#125;;template &lt;typename T&gt;void templated_fn(T) &#123;&#125;int main()&#123; S&lt;int&gt; s = &#123;1, 2, 3, 4, 5&#125;; // 复制初始化 s.append(&#123;6, 7, 8&#125;); // 函数调用中的列表初始化 templated_fn&lt;std::initializer_list&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // OK templated_fn&lt;std::vector&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // 也 OK&#125; 面向对象封装 public 成员：可以被任意实体访问 protected 成员：只允许被子类及本类的成员函数访问 private 成员：只允许被本类的成员函数、友元类或友元函数访问 继承多态多态是以封装和继承为基础的，c++多态分类及实现：1）重载多态（编译期）：函数重载，运算符重载2）子类型多态（运行期）：虚函数3）参数多态性(编译期)：类模板，函数模板4）强制多态(运行/编译期)：基本类型转换，自定义类型转换 静态多态就是函数重载 动态多态 虚函数：用 virtual 修饰成员函数，使其成为虚函数 注意：1）非类成员函数不能是虚函数2）静态函数(static)不能是虚函数3）构造函数不能是虚函数(因为在调用构造函数时，虚表指针还没有在对象空间中，必须要调用完构造函数后才会生成虚表指针)4）内联函数不能是表现多态时的虚函数，详见内联说明 虚析构函数虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 纯虚函数纯虚函数是一种特殊的函数，在基类中没有实现，留给派生类去实现。 1virtual int A() = 0; 虚函数、纯虚函数1）虚函数在子类里面可以不重写，但纯虚函数必须在子类实现才可以实例化类2）虚函数的类用于“实现继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现有子类完成3）带纯虚函数的叫抽象类，这种类不能直接生成对象，而只有被继承实现其虚函数后才能被使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。 虚函数指针、虚函数表1）虚函数指针：在含有虚函数的类对象中，指向虚函数表，在运行时确定。2）虚函数表：在程序只读数据段（ .rodata section ），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个指针，在编译时间根据类的声明创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// g++ dump出的名称是其内部继承结构g++ -fdump-class-hierarchy -std=c++11 -c test.cpp// c++filt导出具有一定可读性的文档 test.cpp.002t.classcat [g++导出的文档] | c++filt -n &gt; [具有一定可读性的输出文档]// 单继承struct A&#123; int ax; virtual void f0() &#123;&#125;&#125;;struct B : public A&#123; int bx; virtual void f1() &#123;&#125;&#125;;struct C : public B&#123; int cx; void f0() override &#123;&#125; virtual void f2() &#123;&#125;&#125;; C VTable（不完整)struct C +------------+object | RTTI for C | 0 - struct B +-------&gt; +------------+ 0 - struct A | | C::f0() | 0 - vptr_A -------------------------+ +------------+ 8 - int ax | B::f1() | 12 - int bx +------------+ 16 - int cx | C::f2() |sizeof(C): 24 align: 8 +------------+ // 多重继承struct A&#123; int ax; virtual void f0() &#123;&#125;&#125;;struct B&#123; int bx; virtual void f1() &#123;&#125;&#125;;struct C : public A, public B&#123; int cx; void f0() override &#123;&#125; void f1() override &#123;&#125;&#125;; C Vtable (7 entities) +--------------------+struct C | offset_to_top (0) |object +--------------------+ 0 - struct A (primary base) | RTTI for C | 0 - vptr_A -----------------------------&gt; +--------------------+ 8 - int ax | C::f0() | 16 - struct B +--------------------+ 16 - vptr_B ----------------------+ | C::f1() | 24 - int bx | +--------------------+ 28 - int cx | | offset_to_top (-16)|sizeof(C): 32 align: 8 | +--------------------+ | | RTTI for C | +------&gt; +--------------------+ | Thunk C::f1() | +--------------------+// Thunk 作用是找到C::f1()的地址(偏移地址-16)// 构造顺序A,B,C，析构C,B,AB* pb = new C();pb-&gt;f1(); -----多重继承3340 Vtable for A 3341 A::vtable for A: 3u entries3342 0 (int (*)(...))03343 8 (int (*)(...))(&amp; typeinfo for A)3344 16 (int (*)(...))A::f03345 3346 Class A3347 size=16 align=83348 base size=12 base align=83349 A (0x0x2b37ee087600) 03350 vptr=((&amp; A::vtable for A) + 16u)3351 3352 Vtable for B3353 B::vtable for B: 3u entries3354 0 (int (*)(...))03355 8 (int (*)(...))(&amp; typeinfo for B)3356 16 (int (*)(...))B::f13357 3358 Class B3359 size=16 align=83360 base size=12 base align=83361 B (0x0x2b37ee087660) 03362 vptr=((&amp; B::vtable for B) + 16u)3364 Vtable for C3365 C::vtable for C: 7u entries3366 0 (int (*)(...))03367 8 (int (*)(...))(&amp; typeinfo for C)3368 16 (int (*)(...))C::f03369 24 (int (*)(...))C::f13370 32 (int (*)(...))-163371 40 (int (*)(...))(&amp; typeinfo for C)3372 48 (int (*)(...))C::non-virtual thunk to C::f1()3373 3374 Class C3375 size=32 align=83376 base size=32 base align=83377 C (0x0x2b37ee120700) 03378 vptr=((&amp; C::vtable for C) + 16u)3379 A (0x0x2b37ee0876c0) 03380 primary-for C (0x0x2b37ee120700)3381 B (0x0x2b37ee087720) 163382 vptr=((&amp; C::vtable for C) + 48u)----- 虚继承A=&gt;Base, B=&gt;Base, C=&gt;A,B Base存储了2份， C对象调用Base方法会有二义性问题。 虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态(公共基类存储1份)。 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 1234// 典型应用class istream : virtual public ios&#123;...&#125;;class ostream : virtual public ios&#123;...&#125;;class iostream : public istream, public ostream&#123;...&#125;; 虚继承、虚函数1）相同之处：都使用虚指针（占用类存储空间）和虚表（不占类存储空间） 2）不同之处： 虚继承，虚基类存储在在继承类中，只占用存储空间；虚基类表存储的是虚基类相对直接继承类的偏移 虚函数，虚函数不占用类存储空间，虚函数表存储的是虚函数地址 模板类、成员模板、虚函数1）模板类中可以使用虚函数2）一个类的成员模板(本身是模板的成员函数)不能是虚函数，不管是普通类还是类模； 因为虚函数表里的虚函数指针是确定的，成员模板无法确定 抽象类、接口类、聚合类1）抽象类：含有纯虚函数的类2）接口类：只含有纯虚函数的抽象类3）聚合类：用户可以直接访问成员，并且具有特殊的初始化语法形式。满足如下特点： a）所有成员都是public b）没有定义任何构造函数 c）没有类内初始化 d）没有基类，也没有virtual函数 内存分配管理1）malloc：申请指定字节数内存，申请到内存中的初始值不确定2）calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存初始化为03）realloc：更改以前分配内存长度(增加或减少）。当增加长度时，将以前分配区的内容移动到一个足够大的区域，新增区域内的初始值不确定4）alloca：在栈上申请内存。程序在出栈的时候，会自动释放。但需要注意的是alloca不可移植，在没有传统堆栈的机器上很难实现，所以不宜用在需要广泛移植的程序中。C99中支持变长数组(VLA)可以用来替代alloca 1234void* malloc (size_t size);void* calloc (size_t num, size_t size);void* realloc (void* ptr, size_t size);void * __cdecl alloca(size_t); // 有些函数定义成__cdecl宏 5)new/delete a）new/new [] 完成两件事，先调用malloc分配内存，然后调用构造函数创建对象 b）delete/delete [] 完成两件事, 先调用析构函数(清理资源)，再调用free释放空间 c）new 在申请内存时会自动计算所需字节数，而malloc需要我们自己指定 6）定位new 允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象 12345678910111213141516171819202122232425262728// place_address 内存地址指针new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123; braced initializer list &#125;class Test&#123;public:Test(int i): m_i(i) &#123;&#125;~Test()&#123;cout&lt;&lt;"~Test."&lt;&lt;endl;&#125;public: int m_i;&#125;;int main()&#123; int* p = new int[1024]; cout &lt;&lt; "p=" &lt;&lt; p &lt;&lt; endl; Test* ptr = new(p) Test(5); cout&lt;&lt; "ptr-&gt;m_i=" &lt;&lt; ptr-&gt;m_i &lt;&lt; endl; cout&lt;&lt; "ptr=" &lt;&lt; ptr&lt;&lt; endl; ptr = new(p+sizeof(Test)) Test(6); cout&lt;&lt; "ptr-&gt;m_i=" &lt;&lt; ptr-&gt;m_i &lt;&lt; endl; cout&lt;&lt; "ptr=" &lt;&lt; ptr&lt;&lt; endl; delete[] p;&#125; delete this 合法吗？合法，但：1） 必须保证 this 对象是通过 new 分配的 （不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）2）必须保证是最后一个调用this的成员函数，后面没有继续调用this了 如何定义一个只能在堆上(栈上)生成对象的类只能在堆上 1）方法：将析构函数设置为私有2）原因：c++是静态绑定语言，编译器管理栈上的生命周期，编译器在为对象分配栈空间时，会先检查类的析构函数的访问性，若析构函数不能访问，则不能在栈上创建 只能在栈上 1）方法：将new/delete重载为私有2）原因：在堆上生成对象，用new关键字，过程分为两个阶段：new 在堆上找可用内存，分配对象；调用构造函数生成对象。new 设为私有，第一步无法完成 智能指针C++标准库STL中，头文件#include 1) shared_ptr多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 2) weak_ptrweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 3) unique_ptr unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr 4) auto_ptr 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵(不支持数组和容器)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// shared_ptrget() // 获取原始指针reset() // 释放关联内存块的所有权，计数减一, 如果是最后一个指向该资源的shared_ptr, 就释放这块内存unique() // 判断是否是唯一指向当前内存的shared_ptruse_count() // 返回引用计数 // weak_ptruse_count() // 返回管理该对象的 shared_ptr 对象数量expire() // 检查被引用的对象是否已删除 lock() // 创建管理被引用的对象的shared_ptr reset() // 将本身设置为空int main() &#123;&#123; std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10); std::cout &lt;&lt; sh_ptr.use_count() &lt;&lt; std::endl; // 1 std::weak_ptr&lt;int&gt; wp(sh_ptr); std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; // 1 if(!wp.expired())&#123; std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //get another shared_ptr *sh_ptr = 100; std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; // 2 wp.reset(); std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; sh_ptr2.use_count() &lt;&lt; std::endl; // 2 &#125;&#125;//delete memory&#125;// unique_ptr release() // 返回一个指向被管理对象的指针，并释放所有权 reset() // 参数可以为 空、内置指针，先将原来对象释放，再重新设置新对象swap() // 交换被管理对象 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;cassert&gt;#include &lt;functional&gt; struct B &#123; virtual void bar() &#123; std::cout &lt;&lt; "B::bar\n"; &#125; virtual ~B() = default;&#125;;struct D : B&#123; D() &#123; std::cout &lt;&lt; "D::D\n"; &#125; ~D() &#123; std::cout &lt;&lt; "D::~D\n"; &#125; void bar() override &#123; std::cout &lt;&lt; "D::bar\n"; &#125;&#125;; // a function consuming a unique_ptr can take it by value or by rvalue referencestd::unique_ptr&lt;D&gt; pass_through(std::unique_ptr&lt;D&gt; p)&#123; p-&gt;bar(); return p;&#125; void close_file(std::FILE* fp) &#123; std::fclose(fp); &#125; int main()&#123; std::cout &lt;&lt; "unique ownership semantics demo\n"; &#123; auto p = std::make_unique&lt;D&gt;(); // p is a unique_ptr that owns a D auto q = pass_through(std::move(p)); assert(!p); // now p owns nothing and holds a null pointer q-&gt;bar(); // and q owns the D object &#125; // ~D called here std::cout &lt;&lt; "Runtime polymorphism demo\n"; &#123; std::unique_ptr&lt;B&gt; p = std::make_unique&lt;D&gt;(); // p is a unique_ptr that owns a D // as a pointer to base p-&gt;bar(); // virtual dispatch std::vector&lt;std::unique_ptr&lt;B&gt;&gt; v; // unique_ptr can be stored in a container v.push_back(std::make_unique&lt;D&gt;()); v.push_back(std::move(p)); v.emplace_back(new D); for(auto&amp; p: v) p-&gt;bar(); // virtual dispatch &#125; // ~D called 3 times std::cout &lt;&lt; "Custom deleter demo\n"; std::ofstream("demo.txt") &lt;&lt; 'x'; // prepare the file to read &#123; std::unique_ptr&lt;std::FILE, decltype(&amp;close_file)&gt; fp(std::fopen("demo.txt", "r"), &amp;close_file); if(fp) // fopen could have failed; in which case fp holds a null pointer std::cout &lt;&lt; (char)std::fgetc(fp.get()) &lt;&lt; '\n'; &#125; // fclose() called here, but only if FILE* is not a null pointer // (that is, if fopen succeeded) std::cout &lt;&lt; "Custom lambda-expression deleter demo\n"; &#123; std::unique_ptr&lt;D, std::function&lt;void(D*)&gt;&gt; p(new D, [](D* ptr) &#123; std::cout &lt;&lt; "destroying from a custom deleter...\n"; delete ptr; &#125;); // p owns D p-&gt;bar(); &#125; // the lambda above is called and D is destroyed std::cout &lt;&lt; "Array form of unique_ptr demo\n"; &#123; std::unique_ptr&lt;D[]&gt; p&#123;new D[3]&#125;; &#125; // calls ~D 3 times&#125; 强制类型转换运算符static_cast 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -&gt; int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） 向上转换是一种隐式转换 dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用 123456try &#123; Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape); &#125; catch (bad_cast b) &#123; cout &lt;&lt; "Caught: " &lt;&lt; b.what(); &#125; 运行时类型信息 (RTTI)typeid/typeinfo Effictive C++STL容器array / vector / deque / forward_list / list / stack / queue / priority_queue / set / map find / sort 1周补充源码阅读, 11.11~11.17 数据结构顺序结构：stack / queue / list / 链队列，单链表，双向链表，循环链表 / 树：二叉/红黑/AVL/B/B+ 1-顺序结构1.1-顺序栈(Sequence Stack)123456typedef struct &#123; ElemType *elem; int top; int size; int increment;&#125; SqStack; 1.2-队列(Sqeuence Queue)1.3-顺序表(Sequence List)2-链式结构1234typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList; 2.1-链队列(Link Queue)2.2-线性表的链式表示单链表(Link List) 双向链表(Du-Link-List) 循环链表(Cri-Link-List) 3-哈希表插入和查找的时间复杂度O(1)，也叫散列表哈希函数 查找某个元素时减少比较次数构造方法 1）直接定址， 取关键字或某个线性函数值为散列地址， H(key) = key 或 H(key) = a*key + b 2）除留余数， 求余， H(key) = key % p, p &lt; m 3）数字分析，选出某几个关键字作为地址 4）折叠， 将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址 5）平方取中， 先计算出关键字值的平方，然后取平方值中间几位作为散列地址冲突处理方法 1）链地址法：key值相同的用单链表链接 2）开放定址法： a）线性探测法，key值相同=&gt;放到key值的下一个位置 Hi = (H(key)+i)%m b）二次探测法：key值相同=&gt; 探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1^2]， T[d+2^2]，T[d+3^2],…，等，直到探查到 有空余地址 或者到 T[d-1]为止 , 无法探查到整个散列空间 c）随机探测法：H = (H(key) + 伪随机数)%m 网络环境下的分布式缓存系统一般基于一致性哈希（Consistent hashing）。简单的说，一致性哈希将哈希值取值空间组织成一个虚拟的环，各个服务器与数据关键字K使用相同的哈希函数映射到这个环上，数据会存储在它顺时针“游走”遇到的第一个服务器。可以使每个服务器节点的负载相对均衡，很大程度上避免资源的浪费。 在动态分布式缓存系统中，哈希算法的设计是关键点。使用分布更合理的算法可以使得多个服务节点间的负载相对均衡，可以很大程度上避免资源的浪费以及部分服务器过载。 使用带虚拟节点的一致性哈希算法，可以有效地降低服务硬件环境变化带来的数据迁移代价和风险，从而使分布式缓存系统更加高效稳定。 线性探测的哈希表数据结构和图片 123456789101112typedef char KeyType;typedef struct &#123; KeyType key;&#125;RcdType;typedef struct &#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 4-递归函数间接或直接的调用自身递归与分治分治法：问题的分解，问题规模的分解递归：折半查找，归并查找，快速排序 递归与迭代迭代：反复用旧变量推出新值折半查找，归并查找 123456789101112131415161718192021// 折半查找（分治）int bin_search(int a[], int size, int key)&#123; int low = 0; int high = size - 1; while(low &lt;= high) &#123; int mid = (low + high) / 2; if(a[mid] == key) return mid; else if(a[mid] &gt; key) high = mid -1; else if(a[mid] &lt; key) low = mid + 1; &#125; return -1;&#125;// 归并查找merge_sort// 快速排序quick_sort 5-二叉树性质1）非空二叉树第 i 层最多 $$ 2^(i-1) $$ 个结点(i&gt;=1)2）深度为k的二叉树最多 $$ 2^(k) -1 $$ 个结点3）包含n个元素的二叉树最大高度为n, 最小为log2^(n+1)4）设完全二叉树中一元素序号为i, 1&lt;=i&lt;=n, 则有以下关系: 1) 当i=1时, 该元素为二叉树的根; 若i&gt;1, 则该元素的父节点编号i/2 2) 当2i&gt;n时, 该元素无左孩子; 否则其左孩子编号为2i 3) 当2i+1&gt;n时, 该元素无右孩子; 否则该右孩子编号为2i+1 存储结构 12345typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 遍历方式 先序遍历，中序遍历，后序遍历，层级遍历 分类1）满二叉树2）完全二叉树(堆)，大顶堆(根&gt;=左 &amp;&amp; 根&gt;= 右)，小顶堆(根&lt;=左 &amp;&amp; 根&lt;= 右)3）二叉查找树(二叉排序树)，左&lt;根&lt;右4）平衡二叉树(AVL树)，|左子树高 - 右子树高| &lt;= 15）最小失衡树：平衡二叉树插入新结点导致失衡，调整： a）LL型：根的左孩子右旋 b）RR型：根的右孩子左旋 c）LR型：根的左孩子左旋，再右旋 d）RL型：右孩子的左子树，先右旋，再左旋 6-其他树图： １周补充, 11.18~11.24 算法排序 / 查找 / 图搜索 / 其他(分治、动态规划、贪心) １周补充 , 11.24~12.1 设计模式23种设计模式 / 设计原则 1周补充，抽空 操作系统进程和线程对于有线程的系统：进程是资源分配的独立单位，线程是资源调度的独立单位。对于没有线程的系统：进程是资源分配和调用的单位 进程间通信及优缺点1-管道(Pipe)1）有名管道：一种半双工通信方式，它允许无亲缘关系进程的通信 优点：可以实现任意进程间通信 缺点：长期存在于系统，使用不当容易出错；缓冲区有限 2）无名管道： 一种半双工的通信方式， 只能在有亲缘关系的进程间通信 优点：简单方便 缺点：局限于单向通信；只能创建在亲缘进程之间；缓冲区有限( 在管道创建时，为缓冲区分配一个页面大小 ) 123456#include &lt;unistd.h&gt;int pipe(int fd[2])#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char * pathname, mode_t mode) 2-信号量(Semaphore)一个计数器，可以用来多个线程对共享资源的访问优点：可以同步进程缺点：信号量有限 12345678910111213141516171819202122232425262728293031323334353637383940414243// 1-----文件名到键值------#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok (char*pathname, char proj)// 系统V信号灯API#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;// 2-----创建一个信号量------int semget(key_t key, int nsems, int semflg) /*nsems 信号量集中信号量的个数semflg IPC_CREAT 存在则返回该信号量集标识符, 不存在则创建 IPC_CREAT|IPC_EXCL 不存在则创建, 否则返回错误*/// 3-----信号量值操作, 成功返回0，否则返回-1-----int semop(int semid, struct sembuf *sops, unsigned nsops)//&#123;0,-1,SEM_UNDO&#125;; /*将信号量对象中序号为0的信号量减1，申请资源*///&#123;0,1,SEM_UNDO&#125;; /*将信号量对象中序号为0的信号量加1，释放资源*///&#123;0,0,0&#125;; /*进程被阻塞，直到对应的信号量值为0*/struct sembuf &#123; unsigned short sem_num; /* semaphore index in array */ short sem_op; /* semaphore operation */ short sem_flg; /* operation flags */&#125;;/*sem_op 大于0表示释放sem_op个数的共享资源, 小于0表示申请-sem_op个数的资源sem_flg IPC_NOWAIT 释放资源不够时直接返回EAGAIN错误，不会睡眠 SEM_UNDO 进程崩溃时，内核自动恢复计数值nsops 一般是1，只完成对一个信号量的操作*/ // 4-----创建，获取，删除, 设置值-----int semctl(int semid, int semnum, int cmd, union semun arg) union semun &#123; short val; /*SETVAL用的值*/ struct semid_ds* buf; /*IPC_STAT、IPC_SET用的semid_ds结构*/ unsigned short* array; /*SETALL、GETALL用的数组值*/ struct seminfo *buf; /*为控制IPC_INFO提供的缓存*/&#125; arg;/*cmd IPC_RMID 删除, SETVAL 设置初始值*/ 3-信号(Signal)信号是在软件层次上对中断机制的模拟。信号来源：硬件来源（按键盘或其他硬件故障），软件来源(kill,raise).信号的分类：可靠信号(支持排队，不会丢失)和不可靠信号(小于32)。实时信号(0～63，可靠)和非实时信号(不支持排队)信号发送 1234567891011121314151617#include &lt;sys/types.h&gt; #include &lt;signal.h&gt; int kill(pid_t pid,int signo)int raise(int signo) int sigqueue(pid_t pid, int sig, const union sigval val) typedef union sigval &#123; int sival_int; void *sival_ptr;&#125;sigval_t;unsigned int alarm(unsigned int seconds) int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue)); void abort(void); 信号的安装 1234typedef void (*sighandler_t)(int)； sighandler_t signal(int signum, sighandler_t handler)); int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact)); 4-消息队列(Message Queue)是消息的链表，存放在内核中并由消息队列标识符标识优点：任意进程间通信，通过系统调用函数实现消息发送和接收同步，使用方便缺点：信息的复制额外消耗CPU的时间，不适合信息量大或操作频繁的场合 12345678910111213141516171819202122232425262728#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;// 文件名到键值key_t ftok (char*pathname, char proj)// 创建消息队列int msgget(key_t key, int msgflg)// 收int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg)// 发int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, int msgflg)struct msgbuf&#123;long mtype;char mtext[1];&#125;;// 设置或删除消息队列int msgctl(int msqid, int cmd, struct msqid_ds *buf)// 注意 msgbuf 可以是自定义结构struct S_PUBLISH_DATA&#123; int32 topic; //! 发布标题 int32 biz_id; //! 业务流程ID int32 flow_id; //! 流程ID int32 pid; //! 进程ID struct tm time; //! 发布时间 int32 content_len; //! 内容长度 char content[0]; //! 发布内容(变长)&#125;; 5-共享内存(Shared Memory)映射到一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程可以访问。 进程间需要共享的数据被放在一个叫做IPC共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。 优点：无需复制，快捷，信息量大缺点：a)通信是通过将共享空间缓存区直接附加到进程的虚拟地址空间中来实现，因此进程间读写操作有同步问题 b)利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的多个进程共享，不方便网络通信 123456789101112#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;// 文件名到键值key_t ftok (char*pathname, char proj)// 创建int shmget(key_t key, size_t size, int shmflg);// 相当于attatchvoid *shmat(int shm_id, const void *shm_addr, int shmflg);// 相当于detachint shmdt(const void *shmaddr);// 控制操作，设置和删除int shmctl(int shm_id, int command, struct shmid_ds *buf); 6-套接字(Socket)用于不同进程和主机间通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 描述套接口通用地址的数据结构struct sockaddr &#123; sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */&#125;;// 描述因特网地址结构的数据结构struct sockaddr_in&#123; unsigned short sin_family; /* 描述协议族 编程中只能是AF_INET*/ in_port_t sin_port; /* 端口号 使用网络字节顺序*/ struct in_addr sin_addr; /* 因特网地址 */ /* Pad to size of `struct sockaddr'. */ unsigned char sin_zero[8]; /* 为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保 留的空字节 */&#125;;struct in_addr &#123; unsigned long s_addr; /*网络字节顺序存储IP地址*/&#125;;// 接口int socket( int domain, int type, int ptotocol)参数：domain 创建网际Ipv4域PF_INET, type SOCK_STREAM或SOCK_DGRAM，ptotocol一般填0int bind( int sockfd, const struct sockaddr * my_addr, socklen_t my_addr_len)参数： int listen(int sockfd, int backlog)参数： backlog 三次握手通过后，Accept queue 队列长度，最终取 min(128,backlog)int connect( int sockfd, const struct sockaddr * servaddr, socklen_t addrlen)int accept( int sockfd, struct sockaddr * cliaddr, socklen_t * addrlen) int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen)// exampleint main()&#123; int nSock = socket( AF_INET, SOCK_STREAM, 0); if( -1 == nSock ) return -1; int iOpt = 1; if(setsockopt(nSock,SOL_SOCKET,SO_REUSEADDR,(const char*)&amp;iOpt, sizeof(iOpt) ) &lt; 0) return -1; // setsockopt( m_nSock, IPPROTO_TCP, TCP_NODELAY, (const char*)&amp;iOpt, sizeof(iOpt) ) // setsockopt(nSock, SOL_SOCKET, SO_KEEPALIVE, (const char*)&amp;iOpt, sizeof(iOpt) ) struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_addr.s_addr = htonl(INADDR_ANY); // inet_pton(AF_INET, " 192.168.0.11", &amp;serv_addr.sin_sddr) ; sin.sin_port = htons(nPort); if( bind( nSock, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0 ) return -1; ::listen( nSock, 256); nClientSock = ::accept( m_nSock, (struct sockaddr*)&amp;clientAddr, &amp;nClientLen);&#125; 线程间通信方式线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。锁机制： 1）互斥锁，以排他方式防止数据结构被并发修改的方法 2）读写锁，允许多个线程同时读共享数据，而对写操作是互斥的 3）自旋锁， 互斥锁是当资源被占用，申请者进入睡眠状态 ；循环检测锁释放已经释放 4）条件变量，阻塞进程，直到某个特定条件为真 信号量机制或信号机制 私有 共享 线程 线程栈，寄存器，程序计数器 堆，地址空间，全局变量，静态变量 进程 堆，栈，寄存器，全局变量，地址空间 代码段，公共数据，进程目录，进程ID 死锁避免死锁的方法：有序分配 字节序 大端字节序：高位字节在前, 低位字节在后, 是人类读取字节的方法 (网络字节序) 小端字节序：低位字节在前, 高位字节在后 页面置换算法在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。 分类 全局置换：在整个内存空间置换 局部置换：在本进程中进行置换 算法全局： 工作集算法 缺页率置换算法 局部： 最佳置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用（LRU）算法 时钟（Clock）置换算法 计算机网络OSI七层 OSI七层 功能 协议 应用层 负责为程序提供统一的接口 ftp telnet http dns 表示层 负责把数据转换成兼容接收系统的格式 NULL(JPEG、MPEG、ASII) 会话层 负责维护计算机之间的通信连接 NULL(NFS、SQL、NETBIOS、RPC) 传输层 负责为数据加上传输表头(包含port), 形成数据包 TCP UDP 网路层 负责数据的路由和转发 IP ICMP IGMP（路由器） RIP 数据链路层 负责MAC寻址, 错误侦测和改错 ARP RARP MTU PPP（网桥，交换机） 物理层 负责在物理网络中传输数据帧 RJ45、CLOCK、IEEE802.3(中继器，集线器) 应用层DNS ，FTP ，TELNETURL统一资源定位符 格式：协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]HTTP 请求方法和状态码 传输层TCP（Transmission Control Protocol，传输控制协议），UDP（User Datagram Protocol，用户数据报协议） TCP如何保证可靠传输ack确认，超时重传，流量控制，拥塞控制，数据校验：TCP首部和IP首部都有校验和，范围不同。数据合理分片和排序：IP分片 在以太网上，由于电气限制，一帧不能超过1518字节，除去以太网帧头14字节（mac地址等）和帧尾4字节校验，还剩1500字节，这个大小称为MTU（最大传输单元）。另外在TCP层有MSS协商，数据会分段，一般约定1460，这样就不会超过MTU。因此TCP传输不会造成IP层分片，在TCP层就分段好了，IP分片一般是给UDP和ICMP使用。 TCP首部最大24个字节，一般没有选项20个字节 UDP首部 TCP与UDP的区别1）TCP是面向连接的，UDP是无连接的2）TCP的逻辑通信是全双工的可靠信道，UDP是不可靠信道3）TCP只能是点对点，UDP可以一对多，一对一，多对一的交互通信4）TCP面向字节流， 实际上是 TCP 把数据看成一连串无结构的字节流 ；UDP面向报文（不会拈包）5）UDP没有拥塞控制， 因此网络出现拥塞不会使源主机的发送速率降低6）TCP首部开销20个字节，UDP首部开销8个字节 TCP粘包问题TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的 。产生原因：1） 发送方 TCP默认会使用Nagle算法: 只有上一个分组得到确认，才会发送下一个分组; 收集多个小分组，在一个确认到来时一起发送 。2） 接受方 没有立即处理, TCP将收到的分组保存至接收缓存里, 缓冲区会存在多个包 。解决办法：1） 发送发关闭Nagle算法, TCP_NODELAY选项 。2） 接受方 TCP协议没有处理机制, 通过应用层来处理。3） 应用层 定义消息包头(len+type)和包体(data), 收包时循环处理。 TCP流量控制 让发送方的发送速率不要太快，要让接收方来得及接收 ，利用可变窗口进行流量控制。 TCP拥塞控制 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载 。 方法：慢开始，拥塞避免，快重传，快恢复。 TCP三次握手和四次挥手 为什么需要三次握手？ 全双工, 告诉对方 发送/接受数据 能力OK 为什么需要四次分手？ 为了确保数据能够完成传输(确保对端收完数据) 为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？ 因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。 TCP的四种定时器a）重传定时器，b）坚持定时器，窗口探查， 解决零窗口大小通知可能导致的死锁问题c）保活定时器，keep-alived）2MSL定时器，time_wait保持2MSL： 1）是为了保证客户端发送的最后一个 ACK 报文能够到达服务端。 若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时 2） 防止已失效的连接请求报文段出现在本连接中 。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段 TCP状态机 网络层IP ，ARP 工作原理ICMP，网际控制报文协议，用于PINGIGMP，网际组管理协议 ，用于多播IP 地址分类： IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;} IP 地址类别 网络号 网络范围 主机号 IP 地址范围 A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 D 类 前四位固定为 1110，后面为多播地址 E 类 前五位固定为 11110，后面保留为今后所用 IP头部格式最大24个字节，一般没有选项20个字节 数据链路层主要信道：点对点信道，广播信道。数据单元：帧。1）点对点信道： 三个基本问题： 封装成帧 , 透明传输 , 差错检测 点对点协议( Point-to-Point Protocol )： 用户计算机和 ISP 通信时所使用的协议 2）广播信道： 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧 物理层传输单位是比特通道： a）单向通道(单工通道)：只有一个方向通信，没有反向交互，如广播 b）双向交替通信(半双工通信)：双发可以发消息，但不能同时发送或接收 c）双向同时通信(全双工通信)：通信双发可以同时发送和接收通道复用技术： a） 频分复用： 不同用户在不同频带，所用用户在同样时间占用不同带宽资源 b） 时分复用 ： 不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 c） 波分复用 ： 光的频分复用 d） 码分复用 ： 不同用户使用不同的码，可以在同样时间使用同样频带通信 TCP/IP四层 TCP/IP四层 功能 应用层 负责向用户提供一组应用程序, 比如HTTP/DNS/FTP 传输层 负责端到端的通信, 比如TCP/UDP 网络层 负责网络包的封装、寻址和路哟, 比如IP/ICMP 网络接口层 负责在物理网络中传输数据帧, 比如MAC寻址, 错误侦测和改错 网络编程网络模型read/writesocket select/poll/epoll参考 TCP队列 发送大文件缓冲区满TCP keep-alive数据库常用数据模型层次模型，网状模型，关系模型， a）关系，一个关系对应通常说的一张表 b）元组，表中的一行即为一个元组 c）属性，表中的一列即为一个属性 d）码，表中可以唯一确定一个元组的的某个属性组 e）域，一组具有相同数据类型的值的集合 f）分量，元组中的一个属性值 g）关系模型，对关系的描述，一般表示为 关系名(属性1，属性2 ……)面向对象数据模型，对象关系数据模型，半结构化数据模型，非关系模型的、有基本固定结构模式的数据，例如日志文件、XML文档、JSON文档、Email等 数据库常用操作查询（选择，投影，链接【等值，自然，左外连接，右外连接】）、除、并、差、交、笛卡尔积)、插入、删除、修改关系模型中的三类完整性约束：实体完整性，参照完整性，用户定义完整性 数据库完整性数据库的完整性是指数据的正确性和相容性？触发器：是用户定义在关系表中的一类由事件驱动的特殊过程 索引MySQL索引背后的数据结构及算法原理 范式参考 1NF：属性(字段)是最小单位不可分割2NF：满足1NF，每个非主属性完全依赖于主键(消除1NF非主属性对码的函数依赖)3NF：满足2NF，任何非主属性不依赖于其他非主属性(消除2NF主属性对码的传递函数依赖)BCNF（ 鲍依斯-科得范式 ）：满足3NF，任何非主属性不能对主键子集依赖( 消除 3NF 主属性对码的部分和传递函数依赖 )4NF：满足3NF， 属性之间不能有非平凡且非函数依赖的多值依赖 ACID参考 并发控制分库分表分析与设计数据库模型过程mysql优化参考 库与链接gdbcommand 分布式系统概念 / 实践 / CAP/BASE/RPC/分布式锁 性能优化linux命令 网络 内存 磁盘 性能 3rdtcmalloc / libevent / boost 2周补充]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gdb command]]></title>
    <url>%2F2019%2F11%2F07%2Fgdb-command%2F</url>
    <content type="text"><![CDATA[参考地址 脚本用户目录下 .gdbinit 文件, 启动gdb时默认加载 1234567891011121314151617181920212223# 打印STL容器中的内容pythonimport syssys.path.insert(0, &apos;/home/maude/gdb_printers/python&apos;)from libstdcxx.v6.printers import register_libstdcxx_printersregister_libstdcxx_printers (None)end# 保存历史命令set history filename ~/.gdb_historyset history save on# 退出时不显示提示信息set confirm off# 按照派生类型打印对象set print object on# 打印数组的索引下标set print array-indexes on# 每行打印一个结构体成员set print pretty on 源文件directory（或dir)命令设置源文件的查找目录 断点12345678910111213141516break/bbreak file:linebreak calss:function// 设置条件断点(gdb) break do_freebie if a&gt; 0 &amp;&amp; b&gt;0// 调试汇编, 在程序地址上打印断点, b *address // 设置临时断点, 只生效一次(gdb) tbreak filename:line// 使用如下命令将设置的断点保存下来(gdb) save breakpoints file-name-to-save// 下次调试时, 加载保存的断点(gdb) source file-name-to-save 函数123456789101112131415161718192021222324252627282930// 从断点开始继续执行continue/c // 不进入的单步执行next/n// 进入的单步执行step/s // nextiUsage: nexti [N]Argument N means step N times (or till program stops for another reason).// jump Usage: jump &lt;location&gt;Give as argument either LINENUM or *ADDR, where ADDR is an expression// 执行完循环体, 后面的一个语句停下until// 退出正在调试的函数(gdb) finish// 选择函数栈帧(gdb) frame 2(gdb) i frame// 向上或向下移动栈帧(gdb) up n(gdb) down n 观察点12345678910111213// 当var值变化时, 程序会停下来(gdb) watch var(gdb) info watchpoints// 设置观察点只针对特定线程// 当线程1改变var的值时程序会停下来, 其他线程改变不会停止(gdb) watch var thread 1// 读观察点, 当发生读取变量行为时，程序就会暂停住(gdb) rwatch var// 当发生读取变量或改变变量值的行为时，程序就会暂停住(gdb) awatch var catchepoint1234567891011121314151617181920212223242526// 设置catchpoint只触发一次(gdb) tcatch fork// 当fork调用发生后, gdb会暂停程序的运行(gdb) catch fork// 为系统调用设置catchpoint(gdb) catch syscall mmap(gdb) help catchSet catchpoints to catch events.List of catch subcommands:catch assert -- Catch failed Ada assertionscatch catch -- Catch an exceptioncatch exception -- Catch Ada exceptionscatch exec -- Catch calls to execcatch fork -- Catch calls to forkcatch load -- Catch loads of shared librariescatch rethrow -- Catch an exceptioncatch signal -- Catch signals by their names and/or numberscatch syscall -- Catch system calls by their names and/or numberscatch throw -- Catch an exceptioncatch unload -- Catch unloads of shared librariescatch vfork -- Catch calls to vfork 打印12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788(gdb) help xExamine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string) and z(hex, zero padded on the left).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format.Defaults for format and size letters are those previously used.Default count is 1. Default address is following last thing printed// 打印字符串(gdb) x/s str1// 格式为“x/nfu addr“, n 是输出单元个数, f 是格式, u 是单元的长度 // 以16进制格式打印数组前32个byte的值(gdb) x/32xb array// 打印STL容器, 加载python脚本后增加可读性// 打印大数组(gdb) set print elements unlimited(gdb) p array// 打印数组中任意连续元素值(gdb) p array[60]@10// 打印函数局部变量的值, bt full [N] 默认打印全部栈函数中的变量, N是栈个数(gdb) bt full#0 fun_a () at a.c:6 a = 0#1 0x000109b0 in fun_b () at a.c:12 b = 1#2 0x000109e4 in fun_c () at a.c:19 c = 2 // 只打印当前函数局部变量的值(gdb) info locals// 查看进程的内存映射信息(gdb)info proc mappings// 查看进程的内存信息，包括引用的动态链接库等(gdb)info files(gdb)info target// 打印静态变量, 可以显式地指定文件名(gdb) p &apos;static-1.c&apos;::var$1 = 1// 打印栈中的变量, 对于C++的函数名，需要使用单引号括起来(gdb) bt(gdb) p func2::b(gdb) p &apos;::namespace::Student&apos;::n-&gt;pi-&gt;dump()// 打印变量类型和变量所在文件(gdb) whatis vartype = struct child(gdb) ptype vartype = struct child &#123; char name[10]; enum &#123;boy, girl&#125; gender;&#125;(gdb) info variables var// 打印源代码行(gdb) list [N,M]// 每行只会显示结构体的一名成员(gdb) set print pretty on(gdb) p st// 打开一个新的终端, 指定输入输出设备(printf打印输出到这个终端)51_zjdev[/data01/zjgrp/zjdev]%tty/dev/pts/2(gdb) tty /dev/pts/2(gdb) r$ gdb -tty /dev/pts/2 ./a.out(gdb) r 多进程/线程123456// 只允许一个线程运行, 忘记的话help set(gdb) set scheduler-locking on// $_thread 打印线程号// $_exitcode 记录程序退出时的“exit code” 其他启动参数123456789// 启动前设置参数$ gdb -args ./a.out a b c// 启动前设置参数(gdb) set args a b c(gdb) show args// 运行时指定(gdb) r a b 记录调试过程1234// 默认的日志文件是“gdb.txt”(gdb) set logging file log.txt// 把执行gdb的过程记录下来(gdb) set logging on 缩写12345678910111213141516171819202122232425b -&gt; breakc -&gt; continued -&gt; deletef -&gt; framei -&gt; infoj -&gt; jumpl -&gt; listn -&gt; nextp -&gt; printr -&gt; runs -&gt; stepu -&gt; untilaw -&gt; awatchbt -&gt; backtracedir -&gt; directorydisas -&gt; disassemblefin -&gt; finishig -&gt; ignoreni -&gt; nextirw -&gt; rwatchsi -&gt; stepitb -&gt; tbreakwa -&gt; watchwin -&gt; winheight]]></content>
      <categories>
        <category>gdb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[费曼技巧]]></title>
    <url>%2F2019%2F10%2F08%2F%E8%B4%B9%E6%9B%BC%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一种学习方法, 更快地学习, 更好地理解 步骤 向不熟悉某议题的人解释该议题，用他们能理解的方式及最简单的语言向他们解释 发现自己不能理解的地方或不能简单解释某议题的地方并记录 回头查看资讯来源并研读自己薄弱的地方直到能用简单的语言来解释 为了讲解通俗易懂, 简化表达语言(直接表达) #]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CDN技术详解 笔记]]></title>
    <url>%2F2019%2F09%2F16%2FCDN%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[引言CDN基本概念, Content Distribute Network, 内容分发网络。产生背景, 为解决网络拥塞问题：第一公里/最后一公里/对等互联网关/长途骨干传输CDN的基本工作过程 CDN技术概述系统功能架构 系统部署架构 CDN系统分类 基于承载内容类型(网页/流媒体/文件/应用协议) 或 内容生成机制分类和分层加速服务 内容缓存工作原理及实现原理正向代理, Cache设备(proxy部署在内网中)为企业网的出口网关提供代理服务/内容缓存/Internet访问控制/安全认证等功能, 用户需要配置反向代理, Cache服务器(代理)和应用服务器部署在同一网络环境中, 有请求内容直接返回否则传给应用服务器透明代理, 通过路由设备WCCP协议把指定用户流量直接发送给Cache(部署在内网中), 实现了正向代理功能, 但用户不需要配置 Web Cache的技术本质是缓存 Web Cache基本实现Web架构三处技术精华：HTML/HTTP/URI HTTP-cookie: 保存在本地的服务器生成的用户ID文件HTTP-sesson: 通过服务器生成全局唯一的session ID来保持会话, 保存在服务器中两者差别可以从应用场景/安全性/性能/失效性等方面来说明 HTTPS 的安全基础是SSL, 采用对称加密和非对称加密结合的方式来进行通信对称加密：加密和解密都是同一个密匙非对称加密：密钥成对出现，分为公钥和私钥，公钥加密需要私钥解密，私钥加密需要公钥解密 HTTP协议中的缓存基本原则:响应消息头告诉缓存不要保留副本请求需要服务器认证或安全协议, 不缓存缓存内容已过期, 缓存服务器向源服务器确认是否可以使用当前副本直接提供服务在有些情况如与源服务器断开情况下, 过期副本直接提供服务响应消息不存在判断内容是否变化标记, 不缓存 Web Cache实现关键点分析性能指标：并发量/吞吐率/命中率/响应时间和丢包率内容存储机制：共享存储/本地附加存储(DAS)/分布式文件系统内容更新机制：有条件更新… Web Cache协议优化tcp长连接, gzip压缩 Web Cache安全实现机制访问控制(ACL)/病毒防护/网络安全防护/内容加密 开源软件Squid功能：Web代理/内容缓存与加速/ACL访问控制/用户认证/日志 集群服务与负载均衡技术服务器集群技术集群的分类: 可分为计算集群 和 负载均衡集群(CND节点) 、高可用集群集群的系统结构: 网络层, 操作系统层, 应用层, 集群管理系统层 Cache集群的交互方式 基于网络消息:ICP：一种轻量级的消息格式(基于UDP), 访问邻居Cache服务器, 确认请求资源十分在其他服务器上HTCP：管理一组HTTP Cache服务器并监控相关缓存活动, Web请求同ICP处理, 但后续请求可以精确应答Cache Digest: 解决上面两种协议网络延迟和拥塞问题, Web请求只要查询服务器上保存邻居缓存信息摘要Cache Pre-filling: 一种推送Cache内容的机制, 很好的应用的IP多播网络上 基于数据结构CARP: 分布式缓存协议, 为集群定义了一张Cache服务器成员列表, 分发消息的URL哈希函数 负载均衡技术 调度算法轮询/加权轮询/随机/加权随机/基于IP的Hash/基于IP端口的Hash/基于UDP报文Hash/最小连接/加权最小连接/最小响应时间 会话持续性保证技术基于IP地址的持续性, 确保每个请求都发送到同一台服务器, 第四层负载均衡基于cookie数据的持续性, 主要是插入和截取, 第七层负载均衡基于SIP报文Call-Id持续性, 确保相同IP报文都发送到同一台服务器, 第七层负载均衡基于HTTP报文头的持续性, 第七层负载均衡 服务器健康监测ICMP/TCP/HTTP/FTP/DNS… 负载均衡部署方式直接部署: in: client =&gt; LB =&gt; Server out: Server =&gt; LB =&gt; client旁挂部署: in: client =&gt; exchange =&gt; LB =&gt; Server out: Server =&gt; exchange =&gt; client 服务器负载均衡 L4 基于tcpudp/ip报文头部NAT: 网络地址转换, 将发送给虚拟IP的请求, 发送给具体服务器DR: Direct Routeing L7 基于整个报文 链路负载均衡为规避运营商网络出口故障, 解决网络带宽不足等问题根据业务流量方向分为InBound和OutBound 链路负载均衡, 前者用于外网访问内网, 后者用于内网访问外网 开源软件LVS/Nginx 全局负载均衡工作原理GSLB 在全网对各节点(设备)保持负载 基于DNS解析的GSLB DNS基本工作原理根DNS服务器, 顶级域名服务器, 权威DNS服务器共同组成了DNS服务器层, 共同维护分布式层次化的数据库本地DNS服务器：用户所在局域网或ISP网络中的域名服务器 DNS记录类型及报文格式 可以用nslookup工具查看 类型 原名 说明 A记录 Adress 域名到IP映射关系,可以有多条记录 NS记录 Name Server 域名服务器记录, 指定由哪个域名服务器来解析, 可以有多条记录 SOA记录 Start Of Authority 指定该区域的权威服务器, 只允许一条记录 CNAME记录 . 域名或主机的别名, 允许多个名字映射到一台计算机, 别名用来查询A记录 PTR记录 Pointer Record IP到域名的映射关系, 一个IP可以有多个域名 基于DNS解析的GSLB实现机制通过CNAME方式实现负载均衡, 返回排序的IP地址负载均衡器作为权威DNS服务器负载均衡器作为代理DNS服务器 负载均衡策略：服务器的健康状况/地理区域距离/会话保持/响应时间/IP地址权重/会话能力阀值/往返时间开源DNS软件: BIND 应用部署方式域组：由CNAME中的别名查询到多个服务池IP区域：用户本地DNS服务器代表的范围(联通, 电信)服务池: 虚拟服务器集合虚拟服务器：可以是四层交换设备进行负载均衡的一组服务器设备 负载均衡策略, 静态策略(基于IP地址/地理位置/POP节点/成本) , 动态策略(基于POP节点健康/会话能力/物理服务器绑定/流量) GSLB部署关键问题: 网站SP接入, 用户访问调度, 异常流程, 网络攻击 基于应用层协议重定向GSLB HTTP重定向原理 302 临时性转移 实现机制 基于IP路由的GSLB 思科LISP协议, 封装多个IP, 网络运营商需要硬件支持 流媒体CDN系统的组成和关键技术 流媒体系统工作原理 流媒体协议TRSP 远程播放控制, RTP用来提供时间信息和实现流同步, RTCP协助RTP完成质量传输控制,RTMP 和 HTTP Streaming 是企业自有流媒体协议RTP和RTCP RTSP应用层协议, 在RTP/TTCP之上, 像遥控器控制电视一样 RTMPflash流媒体 HTTP Streaming MPEG-2 TS 动态内容和加速服务实现CDN商业化服务现状CND发展展望]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lua应用]]></title>
    <url>%2F2019%2F09%2F06%2Flua%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基础全文基于lua5.1 栈Lua和C语言数据交换, 有两个问题, 动态和静态类型之间区别, 自动和手动内存管理的区别Lua设计了一个抽象的栈, 用于与其他语言数据交换, 栈中元素可以保存任何Lua类型的值 12345678910111213141516171819202122232425262728// 一个栈里可以有不同类型的值，通过数据结构TValue保存struct TValue&#123; Value value; // 值 int tt; // 值类型&#125;union Value&#123; GCObject* gc; // 存需要回收的值 void* p; // lua中的light userdata结构 lua_Number n; // 存int或float int b; // 存boolean&#125;// number, boolean, nil, light userdata 直接存，不需要回收// table, userdata、 函数、线程、和字符串 会自动回收union GCObject&#123; GCHeader gch; union TString ts; union UData u; union Clourse cl; struct Table h; struct Proto p; struct UpVal uv; struct lua_State th;&#125; CAPI lua.h 基础函数, lua_ 开头, Lua没有定义全局变量, lua_State 动态结构保持所有状态lauxlib.h 辅助函数 luaL_ 开头, 基于基础函数api, 侧重解决具体业务lualib.h 定义了标准库, 用户可以包含这个文件, 来统一openlibs, 如 luaL_openlibs 压栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 入栈, 常量nil, 布尔, 双精度浮点, 整数void lua_pushnil(lua_State* L); void lua_pushboolean(lua_State* L, int bool);void lua_pushnumber(lua_State* L, lua_Number n);void lua_pushinteger(lua_State* L, lua_Integer n);// 入栈 零结尾字符串, Lua 对这个字符串做一次内存拷贝（或是复用一个拷贝），函数返回后s可释放// 入栈 任意长度len字符串 void lua_pushstring (lua_State *L, const char *s);void lua_pushlstring(lua_State* L, const char* s, size_t len);void lua_push(lua_State* L, const char* s);// 将idx索引上的值的副本压入栈顶void lua_pushvalue(lua_State* L, int index); // 将一个 C 函数压入堆栈void lua_pushcfunction (lua_State *L, lua_CFunction f); typedef int (*lua_CFunction) (lua_State *L); // 把一个新的 C closure 压入堆栈// 与函数关联的值被叫做 upvalue， 在函数被调用的时候访问的到void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);// light userdata 表示一个指针，一个像数字一样的值，没有独立的 metatable ，而且也不会被回收void lua_pushlightuserdata (lua_State *L, void *p);// 把 L 中提供的线程压栈。如果这个线程是当前状态机的主线程的话，返回 1int lua_pushthread (lua_State *L);// 把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值， 而 k 则是栈顶放的值void lua_gettable (lua_State *L, int index);// 把 t[k] 值压入堆栈，这里的 t 是指有效索引 index 指向的值void lua_getfield (lua_State *L, int index, const char *k);// 把全局变量 name 里的值压入堆栈void lua_getglobal (lua_State *L, const char *name);#define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, s)// 把给定索引指向的值的元表压入堆栈// 如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西int lua_getmetatable (lua_State *L, int index);// 从栈上弹出一个 key（键）， 然后把索引指定的表中 key-value（健值）对压入堆栈// 如果表中以无更多元素， 那么 lua_next 将返回 0 （什么也不压入堆栈）int lua_next (lua_State *L, int index);// 典型用法遍历一张表 /* table 放在索引 't' 处 */ lua_pushnil(L); /* 第一个 key */ while (lua_next(L, t) != 0) &#123; /* 用一下 'key' （在索引 -2 处） 和 'value' （在索引 -1 处） */ printf("%s - %s\n", lua_typename(L, lua_type(L, -2)), lua_typename(L, lua_type(L, -1))); /* 移除 'value' ；保留 'key' 做下一次迭代 */ lua_pop(L, 1); &#125; 出栈12345678910111213141516171819202122232425262728293031323334353637// 从堆栈中弹出 n 个元素void lua_pop (lua_State *L, int n);// 返回栈中元素个数int lua_gettop(lua_State* L); // 从栈中弹出n个元素, 将栈顶设置到指定位置, 修改栈元素个数, 不足用nil补充, 多余的丢弃void lua_settop(lua_State* L, int index);#define lua_pop(L, n) lua_settop(L, -(n)-1) lua_settop(L, 0); // 特例清除栈// 作一个等价于 t[k] = v 的操作，这里 t 是一个给定有效索引index 处的值，// v 指栈顶的值，而 k 是栈顶之下的那个值, 从堆栈弹出k,vvoid lua_settable (lua_State *L, int index);// 等价于 t[k] = v 的操作，这里 t 是给出的有效索引index 处的值，而v 是栈顶的那个值。// 从堆栈弹出栈顶值vvoid lua_setfield (lua_State *L, int index, const char *k);// 从堆栈上弹出一个值，并将其设到全局变量 name 中void lua_setglobal (lua_State *L, const char *name); #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, s)// 把一个 table 弹出堆栈，并将其设为给定索引处的值的 metatableint lua_setmetatable (lua_State *L, int index);// Lua 中数字的类型。确省是 double ，但是你可以在 luaconf.h 中修改它。typedef double lua_Number;// 从栈中获取一个值int lua_toboolean(lua_State* L, int index);lua_Number lua_tonumber(lua_State* L, int index);lua_Integer lua_tointeger(lua_State* L, int index);const char* lua_tolstring(lua_State* L, int index, size_t *len);// 返回指定的索引处的值的长度size_t lua_objlen(lua_State* L, int index); 数组1234// 把 t[n] 的值压栈， 这里的 t 是指给定索引 index 处的一个值。它不会触发元方法。void lua_rawgeti (lua_State *L, int index, int n);// 等价于 t[n] = v， 这里的 t 是指给定索引 index 处的一个值， 而 v 是栈顶的值。不会触发元方法void lua_rawseti (lua_State *L, int index, int n); 检查1234567891011121314151617181920212223// 确保堆栈上至少有 extra 个空位// 如果不能把堆栈扩展到相应的尺寸，函数返回 false// 这个函数永远不会缩小堆栈； 如果堆栈已经比需要的大了，那么就放在那里不会产生变化int lua_checkstack (lua_State *L, int extra);// 返回给定索引处的值的类型// LUA_TNIL, LUA_TBOOLEAN, LUA_TNUMBER, LUA_TSTRING, LUA_TTHREAD, LUA_TUSERDATA, LUA_TFUNCTIONint lua_type (lua_State *L, int index);// 返回 tp 表示的类型名const char *lua_typename (lua_State *L, int tp);int lua_iscfunction (lua_State *L, int index);int lua_isfunction (lua_State *L, int index);int lua_islightuserdata (lua_State *L, int index);int lua_isnil (lua_State *L, int index);int lua_isnumber (lua_State *L, int index);int lua_isstring (lua_State *L, int index);int lua_istable (lua_State *L, int index);int lua_isthread (lua_State *L, int index);int lua_isuserdata (lua_State *L, int index);int lua_lessthan (lua_State *L, int index1, int index2);// 查询元素, 索引:1 入栈第一个元素, 2 入栈第二个元素; -1 栈顶元素, -2 int lua_is(lua_State* L, int index); 1234void lua_remove(lua_State* L, int index);void lua_insert(lua_State* L, int index);void lua_replace(lua_State* L, int index); 创建12345678910111213141516171819// 创建新的状态机;参数 f 是一个分配器函数;第二个参数 ud ，这个指针将在每次调用分配器时被直接传入lua_State *lua_newstate (lua_Alloc f, void *ud);// 创建一个空 table ，并将之压入堆栈void lua_newtable (lua_State *L);lua_newtable(L);//要给lua脚本返回一个table类型，先要new一个，压入栈顶lua_pushnumber(L, 1); //将key先压入栈lua_pushstring(L, "table2lua"); //再将value压入栈lua_settable(L, -3);//settable将操作-2，-1编号的键值对设置到table中，并把key-value从栈中移除// 创建一个新线程，并将其压入堆栈，并返回维护这个线程的 lua_State 指针// 这个函数返回的新状态机共享原有状态机中的所有对象（比如一些 table），但是它有独立的执行堆栈// 没有显式的函数可以用来关闭或销毁掉一个线程，靠垃圾回收lua_State *lua_newthread (lua_State *L);// 分配一块指定大小的内存块，把内存块地址作为一个完整的 userdata 压入堆栈，并返回这个地址// 有着自己的元表，而且它在被GC回收时，可以被监测到void *lua_newuserdata (lua_State *L, size_t size); 函数注册123456// 把 C 函数 f 设到全局变量 name 中void lua_register (lua_State *L, const char *name, lua_CFunction f);#define lua_register(L,n,f) \ (lua_pushcfunction(L, f), lua_setglobal(L, n)) 函数调用1234567891011121314151617181920212223242526272829void lua_call (lua_State *L, int nargs, int nresults);// case lua_getfield(L, LUA_GLOBALSINDEX, "f"); /* 将调用的函数 */ lua_pushstring(L, "how"); /* 第一个参数 */ lua_getfield(L, LUA_GLOBALSINDEX, "t"); /* table 的索引 */ lua_getfield(L, -1, "x"); /* 压入 t.x 的值（第 2 个参数）*/ lua_remove(L, -2); /* 从堆栈中移去 't' */ lua_pushinteger(L, 14); /* 第 3 个参数 */ lua_call(L, 3, 1); /* 调用 'f'，传入 3 个参数，并索取 1 个返回值 */ lua_setfield(L, LUA_GLOBALSINDEX, "a"); /* 设置全局变量 'a' */lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);// lua_CFunction static int foo (lua_State *L) &#123; int n = lua_gettop(L); /* 参数的个数 */ lua_Number sum = 0; int i; for (i = 1; i &lt;= n; i++) &#123; if (!lua_isnumber(L, i)) &#123; lua_pushstring(L, "incorrect argument"); lua_error(L); &#125; sum += lua_tonumber(L, i); /* 取值 */ &#125; lua_pushnumber(L, sum/n); /* 第一个返回值 */ lua_pushnumber(L, sum); /* 第二个返回值 */ return 2; /* 返回值的个数 */ &#125; 应用C调用lua文件中的变量/函数点击显代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// lua文件width = 30height = 80// c应用void load(lua_State* L, int* w, int* h)&#123; if(luaL_loadfile(L, fname) || lua_pcall(L, 0, 0, 0)) error(L, "cannot run config file %s", lua_tostring(L, 0)); lua_getglobal(L, "width"); lua_getglobal(L, "height"); *w = lua_tointeger(L, -2); *h = lua_tointeger(L, -1);&#125;// table, 获取全局变量backgroud, 确认类型, get_field获取值backgroud = &#123;r=1, g=2, b=3&#125; if(luaL_loadfile(L, fname) || lua_pcall(L, 0, 0, 0)) error(L, "cannot run config file %s", lua_tostring(L, 0)); lua_getglobal(L, backgroud); if(!lua_istable(L, -1)) error(L, " is not a table"); red = getfield(L, "r") ... // c 调用lua函数function f (x, y) return x*y;endvoid f(int x, int y)&#123; // 压入函数和参数 lua_getglobal(L, f); lua_pushinteger(L, 1); lua_pushinteger(L, 20); // 调用lua函数 if(lua_pcall(L, 2, 1, 0) != 0) error(...) // 检查结果 if(lua_isinteger(L, -1) == 0) int z = lua_tointeger(L, -1); else return -1; // 清除结果 lua_pop(L, -1); return z;&#125; Lua调用C函数点击显代码 1234567891011121314151617181920212223242526// 定义c函数static int l_sin(lua_State* L)&#123; double d = luaL_checknumber(L, 1); lua_pushnumber(L, sin(d)); return 1;&#125;// lua调用lua_pushfunction(L, l_sin);lua_setglobal(L, "mysin");// 获取目录路径static int l_dir(lua_State* L)&#123; ... lua_newtable(L); int i=1; while((entry = readdir(dir)) != NULL) &#123; lua_pushnumber(L, i++); // 压入KEY lua_pushstring(L, entry-&gt;dname); // 压入value lua_settable(L, -3); &#125; ...&#125; Lua调用C模块点击显代码 123456789101112131415161718192021// 1. 定义C模块函数static int l_dir(lua_State* L)&#123;...&#125;// 2. 声明数组, 包含字符串名称和函数指针static const struct LuaL_Reg mylib[] = &#123; &#123;"dir", l_dir&#125;, &#123;NULL, NULL&#125;&#125;// 3. 声明一个主函数int luaopen_mylib()&#123; luaL_register(L, mylib); return 1;&#125;// 4. lua调用so 或 重新编译添加到标准库列表中打开require "mylib"luaL_openlibs 打开标准库列表(linit.c) 编写C函数技巧数组/字符串操作点击显代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 数组操作, index 表示 table 在栈里的位置, key 表示元素在table中的位置(从1开始)// 取值, stack[index][key]void lua_rawgeti(lua_State* L, int index, int key);// 赋值, 将栈顶的值赋值到 stack[index][key]void lua_rawseti(lua_State* L, int index, int key);-- 定义一个全局tableLanguagesTable = &#123; &quot;lua&quot;, &quot;c&quot;, &quot;c++&quot;, &quot;java&quot;, &quot;python&quot;,&#125;//-- 定义一个打印函数function func_printarray() print(&quot;\n&quot;); for index,value in pairs(LanguagesTable) do print(&quot;[&quot;..index..&quot;] = &quot;.. value); endend//-- c++代码lua_State *L = lua_open();luaL_openlibs(L);luaL_dofile(L,&quot;rawgetitest.lua&quot;); // 加载执行lua文件lua_getglobal(L,&quot;LanguagesTable&quot;); // 将全局表压入栈lua_rawgeti(L, -1, 2); // 取LanguagesTable[2]的值, -1 是栈中位置if(lua_isnil(L, -1))&#123; printf(&quot;c++ --&gt; [2] = nil\n&quot;);&#125;else&#123; printf(&quot;c++ --&gt; [2] = %s\n&quot;, lua_tostring(L, -1)); // 输出 c&#125;lua_pop(L,1); // 弹出栈顶变量lua_getglobal(L, &quot;func_printarray&quot;);// 改变之前先调用打印函数，查看原数组lua_pcall(L, 0, 0, 0); // 输出 LanguagesTable 一共5个元素lua_pushstring(L, &quot;php&quot;); // 将要赋值的结果压入栈lua_rawseti(L, -2, 4); // 赋值操作, -2是table在栈中位置lua_pushstring(L, &quot;swift&quot;); // 将要赋值的结果压入栈lua_rawseti(L, -2, 8); // 赋值操作, -2是table在栈中位置lua_getglobal(L, &quot;func_printarray&quot;);// 改变之后再调用打印函数，查看改变后的结果lua_pcall(L, 0, 0, 0); // LanguagesTable[4] = php, LanguagesTable[8] = swift, 一共6个元素lua_close(L); //关闭lua环境 // ------------------------------// 把s[i, j]子串传递给lualua_pushlstring(L, s+i, j-i+1); 在C函数中保存状态C API提供3中方式：注册表(全局table, 多个模块共享), 环境(模块私有数据), upvalue(在特定函数中可见) 注册表1234567891011121314151617181920// 获取全局变量lua_getfield(L, LUA_REGISTRINDEX, &quot;KEY&quot;);// 创建一个唯一的key, 取值int r = luaL_ref(L, LUA_REGISTRINDEX);lua_rawgeti(L, LUA_REGISTRINDEX, r);// 释放引用和该值luaL_unref(L, LUA_REGISTRINDEX);// 保存字符串static char KEY = &apos;key&apos;lua_pushlightuserdata(L, (void*)&amp;KEY);lua_pushstring(L, myStr);lua_settable(L, LUA_REGISTRINDEX);// 检索一个字符串lua_pushlightuserdata(L, (void*)&amp;KEY);lua_gettable(L, LUA_REGISTRINDEX);myStr = lua_tostring(L, -1); 环境在本模块中可见12345&#123; lua_newtable(L); lua_replace(L, LUA_ENVIRONINDEX); luaL_register(L, &quot;name&quot;, tab); // 创建一个name的table, 用tab去填充&#125; upvalue相当于一个静态变量, 在一个特性函数中可见12 用户自定义类型参考 userdata123456789// 申请指定大小内存, 压栈, 返回内存地址void* lua_newuserdata(lua_State* L, size_t size);CUser* p = (CUser*)lua_touserdata(L, 1);// 检查 cond 是否为真。如果不为真，以标准信息形式抛出一个错误void luaL_argcheck (lua_State *L, int cond, int arg, const char *extramsg); 元素怎么确第一个参数就是我们想要的数组userdata, 不是其他的userdata?用名称来标记123456789101112131415// 如果registry已经有tnme键值，则函数返回0; 否则创建一个[tname, metatable]，并放入registry，并返回1。int luaL_newmetatable (lua_State *L, const char *tname);// 获取registry中的tname对应的metatable，并入栈int luaL_getmetatable (lua_State *L, const char *tname);// 将栈顶对象的metatable设置为registry表中键tname对应的值void luaL_setmetatable (lua_State *L, const char *tname);// 检查栈的指定位置是否为元表，并且是否具有和指定名称相匹配的表void* luaL_checkudata(lua_State*L,int index,const char*tname);// 注意区分void lua_setmetatable (lua_State *L, int index);int lua_getmetatable (lua_State *L, int index); 轻量级用户管理内存, 保持指针void lua_pushlightuserdata(lua_State L, void p); 多线程多线程的目的是为了协同程序, 挂起某些程序的执行, 并在稍后恢复。从C API角度看, 一个线程一个栈;只要创建一个Lua状态, 就会自动在这个状态中创建一个线程。 12345678910111213141516// L1 以一个空栈进行运行, L 的栈顶就是这个新线程lua_State* L1 = lua_newstate(L);printf(&quot;%d\n&quot;, lua_gettop(L1)); --&gt; 0printf(&quot;%d\n&quot;, lua_typename(L)); --&gt; thread// L1 会被垃圾回收lua_pop(L1); // 执行函数或在lua_yield后恢复lua_resume(lua_State* L, int narg);// 挂起lua调用成, 也就是C程序lua_yield(L, nres);// 线程之间数据交换lua_pushstring(L2, lua_tostring(L1, 1)); 内存管理垃圾回收，原子操作]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git操作命令]]></title>
    <url>%2F2019%2F08%2F14%2Fgit%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[沉浸式学习Git参考地址 创建仓库git clone [url] [dir]git init git@github.com:bzadhere/myim.git ssh协议https://github.com/bzadhere/myim.git https协议 git生成SSH公钥~/.ssh 目录下有公钥, 或ssh-keygen创建, 生成公钥id_rsa.pub和私钥id_rsa 12345$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;// github上，进入 Account Settings（账户配置），左边选择SSH Keys， // Add SSH Key,title随便填，粘贴在你电脑上生成的key$ ssh -T git@github.comHi xxxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 基本概念 working tree: 能看到的目录 HEAD: 是当前分支引用的指针，它总是指向该分支上的最后一次提交(commit) Index: 索引是你的“预期的下一次提交”–“暂存区域”，运行git add后，代码就进入“暂存区域” git add 索引就记录git commit 暂存区目录树写到对象库中, master分支相应更新。master指向的目录树就是提交时暂存区的目录树git reset HEAD 暂存区的目录树会被重写, 被 master 分支指向的目录树所替换, 但是工作区不受影响git rm –cached 从暂存区删文件, 工作区不变git checkout HEAD(.) 或git checkout HEAD 会用 HEAD 指向的分支中的全部或部分文件替换暂存区和以及工作区中的文件 配置说明依次加载配置, 变量依次覆盖/etc/gitconfig git config –system~/.gitconfig git config –global.git/config git config –list 一般就用这个 12345678910111213141516[imdev@localhost .git]$ cat config[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true quotepath=false #避免中文文件名显示乱码[remote &quot;origin&quot;] url = git@github.com:bzadhere/myim.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[user] name = bzadhere email = bzadhere@gmail.com 别名12345git config --global alias.st status;git config --global alias.ci commit;git config --global alias.co checkout;git config --global alias.br branch;git config --global alias.last &apos;log -1 HEAD&apos;; 分支操作123456789101112# 创建分支git branch (branchname)# 切换分支git checkout (branchname)# 列出分支git branch# 创建并切换到该分支git checkout -b (branchname)# 删除分支git branch -d (branchname)# 合并指定分支到当前分支git merge &lt;branchname&gt; 标签1234567891011# 查看标签git tag# 添加标签git tag -a v1.0# 指定版本添加标签git tag -a v1.0 c3d2d07// 删除git tag -d v1.0// 标签传送到远端服务器上git push &lt;remote&gt; [tagname]git push &lt;remote&gt; --tags 查看日志和文件状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 查看那些文件修改了$ git status -s# 查看帮助[imdev@localhost ~/myim]$ git help log# 查看修改日志[imdev@localhost ~/myim]$ git logcommit 6ee178bf83f1996568401cfb23411b3c046922e7Merge: ebe63a1 c3d2d07Author: bzadhere &lt;bzadhere@gmail.com&gt;Date: Mon Aug 19 23:22:30 2019 -0400 Merge branch &apos;tmpim&apos; Conflicts: test.txtcommit c3d2d07be4add9fb1eba57b49fc3fe0202615dc3Author: bzadhere &lt;bzadhere@gmail.com&gt;Date: Mon Aug 19 23:20:10 2019 -0400 modify from tmpimcommit ebe63a1782656804e002a35ec372195ba72ebdfdAuthor: bzadhere &lt;bzadhere@gmail.com&gt;Date: Mon Aug 19 23:17:07 2019 -0400 modify from master......# 简洁版本--oneline, 分支合并--graph[imdev@localhost ~/myim]$ git log --oneline --graph* 6ee178b Merge branch &apos;tmpim&apos;|\ | * c3d2d07 modify from tmpim* | ebe63a1 modify from master|/ * 5b824c1 add test.txt* 7706505 add dir* 7d4976b add dir* 8782412 add file# --reverse 逆向, --author=zhangbb 指定用户, --no-merges 隐藏合并提交# --before=&#123;1.weeks.ago&#125; 一周前, --after=&#123;2010-04-18&#125;, 4.18号之后; --since, --util# 分支还没合并进主干的修改git log master..branch 远程仓库12345678910// 查看当前的远程仓库git remote -v// 查看远程仓库版本库信息git remote show [shortname]// shortname 别名git remote add [shortname] [url]// 重命名git remote rename old new// 删除git remote rm [shortname] 修改提交1234567891011121314151617181920212223242526272829303132333435363738394041424344// 文件改名git mv &lt;old&gt; &lt;new&gt;// 彻底删除文件, 包括工作区和暂存区git rm &lt;file&gt;// 暂存区和上一个版本差异git diff --stage// 比较指定版本差异git diff (id1) (id2) --binary --(path) &gt; 目标文件路径// 增加全部文件 或 指定文件夹git add .git add --allgit add &lt;dir&gt;// 提交指定文件或多个文件git commit &lt;file&gt; -m &quot;comment&quot;// 提交了所有 暂存区 的文件git commit -m &quot;commit&quot;// 提交分别来自不同地方的文件，比如 工作区的 和 暂存区的git commit -o a.txt b.txt -m &quot;comment&quot;// 忽略文件或文件夹，在项目根目录下面 添加 .gitignore文件 // 只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的vim .gitignore# 忽略*.o和*.a文件 *.[oa]# 忽略*.b和*.B文件，my.b除外*.[bB]!my.b# 忽略dbg文件和dbg目录dbg# 只忽略dbg目录，不忽略dbg文件dbg/# 只忽略dbg文件，不忽略dbg目录dbg!dbg/# 忽略.gitignore本身!.gitignore# 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内/dbg# 以&apos;#&apos;开始的行，被视为注释. * ？：代表任意的一个字符 * ＊：代表任意数目的字符 * &#123;!ab&#125;：必须不是此类型 * &#123;ab,bb,cx&#125;：代表ab,bb,cx中任一类型即可 * [abc]：代表a,b,c中任一字符即可 * [ ^abc]：代表必须不是a,b,c中任一字符 版本合并(更新)123456789101112131415161718192021222324// 下载更新到本地git fetch [remote-name]// 合并到任意分支git merge [shortname]// 推送本地数据到远程仓库, 如果从分支push 会产生合并请求git push [remote-name] [branch-name]// 从远程仓库更新合并到本地git pull [remote-name] [branch-name]// 合并一个分支上改动的部分文件到mastergit checkeout mastergit checkeout --path branch file// 签出指定文件git checkout [&lt;options&gt;] [&lt;branch&gt;] -- &lt;file&gt;// 从上一次提交中签出指定文件git checkout -- a.txt// 从指定的提交历史中签出指定文件git checkout 830cf95f56ef9a7d6838f6894796dac8385643b7 -- a.txt// 从其他分支签出指定文件git checkout master -- a.txt// 签出某个后缀的文件 或 指定目录git checkout -- *.txtgit checkout -- css/ 回退commit最后三个版本 HEAD~3包含(HEAD, HEAD^, HEAD~2) 123456789101112131415161718192021222324252627// 本地进行了多次git commit操作，现在想撤销到其中某次Commit// soft 回退到某个版本，只回退了commit的信息，不会恢复到index file一级// mixed 此为默认方式, 回退到某个版本，只保留源码，回退commit和index信息// hard 彻底回退到某个版本，本地的源码也会变为上一个版本的内容git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]// 回退到指定版本git reset --hard 406b5944e3// 文件被修改了，但未执行git add操作(working tree内撤销) git checkout fileName git checkout .// 同时对多个文件执行了git add操作，但本次只想提交其中一部分文件git add *git statusgit reset HEAD &lt;filename&gt; # 取消暂存// 文件执行了git add操作，但想撤销对其的修改（index内回滚）git reset HEAD fileName # 取消暂存git checkout fileName # 撤销修改// 修改的文件已被git commit，但想再次修改不再产生新的Commitgit add sample.txtgit commit --amend -m &quot;说明&quot; # 修改最后一次提交 // 修改最近三次提交信息, 删除某次提交, 编辑删除即可git rebase -i HEAD~3 已经git push推送到远程仓库中12345678910111213141516171819// 若有taggit checkout &lt;tag&gt;// 回到当前HEAD指向git checkout &lt;branch_name&gt;// 撤销指定文件到指定版本git log &lt;filename&gt; git checkout &lt;commitID&gt; &lt;filename&gt; # 回滚到指定commitID// 删除最后一次远程提交git revert HEAD # 放弃指定提交的修改，生成一次新的提交, 以前的历史记录都在git push origin mastergit reset --hard HEAD^ # 将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录git push origin master -f # -f 将旧版本强制推送更新到远程仓库// 回滚某次提交git revert commitID 保存修改123456789101112131415161718// 暂存修改, 工作目录恢复到修改前, save [message]$ git stash// 查看暂存修改git stash list// 查看最近一个修改的diff, git stash show// 取出和删除指定修改git stash apply stash@&#123;2&#125;git stash drop stash@&#123;2&#125;// 取出最近一个修改git stash apply// 取出并删除最近一个修改git stash pop// 从暂存区创建一个分支$ git stash branch testchanges// 删除全部stashgit stash clear 命令总结官方地址 练习12345671. 配置2. 创建分支，切换3. 文件修改，状态查看，日志查看(指定时间条件)，提交(批量或单个), 忽略文件或文件夹，回退4. 同步分支，合并，冲突解决，撤销，更新某些指定文件5. 暂存当前工作6. 推送到远程仓库，同步远程仓库到本地7. 文档查看, git cmd --help 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162git initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@*************.gitgit push -u origin master# tmpim分支创建切换[imdev@localhost ~/myim]$ git branch* master[imdev@localhost ~/myim]$ git branch tmpim[imdev@localhost ~/myim]$ git checkout tmpimSwitched to branch &apos;tmpim&apos;[imdev@localhost ~/myim]$ git branch master* tmpim# master 合并 tmpim修改[imdev@localhost ~/myim]$ echo &quot;hello world!&quot; &gt; test.txt[imdev@localhost ~/myim]$ lsob_rel Readme source test.txt[imdev@localhost ~/myim]$ git add test.txt [imdev@localhost ~/myim]$ git commit test.txt -m &apos;add test.txt&apos;[tmpim 5b824c1] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt[imdev@localhost ~/myim]$ git checkout masterSwitched to branch &apos;master&apos;[imdev@localhost ~/myim]$ lsob_rel Readme source[imdev@localhost ~/myim]$ git merge tmpimUpdating 7706505..5b824c1Fast-forward test.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 test.txt[imdev@localhost ~/myim]$ lsob_rel Readme source test.txt# 分支合并冲突[imdev@localhost ~/myim]$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)[imdev@localhost ~/myim]$ git merge tmpimAuto-merging test.txtCONFLICT (content): Merge conflict in test.txtAutomatic merge failed; fix conflicts and then commit the result.[imdev@localhost ~/myim]$ cat test.txt hello world!&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADby zhangbb=======by tmpim&gt;&gt;&gt;&gt;&gt;&gt;&gt; tmpim[imdev@localhost ~/myim]$ vi test.txt .......[imdev@localhost ~/myim]$ git status -sUU test.txt[imdev@localhost ~/myim]$ git add test.txt [imdev@localhost ~/myim]$ git status -sM test.txt[imdev@localhost ~/myim]$ git commit]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[散列和跳表]]></title>
    <url>%2F2019%2F08%2F08%2F%E6%95%A3%E5%88%97%E5%92%8C%E8%B7%B3%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[字典： dictionary, 有限元素集合, key+value 线性表描述: template class SortedChain { public: SortedChain(){ first = 0; } ~SortedChain(); bool isEmpty() { return first == 0 ? true : false; } int Length(); bool Search(); SortedChain&lt;E, K&gt;&amp; Delete(const K&amp; k, E&amp; e); SortedChain&lt;E, K&gt;&amp; Insert(const E&amp; e); SortedChain&lt;E, K&gt;&amp; DistincsInsert(); private: SortedChainNode&lt;E, K&gt;* first; } 跳表描述： 特征： 1) 一个跳表有几个层组成 2) 跳表第一层包含所有元素 3) 每一层都是有序链表 http://www.cppblog.com/mysileng/archive/2013/04/06/199159.html 散列描述：]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树和其他树]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%85%B6%E4%BB%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树 概念 描述 树的定义 tree 是一个有限非空集合, 其中一个元素为根(root), 余下的元素组成t的子树 树的叶子 没有孩子的节点称为叶子 树的层级 level 根的级为1, 孩子的级为2 树的高度 叶节点的深度, 根节点的高度为0 元素的度 degree of element 孩子的个数, 叶子节点的度为0 二叉树二叉树及其表示二叉树的定义: tree 是一个有限非空集合; 根元素 + 2个二叉树组成, 分别称为t的左子树和右子树 有序二叉树: 节点的度数均不超过2个 满二叉树: 有2^h-1个元素 完全二叉树: 从满二叉树中删除k个元素, 称为完全二叉树, 满二叉树是完全二叉树的一个特例 特点： 每个元素有两棵子树 每个元素的子树都是有序的，可以用左右来区分 特性： 1. 包含n(n&gt;0)个元素的二叉树边数为n-1 2. 若二叉树的高度或深度(层数)h, h&gt;=0, 则该二叉树至少有h个元素, 最多有2^h-1个元素(满二叉树) 3. 包含n个元素的二叉树最大高度为n, 最小为log2^(n+1) 4. 设完全二叉树中一元素序号为i, 1&lt;=i&lt;=n, 则有以下关系: 1) 当i=1时, 该元素为二叉树的根; 若i&gt;1, 则该元素的父节点编号i/2 2) 当2i&gt;n时, 该元素无左孩子; 否则其左孩子编号为2i 3) 当2i+1&gt;n时, 该元素无右孩子; 否则该右孩子编号为2i+1 编码树PFC编码树, 每个字符对应叶子节点, 顺序？ 二叉树的实现二叉树的遍历Huffman 编码公式化描述: 按层级的数组 链表描述:template class BinaryTreeNode{public: Visit(BinaryTreeNode ); void PreOrder(BinaryTreeNode ); void InOrder(BinaryTreeNode ); void PostOrder(BinaryTreeNode ); void LevelOrder(BinaryTreeNode* ); public: BinaryTreeNode(){} BinaryTreeNode(const T&amp; e) { data = e; } BinaryTreeNode(const T&amp;e, BinaryTreeNode l, BinaryTreeNode r) { }private: T data; BinaryTreeNode liftChild = 0; BinaryTreeNode rightChild = 0;} 遍历:void PreOrder(BinaryTreeNode* t){ if(t) { Visit(t); PreOrder(t-&gt;leftChild); PreOrder(t-&gt;rightChild); }} void InOrder(BinaryTreeNode* t){ if(t) { InOrder(t-&gt;leftChild); Visit(t); InOrder(t-&gt;rightChild); }} void PostOrder(BinaryTreeNode* t){ if(t) { PostOrder(t-&gt;leftChild); PostOrder(t-&gt;rightChild); Visit(t); }} void LevelOrder(BinaryTreeNode t){ LinkedQueue&lt;BinaryTreeNode&gt; list; while(t) { Visit(t); list.add(t-&gt;leftChild); list.add(t-&gt;rightChild); list.delete(t); // vector erase // return; }} 类BinaryTreetemplate class BinaryTree{public: BinaryTree(){root = 0;} ~BinaryTree(){} bool IsEmpty(){ return root ? true : false; } bool RootValue(T&amp; x); void MakeTree(T&amp; e, BinaryTree&amp; leftTree, BinaryTree&amp; rightTree); void BreakTree(T&amp; e, BinaryTree&amp; leftTree, BinaryTree&amp; rightTree); void PreOrder(void (*Visit)(BinaryTreeNode&lt;T&gt;* u)) { PreOrder(Visit, root); } void InOrder(void (*Visit)(BinaryTreeNode&lt;T&gt;* u)) { InOrder(Visit, root); } void PostOrder(void (*Visit)(BinaryTreeNode&lt;T&gt;* u)) { PostOrder(Visit, root); } void LevelOrder(void (*Visit)(BinaryTreeNode&lt;T&gt;* u)) { LevelOrder(Visit, root); } private: BinaryTreeNode* root;} bool RootValue(T&amp; x){ if(root) { x = root-&gt;data; return true; } else { return false; }}]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chrome小技巧]]></title>
    <url>%2F2019%2F07%2F31%2Fchrome%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[全屏截图F12打开开发工具栏, Ctl+Shift+P调出查找界面栏, 输入命令full回车截图并自动下载(或者capture选择截图模式)]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[STL源码解析-笔记]]></title>
    <url>%2F2019%2F07%2F18%2FSTL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[STL概述与版本STL六大组件, 容器/算法/迭代器/仿函数/配接器(adapters)/配置器(alloctors) 令人困惑的语法临时对象产生和应用for_each(begin, end, Print()) 静态常量在class里直接初始化1234567template&lt;class T&gt;calss Test&#123;public: static const int a = 1; static const char b = &apos;c&apos;;&#125; 操作符++/–/*123456789101112131415161718192021222324252627282930class Int&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Int&amp; i); // prefix, same as operator-- Int&amp; operator++() &#123; ++(this-&gt;m_i); return *this; &#125; // postfix, same as operator-- const Int operator++(int) &#123; Int tmp = *this; ++(*this); return tmp; &#125; // dereference int&amp; operator*() const &#123; return (int&amp;)m_i; &#125; private: int m_i;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; os, const Int&amp; i)&#123; os &lt;&lt; &apos;[&apos; &lt;&lt; i &lt;&lt; &apos;]&apos;; return os;&#125; 前闭后开操作符operator()1234567891011121314151617template&lt;class T&gt;class Plus&#123; T operator(const T&amp; t1, const T&amp; t2) &#123; return t1+t2; &#125;&#125;;int main()&#123; Plus&lt;int&gt; obj; // 使用仿函数, 和普通函数一样 cout&lt;&lt; obj(3,4) &lt;&lt; endl; // 直接使用仿函数使用的临时对象, 并调用 cout&lt;&lt; Plus&lt;int&gt;()(3,4) &lt;&lt; endl;&#125; 源码获取解压后在 gcc-5-20171003\libstdc++-v3\include\bits 目录 空间配置器文件清单stl_construct.h 定义构造析构stl_uninitalize.h 定义内存拷贝和填充allocate.h 定义内存分配器 模板分析变长参数模板接受零个或多个模板实参的模板形参1234template&lt;typename _T1, typename... _Args&gt;inline void_Construct(_T1* __p, _Args&amp;&amp;... __args)&#123; ::new(static_cast&lt;void*&gt;(__p)) _T1(std::forward&lt;_Args&gt;(__args)...); &#125; 类设计12345678910111213141516171819202122232425template&lt;class T&gt;class Alloc&#123;public: typedef size_t size_type; typedef T* pointer; typedef const T* const_pointer; typedef T&amp; reference; typedef const T&amp; const_reference; typedef T value_type; // 内嵌类 template&lt;class T1&gt; struct rebind &#123;typedef Alloc&lt;T1&gt; other;&#125;; Alloc()throw() &#123; &#125; Alloc(Alloc&amp; rh); ~Alloc(); void allocate(); // 内存分配 void deallocate(); // 内存释放 void construct(); // 对象构造 void destory(); // 对象析构&#125;; 设计思路 向 heap 申请空间考虑多线程状态内存不足时应变处理内存碎片(小的用memory pool, 大于128 bytes 才用malloc ) allocateallocate申请内存大于128 byte 时, 直接用new(malloc)分配申请内存小于128 byte 时, _M_get_free_list 从空闲链表中取一块分配, 内存池由16个不同大小的链表数组(8的倍, 8~128 byte) 取到的链表头头为空, _M_refill 初始化内存池返回可用地址, _M_round_up 规整成8的整数倍_M_allocate_chunk 申请固定内存块, 大小为 (2*20*(n*sizeof(Tp))+ heap_size&gt;&gt;4), 返回空闲起始地址重新调用_M_get_free_list(n*sizeof(Tp))再将整个chunk中剩下的nobj-1个内存块串联起来构成一个空闲列表, 根据size获取链表数组下标返回地址 例子, _M_allocate_chunk(32, 20), 申请分配了40个32 byte块, free_list[3] 第一个交给调用者, 19个给 free_list, 余下给内存池;若接下来调用 _M_allocate_chunk(64, 20) 只够10个, 一个交给调用者, 19个交给free_list[7];再来调用 _M_allocate_chunk(96, 20) 则重新申请 40+n(附加量)个96 byte块……如果heap 都没有, 从free_list 挖出一块交出, 找不到就交给malloc deallocate回收也是重新放入free_list 迭代器设计思路思路就是迭代器设计模式, 迭代器是一种智能指针 迭代器类型Traits 编程技法12345678910111213template &lt;class T&gt;struct MyInter&#123; typedef T value_type; ......&#125;;template &lt;class I&gt;typename I::value_type // 返回值类型, typename告诉编译器这是一个类型func(I ite)&#123; return *ite;&#125; 参数偏特化是指对template参数更进一步的条件限制12345678910111213141516171819202122232425template &lt;class I&gt;struct iterator_traits&#123; typedef typename I::value_type value_type;&#125;template &lt;class I&gt;typename iterator_traits&lt;I&gt;::value_type // 返回值类型, typename告诉编译器这是一个类型func(I ite)&#123; return *ite;&#125;template &lt;class T&gt;struct iterator_traits&#123; typedef typename I::value_type value_type;&#125;// 多这一层的好处是可以特化，支持原生指针template &lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; typedef T value_type;&#125; ## ## 序列容器关联容器算法仿函数配接器]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++指针详解]]></title>
    <url>%2F2019%2F07%2F17%2Fc-%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是指针指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址 12345678910111213141516171819#include &lt;iostream&gt;using namespace std; int main ()&#123; int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在指针变量中存储 var 的地址 // 输出在指针变量中存储的地址 cout &lt;&lt; &quot;Address stored in ip variable: &quot;; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; &quot;Value of *ip variable: &quot;; cout &lt;&lt; *ip &lt;&lt; endl; return 0;&#125; 指针数组1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;const int MAX = 3; int main ()&#123; int var[MAX] = &#123;10, 100, 200&#125;; int *ptr[MAX]; for (int i = 0; i &lt; MAX; i++) &#123; ptr[i] = &amp;var[i]; // 赋值为整数的地址 &#125; for (int i = 0; i &lt; MAX; i++) &#123; cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; *ptr[i] &lt;&lt; endl; &#125; return 0;&#125; 多级指针 1234567891011// 值传递 因为有临时拷贝void getMemory(char** p, int num)&#123; *p = (char*)malloc(num);&#125;// 引用传递 直接使用void lookup_AdjDetail(int key, const CAdjDetail*&amp; pVal)&#123; pVal = new CAdjDetail();&#125; 二维数据指针1234567891011121314int rowsNum = 2;int colsNum = 4;// 内存分配int** a = new int*[rowsNum];for(int i = 0; i &lt; rowsNum; i++)&#123; a[i] = new int[colsNum];&#125;// 内存释放for(int i = 0; i &lt; rowsNum; i++)&#123; delete[] a[i];&#125;delete []a; 指针运算自增或自减 都指向下一个对象 12345CDetail* pDeductFree = (CDetail*)((char*)pQuery+sizeof(CQueryUp));for(int i=0; i&lt;pQuery-&gt;size; ++i)&#123; pDeductFree++;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++对象模型和虚函数表]]></title>
    <url>%2F2019%2F07%2F15%2Fc-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[c++对象模型和虚函数表]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day14]]></title>
    <url>%2F2019%2F07%2F02%2Fcorejava_day14%2F</url>
    <content type="text"><![CDATA[泛型泛型方法/类/通配符 异常断言]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day11]]></title>
    <url>%2F2019%2F07%2F02%2Fcorejava_day11%2F</url>
    <content type="text"><![CDATA[内部类静态内部类12345678class OuterClass&#123; private String name1 = &quot;hello&quot;; private static String name2 = &quot;moto&quot;; public static class InnerClass&#123;//看成一个静态成员，寄居关系 public void innerM()&#123; &#125; &#125;&#125; 静态内部类中只能访问外部类的静态成员访问方式同–&gt;类名.静态成员 成员内部类12345678910111213141516171819class OuterClass&#123; private String name1 = &quot;hello&quot;; private static String name2 = &quot;moto&quot;; public class InnerClass&#123;//看成一个实例成员，寄生关系// private OuterClass outer; public InnerClass(/*OuterClass outer*/)&#123;// this.outer = outer;// 外部调用构造方法时编译器会自动传入外部对象参数 &#125; public void innerM()&#123; System.out.println(name1 + name2);--&gt;默认输出 OuterClass.this.name1(编译器会转化成outer.name1)(成员内部类访问外部类当前对象) &#125; &#125;&#125;OuterClass outer = new OuterClass();OuterClass.InnerClass inner = outer.new InnerClass();//OuterClass.InnerClass inner = new InnerClass(outer);inner.innerM(); 成员内部类可以访问外部类的所有成员访问方式同–&gt;外部对象引用.实例成员 局部内部类123456789101112131415161718class OuterClass&#123; public Object M()&#123;//方法中包含类, 看成方法的局部变量 class InnerClass implements MyInter&#123; final int num = 0; // public void innerM()&#123; &#125; &#125; return new InnerClass(); &#125;&#125;interface MyInter&#123; public void innerM();&#125;OuterClass outer = new OuterClass();MyInter inter = outer.M();inter.innerM(); 若内部类方法要访问外部方法中的变量, 该变量必须是final, 否则当外部类方法执行完, 变量被GC, JDK 1.8 不需要声明为final 匿名内部类12345678910class OuterClass&#123; public MyInter M()&#123; //这里将匿名内部类生成的对象当成一个方法的返回值返回 return new MyInter()&#123;//定义一个无名类实现MyInter接口，实现方法，生成该实现类的对象 public void innerM()&#123; // ... ... &#125; &#125; ; &#125;&#125; 局部内部类的特例, 无类名，无构造方法，必隐含实现接口或继承父类 集合CollectionCollection 接口是 List 接口和 Set 接口的父接口，通常情况下不被直接使用(不能对其实例化) 常用方法 说明 boolean add(E e) 向集合中添加一个元素，E 是元素的数据类型 boolean addAll(Collection c) 向集合中添加集合 c 中的所有元素 void clear() 删除集合中的所有元素 boolean isEmpty() 判断集合是否为空 Iterator iterator() 返回一个 Iterator 对象，用于遍历集合中的元素 boolean remove(Object o) 从集合中删除一个指定元素 int size() 返回集合中元素的个数 boolean contains(Object o) 判断集合中是否存在指定元素 ListList 接口实现了 Collection 接口，它主要有两个实现类：ArrayList 类和 LinkedList 类ArrayList 类提供了快速的基于索引的成员访问方式，对尾部成员的增加和删除支持较好LinkedList 类采用链表结构保存对象，这种结构的优点是便于向集合中插入或者删除元素 ArrayList类常用方法 方法 说明 E get(int index) 获取此集合中指定索引位置的元素，E 为集合中元素的数据类型 int index(Object o) 返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1 int lastIndexOf(Obj ect o) 返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1 E set(int index, E element) 将此集合中指定索引位置的元素修改为 element 参数指定的对象 List&lt;E&gt; subList(int fromlndex, int tolndex) 返回一个新的集合 LinkedList常用方法 方法 说明 void addFirst(E e) 将指定元素添加到此集合的开头 void addLast(E e) 将指定元素添加到此集合的末尾 E getFirst() 返回此集合的第一个元素 E getLast() 返回此集合的最后一个元素 E removeFirst() 删除此集合中的第一个元素 E removeLast() 删除此集合中的最后一个元素 SetSet 集合也实现了 Collection 接口，它主要有两个实现类：HashSet 类和 TreeSet类HashSet 类是按照哈希算法来存储集合中的元素, TreeSet 类同时实现了 Set 接口和 SortedSet 接口。SortedSet 接口是 Set 接口的子接口，可以实现对集合进行自然排序TreeSet 只能对实现了 Comparable 接口的类对象进行排序(compareTos), 二叉树结构, 中序遍历方式 TreeSet类的常用方法 方法 说明 E first() 返回此集合中的第一个元素 E last() 返回此集合中的最后一个元素 SortedSet&lt;E&gt; subSet(E fromElement,E toElement) 返回一个新的集合 SortedSet&lt;E&gt; headSet&lt;E toElement&gt; 返回一个新的集合, toElement 对象之前的所有对象 SortedSet&lt;E&gt; tailSet(E fromElement) 返回一个新的集合, fromElement 对象之后的所有对 自己定义一个比较器和迭代器 MapMap 接口主要有两个实现类：HashMap 类和 TreeMap 类Map.Entry 描述在一个Map中的一个元素（键/值对） Map接口的常用方法 方法 说明 V get(Object key) 返回 Map 集合中指定键对象所对应的值 V put(K key, V value) 向 Map 集合中添加键-值对，返回 key 以前对应的 value，如果不存在, 则返回 null V remove(Object key) 从 Map 集合中删除 key 对应的键-值对，返回 key 对应的 value，如 果没有，则返回null Set entrySet() 返回 Map 集合中所有键-值对的 Set 集合, 此 Set 集合中元素的数据 类型为 Map.Entry Set keySet() 返回 Map 集合中所有键对象的 Set 集合 遍历方法: 通过Map.keySet遍历key和value, 通过Map.entrySet使用iterator遍历key和value,过Map.entrySet遍历key和value, 通过Map.values()遍历所有的value，但不能遍历key 小结接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day09]]></title>
    <url>%2F2019%2F07%2F02%2Fcorejava_day09%2F</url>
    <content type="text"><![CDATA[访问控制修饰符public 所有可见protected 同包及子类可见Default 同包可见private 仅当前类可见 Object类中的方法 方法 返回值 说明 clone() 对象拷贝 Animal b = a；只是地址赋值；实现对象拷贝：在类中覆盖clone方法，修饰符改为public，并实现Cloneable接口 equals() boolenan 实现就是”==” finalize() 资源释放 垃圾回收前调用这个方法 toString() String Object中输出包名+类名+@+16进制地址 String对象池（堆、栈空间之外，属于公共空间，由JVM自动管理和维护）, 对象池中存放字符串值（堆中）的引用 String str1 = “hello”; =&gt; 会在对象池中找”hello”的引用String str2 = new String(“hello”); =&gt; 不会在对象池中找，而且也不会存入对象池，该语句创建了两个对象，一个参数”hello”所代表的字符串对象(会在对象池中找)，一个new出来的字符串对象String s1 = “he”+”llo”; =&gt;编译器先把这条语句优化成String s1 = “hello”;String s2 = “he”;String s3 = s2+”llo”;=&gt;编译器认为相加运算中有变量，不会优化语句，故先得到s2，再得到”llo”，再组合这两个字符串成一个新字符串对象s1==s3 =&gt;false 不是同一个对象s1==str1=&gt;trues3==str1=&gt;false 字符串对象的值不可改变正是由于这种不可改变的特征，如果对于一个具有String类型属性的对象作一个浅拷贝，相当于深拷贝c++中是写时拷贝 StringBuffer线程安全，值可以被修改，默认初始字符长度为16个字符的空间，自动扩容 StringBuilder线程不安全，但效率高了 静态导入要使用静态成员（方法和变量）我们必须给出提供这个静态成员的类。使用静态导入可以使被导入类的静态变量和静态方法在当前类直接可见，使用这些静态成员无需再给出他们的类名。 import java.util.Scanner =&gt; Scanner()import static java.lang.System.out; =&gt; out.println()out为System的静态成员 IntegerInteger.paresInt(“12”,8) =&gt; 12是八进制的，输出十进制int值 =&gt;10Integer.toString(10,8) =&gt; 10是10进制的，输出八进制字符串=&gt;”12”Integer.valueOf(“12”,8) =&gt; 12是8进制的，输出十进制Integer对象=&gt;10 自动封箱=&gt;Integer i =0 &lt;==&gt; Integer i = new Integer(0);自动解封=&gt;int j = i &lt;==&gt; int j = i.intValue();相当于类型隐式转换 Integer也有对象池，同String的理解，值也不可改变Integer的对象池只能存放-128~127的对象，超出范围的只能重新创建对象，不会再到对象池中找Integer i = 0 ; =&gt; 对象池中找Integer i = Integer.valueOf(0); =&gt; 对象池中找Integer i =new Integer(0); =&gt; 创建新对象 类型安全的枚举1)类型不安全public static final int SPRING = 1;public static final int SUMMER = 2;public static final int AUTUMN = 3;public static final int WINTER = 4; switch(int){根据int值判断返回值 case Season.SPRING:return “Spring”; case Season.SUMMER:return “Summer”; case Season.AUTUMN:return “Autumn”; case Season.WINTER:return “Winter”;} 2)外部调用类型安全class Season{ private Season(){} public static final Season SPRING = new Season();} 3)枚举继承自 java.lang.Enum 类, 枚举成员默认都被 final、public, static 修饰，使用时直接使用枚举名称调用成员即可;枚举的构造方法是私有的，可以添加方法 常用方法 描述 values() 以数组形式返回枚举类型的所有成员 valueOf() 将普通字符串转换为枚举实例 compareTo() 比较两个枚举成员在定义时的顺序 ordinal() 获取枚举成员的索引位置 java.util 中添加了两个新类：EnumMap 和 EnumSetEnumMap 使用数组来存放与枚举类型对应的值，使得 EnumMap 的效率非常高(比HashMap高)EnumSet 是枚举类型的高性能 Set 实现，它要求放入它的枚举常量必须属于同一枚举类型123456789101112131415161718192021//定义数据库类型枚举public enum DataBaseType&#123; MYSQUORACLE,DB2,SQLSERVER&#125;//某类中定义的获取数据库URL的方法以及EnumMap的声明private EnumMap&lt;DataBaseType,String&gt;urls=new EnumMap&lt;DataBaseType,String&gt;(DataBaseType.class);public DataBaseInfo()&#123; urls.put(DataBaseType.DB2,&quot;jdbc:db2://localhost:5000/sample&quot;); urls.put(DataBaseType.MYSQL,&quot;jdbc:mysql://localhost/mydb&quot;); urls.put(DataBaseType.ORACLE,&quot;jdbc:oracle:thin:@localhost:1521:sample&quot;); urls.put(DataBaseType.SQLSERVER,&quot;jdbc:microsoft:sqlserver://sql:1433;Database=mydb&quot;);&#125;//根据不同的数据库类型，返回对应的URL//@param type DataBaseType 枚举类新实例//@returnpublic String getURL(DataBaseType type)&#123; return this.urls.get(type);&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day07]]></title>
    <url>%2F2019%2F07%2F01%2Fcorejava_day07%2F</url>
    <content type="text"><![CDATA[instanceofinstanceof ：判断给定的某个对象是不是某一个类型的实例boolean : A instanceof AnimalClassCastException 类强转异常 staticstatic修饰属性（类变量/成员变量）静态属性与非静态属性区别|区别点| 静态属性| 实例态属性||:-|:-|:-|| 空间分配时机| 类加载时分配| 生成对象时|| 空间分配方式| 整个类只有一份| 同对象的数量|| 访问方式| 类名.属性名| 对象名.属性名| static修饰方法（静态方法）1 用” 类名.方法名 “访问2 能直接访问本类中的非静态成员, 但本类的非静态方法可以访问本类的静态成员3 在静态方法中不能出现this关键字4 父类中是静态方法, 子类中不能覆盖为非静态方法5 父子类中, 父类中的静态方法可以被子类中的静态方法覆盖, 但是没有多态！（在使用对象调用静态方法时其实是调用编译时类型的静态方法）6 java中的main方法必须写成static的原因：在类加载时无法创建对象, 而静态方法可以不通过对象调用, 所以在类加载时就可以通过main方法入口来运行程序。 static修饰初始代码块这个代码块只在类加载时被执行一次, 可以用静态初始代码块初始化一个类1234567891011public class TestStatic &#123; public static String str; static &#123; str = &quot;i am here&quot;; &#125; public static void main(String[] args) &#123; System.out.println(TestStatic.str); &#125;&#125; final1 修饰类：类不能被继承2 修饰属性：属性的值不可改变(外部不能改变, 所以一般定义成公开） final static int a = 0 ; 静态常量, 一般这里要赋初始值, 否则就没有机会赋值（只可以这样赋值或则通过构造方法赋值, 而通过构造方法给静态属性赋值没有意义）, 代表整个类的特征 final int a ; 非静态常量, 一般不赋初值, 通过构造方法赋值, 每创建一个对象就有这么一个常量, 属于对象的不可改变的特征3 修饰方法：方法不能被覆盖4 修饰局部变量(or 形参)：值不可变, 为常量 abstract1 修饰类：抽象类 –&gt; 有构造方法, 给子类调用, 但不能实例化 , 必须有子类！2 修饰方法：抽象方法(只有方法的声明没有方法的实现)有抽象方法的类必须是抽象类, 抽象类未必有抽象方法 接口(interface,implements)将服务的提供者和服务的使用者分开1, 接口的所有方法必须是抽象方法abstract, 被隐式的指定为 public abstract2, 接口的所有属性都默认是静态常量static final3, 接口不能实例化, 没有构造方法4, 一个类可以同时实现多个接口5, 一个接口可以同时继承自多个接口(普通类只能单继承) 接口编程的好处： 1）降低系统的耦合度； 六字真言：高内聚, 低耦合； 内聚：一个类独立完成某项功能的能力； 耦合：类和类之间, 模块与模块之间关联关系的复杂度；一个类改了不影响别的类； 2）将标准的制定者和标准的实现者分离； 3）接口应该尽量简单和单一； 4）基于接口的编程（基于抽象的编程）；]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day06]]></title>
    <url>%2F2019%2F07%2F01%2Fcorejava_day06%2F</url>
    <content type="text"><![CDATA[面向对象类类的模板123456修饰符+class+类名+[extends 父类]+[implements 接口名1,接口名2, ...]&#123; 属性: 修饰符+类型+属性名+[=值]; 方法: 修饰符+返回值类型+方法名([形参列表]) [throws 异常类型 ...]&#123; 方法体 &#125;&#125; 构造方法 用处 1、构造方法一般用来为属性赋初值2、构造方法会在生成对象时被系统自动调用 特点 1、没有返回值, 写返回值的位置什么都不写2、方法名必须和类名完全相同 构造方法也可以定义参数, 也可以在里面写实现代码, 程序员不定义, 系统会默认加一个this等价于当前对象, 调用当前对象的属性或方法就用 this.属性名, 或this.方法名() 方法的重载 1, 一个类中同名但参数不同的方法2, 构造方法也可以重载3, this(..,..);调用本类其它的构造方法,这样的调用只能出现在构造方法的第一行 对象创建类的对象的语法: 类名 对象名=new 类名(); 实例化步骤 1, 为对象分配空间(堆)2, 为属性赋初值3, 调用构造方法再次赋值 调用对象的成员 对象名.属性名; a.name=…;对象名.方法名(); a.move(); 封装/继承/多态封装, 将抽象性函式接口的实现细节部份包装、隐藏起来的方法 继承(extends) 1,扩展新的功能 2,子类构造方法一定会调用父类构造方法 3,构造方法第一行 –&gt; this(…) or super(…) , 缺省第一行 –&gt; super() 4,this.name , super.name 多态, 方法的重载和覆盖就是方法多态的一种体现 方法的覆盖(重写, override), 父子类中, 同名同参同返回值, 子类方法访问控制修饰符不能比父类的更封闭, 子类抛出的异常要比父类更具体方法的重载, 同类中, 同名不同参 Java只支持单继承, 一个类最多只有一个直接的父类 编译时类型：在写代码编译过程中，编译器把这个对象当作什么来看（父类对象）运行时类型：在代码执行过程中，JVM把这个对象当作什么看（子类对象）运行时多态的三原则: 1，对象类型不变。 2，只能对对象调用编译时类型中定义的方法。 3，在程序的运行时，根据对象的运行时类型，找覆盖后的方法来调用。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day03]]></title>
    <url>%2F2019%2F07%2F01%2Fcorejava_day03%2F</url>
    <content type="text"><![CDATA[流程控制12345678switch(byte/short/int/char/enum(精确存储，可以匹配))&#123; case byte/short/int/char/enum:... ... ...;break(如果进入该句，而没有break，则以下语句将执行完); case byte/short/int/char/enum:... ... ...; case x1 case x2 case x3:...; ... ... ... default :...;&#125; 数组1234567891011121314151617一维数组 int[] a; --&gt;数组声明 a = new int[5] --&gt; 数组实例化，分配空间，5*(4 byte)，把空间首地址赋给a int[] a = new int[5] ; int[] a =new int[5]&#123;1,2,3,4,5&#125; &lt;==&gt; int[] a = &#123;1,2,3,4,5&#125; a.length ArrayIndexOutOfBoundsException --&gt; 数组下标越界异常 for循环赋值 二维数组 int[][] a = new int[3][5] --&gt; 规则 int[][] a = new int[3][] --&gt; 可以不规则 , 如 a[0] = new int[3] a[1] = new int[5] a[2] = new int[7] a[i] --&gt; 存地址，指向a[i][0].a[i][1]...的首地址 两层for循环赋值 a.length , a[i].length 方法方法：完成某个功能的程序的一个封装体基本语法：修饰符 返回值类型 方法名 ( 形参类型 形参名字 ，… …){ 方法体}public(公开的) static(静态的) void(空类型) main(String[] args) 方法调用过程 1，在栈中给被调用方法的形参分配空间 2，将调用方法实参的值传递给形参 3，断开原方法的执行，跳到被调用方法的执行过程 4，直至被调用方法执行完毕，程序调回原方法继续执行 5，如果有返回值也带回值 6，释放被调用方法的临时空间 空间代码空间：存放字节码数据空间： 栈 –&gt; 给方法中的变量分配的临时空间，特点：先进后出 堆 –&gt; 给创建的对象分配的空间栈： 1,从代码空间装载字节码，因为要运行，最先找到主方法，在栈空间给主方法分配空间，变量分配在主方法的栈空间里 2,如果主方法中调用了m1方法，JVM又去寻找m1方法的字节码，再在栈空间给m1方法分配空间(一样包括变量的分配) 3,如果m1中还有调用m2方法… … … 4,如果m2执行完了，释放m2空间 5,如果m1执行完了，释放m1空间 6,如果主方法也执行完了，释放主方法空间堆： 存放创建的对象(如主方法中的对象的引用，则引用变量存放在栈，创建的对象存放在堆) ScannerScanner scan = new Scanner(System.in); scan.next(); –&gt; return String (a word)scan.nextLine(); –&gt; return String (a line)scan.nextInt(); –&gt; return intscan.nextFloat();scan.nextDouble();]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day02]]></title>
    <url>%2F2019%2F07%2F01%2Fcorejava_day02%2F</url>
    <content type="text"><![CDATA[复习1，java特点：简单、安全、跨平台 2，开发环境：JDK、JRM、JVM、环境变量 3，java程序基本结构 4，带包声明的java程序编译和运行，类装载搜索顺序 5，import语法(java.lang下的类不用import，不用带包名) 6，javadoc String.java -d ./docs jar命令jar (保存编译好的java字节码文件), jar -cvf abc.jar ./abc, cvf (create visable filename) 如何使用abc.jar中的类？=&gt; 在CLASSPATH中指向abc.jar =&gt; 在自己写的java文件中就可以导入jar中的类拿来使用常用的包： java.lang 基本 java.awt/java.swing/java.awt.event 图形界面 java.applet 小程序 java.io 流 java.net 网络 java.util 工具 标识符以_, $开头, 大小写敏感; 命名规则如下1)标识符要符合语义信息2)包名：所有字母小写3)类名：每个单词首字母大写，其它小写 //TarenaStudent4)变量和方法：第一个单词小写，从第二个单词开始首字母大写 //tarenaStudent5)常量：所有字母大写，每个单词之间用” _ “连接 //int MONEY_VALUE = 50; 基本数据类型 关键字 占位 值 boolean 8位 true/false byte 8位整数 256 short 16位整数 65536 int 32位整数 2^32, 一个10位 long 64位整数 2^64, 一共20位 float 32位浮点 1bit(符号位) 8bits(指数位) 23bits(尾数位); 指数范围-2^128 ~ +2^128; 精度2^23 = 8388608, 一共7位; 其中负指数决定了浮点数所能表达的绝对值最小的非零数,而正指数决定了浮点数所能表达的绝对值最大的数 double 64位浮点 1bit(符号位) 11bits(指数位) 52bits(尾数位); 指数范围-2^1024 ~ +2^1024; 精度2^52 = 4503599627370496, 一共16位 char 16位Unicode编码 0~65535, 代表某个字符(无符号整数), 有足够的空间保存非英文字符;(c语言 =&gt; 8bit , A~Z , a~z , number , 标点及控制字符等 ) char = ‘\u0060’ , unicode 为0X0060 (16进制 )的字符97(‘\u0061’) =&gt; ‘a’65 =&gt; ‘A’48 =&gt; ‘0’ 二进制中的原码、反码、补码 对于有符号数而言： (1)二进制的最高位是符号位：0表示正数，1表示负数 (2)正数的原码、反码、补码都一样； (3)负数的反码 = 它的原码符号位不变，其他位取反（0 -&gt;1 ; 1-&gt;0 ） (4)负数的补码 = 它的反码 +1 (5)0的反码、补码都是0 (6)在计算机运算的时候，都是以补码的方式来运算的 (7)如果想将 二进制 转为 十进制，必须使用 二进制的原码 类型转换 自动类型转换(隐式转换)：小值赋给大值 强制类型转换(显式转换)：大值赋给小值 byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double char-&gt;int-&gt;long-&gt;float-&gt;double long l=2147483648错误，字面值默认为是int型，超出了int范围，正确写法:long l=2147483648Lfloat f=3.1415926错误，字面值默认为double型，double赋给float，类型不匹配，正确写法：float f=3.1415926F如果要判断两个浮点数n1和n2是否相等，if(Math.abs(n1-n2)&lt;=1e-6){…} 替代 if(n1==n2){…} 运算符位运算符, 右移位数如果超出基本类型范围 , 则实际右移位数=右移位数%范围 &gt;&gt; 有符号右移 左0/1符号补充右丢失 右移n位后 = 数/2^n &gt;&gt;&gt; 无符号右移 左以0补充 &lt;&lt; 左移 右0补充左丢失 左移n位后 = 数*2^n (有效数据位没有溢出时) ~ 按位取反 b3 = 10 ; ~b3; 数字+1取负 &amp; 按位与 1 &amp; 1 = 1 , else 0; 设置指定位置0,其它不变 shu 按位或 0 shu 0 = 0 , else 1; 设置指定位置1, 其它位不变 ^ 按位异或 不同为1，相同为0; 设置指定位置求反，其他位不变, 0000 1111按位异或 –&gt; 1位求反其余不变 小结jar命令/Java常用包介绍/标识符、关键字、基本数据类型/数据类型转换/引用类型/对象/运算符]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[corejava_day01]]></title>
    <url>%2F2019%2F06%2F28%2Fcorejava_day01%2F</url>
    <content type="text"><![CDATA[Java特点why invent java ? 1995.5.23 sun.发布 简单：抛弃指针、垃圾回收机制 (System.gc() ; ) 安全：允许用户使用指针而不允许用户操作指针 跨平台：跨操作系统平台 32位(xp),指总线宽度为32位，存储内存空间的地址值，可以存储2^32个不同的值，每个地址值指向一个字节的地址， 故机器能够识别管理大内存空间为2^32字节(42^102^10*2^10=4G) C++原码跨平台，编译后不跨平台，需不同平台下编译 高级语言 =&gt; 编译 =&gt; 操作平台代码 =&gt; OS转化 =&gt; 机器平台代码(cpu指令集)java语言 =&gt; 编译 =&gt; 二进制字节码 =&gt; JVM (不跨平台)=&gt; 转化 =&gt; 操作平台代码 =&gt; OS转化 =&gt; 机器平台代码 What is the difference between JRE,JVM and JDK?JDK Java Development Kit, 编写java程序所需的开发工具包, 包含JRE, java/javac。JRE Java Runtime Environment, JRE=JVM+Java Packages Classes+runtime librariesJVM Java Virtual Machine, It only helps Java to be executed on the platform-independent way. 参考 JDK安装JDK/lib 目录下rt.jar JDK提供的基础开发类库(字节码文件); src.zip是rt.jar 的源码123456789.bash_profile JAVA_HOME=xxxxx #JDK安装目录 CLASSPATH=. #字节码搜索路径 PATH=$PATH:$JAVA_HOME/bin #加入jdkXXX/bin目录 (jdk开发调试命令 ) export JAVA_HOME CLASSPATH PATH vi MyFirstJava.java javac MyFirstJava.java java MyFirstJava Java基本概念类 1) 一个java源文件可以定义多个类，但最多只能有一个public类，而且该public类的类名必须和文件名一致 2) 一个java源文件在编译后形成的字节码文件个数与该源文件中定义的类的个数一致，每一个类 =&gt; 一个字节码文件 3) 一个可运行的java类有且仅有一个主方法，而且主方法的签名(public static void main(String[] args))是固定的，是整个程序的入口方法 包 url + project_name + project_model_name, 例如 com.tarena.abs.model 12345678910111213package xxx.xxx.xxx;import java.util.Scanner;import java.util.List;import java.util.*;public class XXX&#123; public static void main(String[] args)&#123; ... ... ... &#125; &#125;class XXX&#123; ... ... ... &#125; 编译运行 javac PackageTest.java -d . | or | javac -d . PackageTest.java 带包编译并把编译后生成的class字节码文件放在指定目录下 java xxx.xxx.PackageTest 1) 启动JVM 2) 装载类的字节码文件, 先到当前所在包下找, 再到jre/lib/xxx.jar中找, 再到CLASSPATH中找 3) 运行类的主方法 String =&gt; java.lang 包下 =&gt; 字节码文件在jre/lib/rt.jar中 =&gt; 默认会加载，不必配置CLASSPATH，(jre/lib/下的jar文件都会自动加载，不需配置) java.lang包下的所有类的使用可以不写包名，直接写类名 123456789javac -help//...单行注释/* ...多行注释 *//** ...文档注释 */生成文档：javadoc String.java -d(目录参数) ./docs]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++泛型编程]]></title>
    <url>%2F2019%2F06%2F11%2Fc-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[泛型编程就是与类型无关的编程, 可以提高软件重用 函数模板关键字template &lt; class T &gt;template &lt; typename &gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;inline T square(T x)&#123; T result; result = x * x; return result;&#125;;template &lt;typename T, typename U&gt;void squareAndPrint(T x, U y)&#123; T result; U otherVar; cout &lt;&lt; &quot;X: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; x * x &lt;&lt; endl; cout &lt;&lt; &quot;Y: &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; y * y &lt;&lt; endl;&#125;;template &lt;typename T, int count&gt;void loopIt(T x)&#123; T val[count]; for(int ii=0; ii&lt;count; ii++) &#123; val[ii] = x++; cout &lt;&lt; val[ii] &lt;&lt; endl; &#125;&#125;;template &lt;typename T=float, int count=3&gt;T multIt(T x)&#123; for(int ii=0; ii&lt;count; ii++) &#123; x = x * x; &#125; return x;&#125;;// template specializationtemplate &lt;&gt;string square&lt;string&gt;(string ss)&#123; return (ss+ss);&#125;;main()&#123; int i, ii; float x, xx; double y, yy; i = 2; x = 2.2; y = 2.2; ii = square&lt;int&gt;(i); cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; ii &lt;&lt; endl; xx = square&lt;float&gt;(x); cout &lt;&lt; x &lt;&lt; &quot;: &quot; &lt;&lt; xx &lt;&lt; endl; // Explicit use of template yy = square&lt;double&gt;(y); cout &lt;&lt; y &lt;&lt; &quot;: &quot; &lt;&lt; yy &lt;&lt; endl; // Implicit use of template yy = square(y); cout &lt;&lt; y &lt;&lt; &quot;: &quot; &lt;&lt; yy &lt;&lt; endl;&#125; 类模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Matrix2x2.hpp----#ifndef MATRIX_2X2_HPP__#define MATRIX_2X2_HPP__using namespace std;/** m(11) m(12) m(21) m(22)*/template &lt;class T&gt;class Matrix2x2&#123;public: Matrix2x2(T m11, T m12, T m21, T m22); //constructor Matrix2x2(T m[2][2]); Matrix2x2(); int Add(Matrix2x2 x) int Multiply(Matrix2x2 x) void Print(); T m[2][2];&#125;;template &lt;class T&gt;Matrix2x2&lt;T&gt;::Matrix2x2(T _m11, T _m12, T _m21, T _m22)&#123; m[0][0] = _m11; m[0][1] = _m12; m[1][0] = _m21; m[1][1] = _m22;&#125;template &lt;class T&gt;Matrix2x2&lt;T&gt;::Matrix2x2(T _m)&#123; m[0][0] = _m[0][0]; m[0][1] = _m[0][1]; m[1][0] = _m[1][0]; m[1][1] = _m[1][1];&#125;template &lt;class T&gt;Matrix2x2&lt;T&gt;::Matrix2x2()&#123; m[0][0] = 0; m[0][1] = 0; m[1][0] = 0; m[1][1] = 0;&#125;.......#endif// file2.cpp----#include &lt;iostream&gt;#include &quot;Matrix2x2.hpp&quot;using namespace std;int main(int argc, char* argv[])&#123; Matrix2x2&lt;int&gt; X(1,2,3,4); Matrix2x2&lt;int&gt; Y(5,6,7,8); cout &lt;&lt; &quot;X:&quot; &lt;&lt; endl; X.Print();&#125; 静态成员123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;template &lt;class T&gt; class XYZ&#123;public: void putPri(); static T ipub;private: static T ipri;&#125;;template &lt;class T&gt; void XYZ&lt;T&gt;::putPri()&#123; cout &lt;&lt; ipri++ &lt;&lt; endl;&#125;// Static variable initialization:template &lt;class T&gt; T XYZ&lt;T&gt;::ipub = 1;template &lt;class T&gt; T XYZ&lt;T&gt;::ipri = 1.2;main()&#123; XYZ&lt;int&gt; aaa; XYZ&lt;float&gt; bbb; aaa.putPri(); cout &lt;&lt; aaa.ipub &lt;&lt; endl; bbb.putPri();&#125; 继承12345678910111213141516class Clor&#123;&#125;;// 泛型类继承非泛型类template &lt;typename T&gt;class Circle : public Color&#123;&#125;;// 非泛型类继承泛型类class Sphere : public Circle&lt;float&gt;&#123;&#125;;// 泛型类继承泛型类template &lt;typename T&gt;class Sphere : public Circle&lt;T&gt;&#123;&#125;; 模板参数12 全特化和偏特化12 类型萃取模板的分离编译因为编译和连接是分开的, 将声明和定义单独编译, 链接会出错; 所以声明和定义放在头文件中.]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql深入浅出 笔记]]></title>
    <url>%2F2019%2F06%2F04%2Fmysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA1-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[mysql基本架构MySQL的逻辑架构：Server层和引擎层。Server层：连接器+分析器(词法/语法分析)+优化器(索引选择)+执行器(操作引擎，返回结果) + 查询缓存(分析时命中则直接返回)引擎层： 1234//链接数据库mysql -h$ip -P$port -u$user -p //显示数据库连接情况show processlist 一个链接长时间不用默认8小时断开，参数wait_timeout控制；通过链接对象管理内存，用久内存占用大。 mysql_reset_connection 重新初始化链接。 查询缓存，key-value，key是sql，value是结果；在更新数据后清空，一般不建议用(参数query_cache_type)，在MySQL8.0中没有缓存。 日志系统binlog（归档日志）是Server层的，所有引擎都可用; 追加写, 文件写到一定大小切换下一个; 逻辑日志记录原始语句;主要用于备份 redo log（重做日志）InnoDB引擎特有的日志; 循环写, 固定空间; 物理日志记录在某个数据页上的修改;主要用户crash恢复 redo log 为了支持crash-safe, WAL技术, Write-Ahead Logging, 关键点是先写日志再写磁盘, 还没写磁盘查询怎么办？ redo log 二阶段提交, 包含prepare/commit, 保证两个日志都写完整，可以恢复到任意时刻crash恢复 和 扩容(备份+binlog)，保持逻辑上一致 innodb_flush_log_at_trx_commit = 1 , sync_binlog = 1 每次事务日志都持久化到磁盘 Binlog有两种模式, statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有. 12345// 数据库1 写redo log, 处于prepare状态 =&gt; 2 写binlog =&gt; 3 commit提交事务, redo log处于commit状态不管在什么时候崩溃，binlog写成后事务算成功，就提交事务; 否则就回滚。binlog是后悔，redo log是救命。 事务隔离ACID（Atomicity, Consistency, Isolation, Durability） 多个事务同时执行问题：脏读，读取了其他事务未提交的数据不可重复读，针对其他提交，读取数据本身的对比；同一条记录多次读取值不一样，其他事务update幻读，针对其他提交，读取数据条数的对比；多次查询结果集不一样，其他事务insert SQL标准的事务隔离级别：读未提交, 一个事务还没提交时, 变更就能不其他事务看到读提交, 一个事务提交后, 变更才会被其他事务看到可重复读, 一个事务在执行过程中看到的数据, 总是跟这个事务启动时看到的是一致的, 未提交事务对其他事务不可见; 一个事务在启动的时候, 看到所有已提交的事务结果, 之后在事务期间, 其他事务更新不可见。串行化, 顺序执行 1234567891011mysql&gt; show variables like &apos;transaction_isolation&apos;;+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+ 事务隔离实现:通过一致性视图和回滚日志，同一条记录在系统中可以有多个版本(就是数据库多版本并发控制MVCC) 事务的启动： 1231) begin或start transaction(在真正操作表时才启动), commit, rollback2) set autocommint=0 (默认1)，不会主动提交，执行commit/rollback或断开连接3) start transaction with consist snapshot(InnoDB) 索引索引模型哈希表, 适用于等值查询有序数组, 有序数组索引只适用于静态存储引擎, 例如等值查询和范围查询搜索树, 较少磁盘访问次数 主键和索引区别, 每个主键都会维护一个索引, 索引字段单独维护一个表 索引类型1）主键索引(聚簇索引)，值存的是整行内容2）非主键索引(二级索引)，值存的是主键内容 12345678//drop主键索引会导致其他索引失效，但drop普通索引不会//删除主键还是创建主键，都会将整个表重建//重建索引 k 的做法是合理的，可以达到省空间的目的alter table T drop index k;alter table T drop primary key;alter table T add index(k);alter table T add primary key(id); 基于主键索引查询，只需查询一次；基于非主键索引查询，先得到主键值，再去查询主键索引。 InnoDb 索引模型索引的实现由存储引擎来决定, 每一个索引在 InnoDB里面对应一棵B+树(N叉树), 没有主键的表,innodb会给默认创建一个Rowid做主键 1234567mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;// NOT NULL PRIMARY KEY AUTO_INCREMENT 自增主键 索引维护B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一 在Key-Value的场景下，只有一个索引且是唯一索引，则适合直接使用业务字段作为主键索引 如何避免长事务对业务的影响？客户端：分析general_log；select不需要begin/commit；SET MAX_EXECUTION_TIME命令控制最长执行时间；数据库：监控infomation_schema.Innodb_trx，设置长事务阀值，超过就报警或kill pt-kill （KILL MySQL指定查询) 1234567mysql&gt;set global general_log_file='/tmp/general.lg'; #设置路径mysql&gt;set global general_log=on; # 开启general log模式mysql&gt;set global general_log=off; # 关闭general log模式mysql&gt;set global log_output='table' # 在general_log表中查看mysql&gt;show global variables like '%general%'; # 查看 覆盖索引非主键索引上已经存储了主键值, 查询主键值不需要回表应用场景：身份证号/姓名 联合索引, 通过身份证号查询姓名频率很高 最左前缀原则, 联合索引顺序, 最左的N的字段或字符串的M个字符索引下推, 在搜索过程中对索引中包含字段优先判断, 减少回表次数，满足条件的再比较其他字段 重建索引和主键，省空间？ 1alter table T engine=InnoDB 全局锁和表锁全局锁命令: 其他线程数据库操作被阻塞 1mysql&gt;Flush tables with read lock 业务场景：用于全库逻辑备份;mysqldump , InnoDB使用-single-tranction参数导数据前拿到一个一致性试图, 数据可以正常更新; MyISAM引擎不支持事务, 只能使用全局锁 set global readonly=true 不推荐使用, 通常用做主备判断, 客户端异常断开数据库保持readonly 表级别的锁 表锁 123456// read 本线程和其他线程只能读; write 本线程可读写，其他线程读写阻塞lock/unlock tables ... read/write// 其他线程，t1可读，t1写和t2读写阻塞// 本线程只能t1可读，t2可读写lock tables t1 read, t2 write ; 元数据锁MDL锁(metadata lock)，防止DDL和DML并发的冲突，事务提交时释放。增删改查加MDL读锁，表结构变更操作时加MDL写锁；读写锁之间互斥，读锁之间不互斥。DML语句（数据操作语言）Insert、Update、 Delete、MergeDDL语句（数据定义语言）Create、Alter、 Drop、Truncate 如何安全的给表加个字段？ 123// 使用NOWAIT/WAIT n 不影响其他线程查询和更新操作alter table name NOWAIT add column...alter talbe name WAIT N add column... 哪个索引是多余的？ 12345678910111213CREATE TABLE `geek` ( `a` int(11) NOT NULL, `b` int(11) NOT NULL, `c` int(11) NOT NULL, `d` int(11) NOT NULL, PRIMARY KEY (`a`,`b`), KEY `c` (`c`), KEY `ca` (`c`,`a`), KEY `cb` (`c`,`b`)) ENGINE=InnoDB;InnoDB会把主键字段放到索引定义字段后面, 同时也会去重依次是 abc,cab,cab,cba , 所以第三个ca主键索引是多余的 行锁在InnoDB事务中, 行锁是在需要的时候加入, 事务结束时释放 交叉死锁办法:innodb_lock_wait_timeout 超时设置，默认50s; innodb_deadlock_dectect 设置on, 回滚其中一个交叉的事务 备库-single-tracation备份时，主库binlog传来一个DDL语句会怎么样？ 123456789101112Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;Q2:START TRANSACTION WITH CONSISTENT SNAPSHOT；/* other tables */Q3:SAVEPOINT sp;/* 时刻 1 */Q4:show create table `t1`;/* 时刻 2 */Q5:SELECT * FROM `t1`;/* 时刻 3 */Q6:ROLLBACK TO SAVEPOINT sp;/* 时刻 4 *//* other tables */ 事务视图 : view 虚拟表, 一致性视图(MVCC多版本并发控制协议) 用于支持读提交/可重复读隔离级别实现 InnoDB里面有一个唯一事务ID, 按申请顺序严格递增, 每个版本都有row trx_idInnoDB为每个事务创建了一个数组, 记录事务启动瞬间活跃的事务ID 可重复读 查询只承认事务启动前就已经提交的数据 读提交 查询只承认在语句启动前就已经提交的数据 Percona Toolkit1234567891011121314151617181920212223[root@localhost download]# rpm -ivh percona-toolkit-3.1.0-2.el7.x86_64.rpmwarning: percona-toolkit-3.1.0-2.el7.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 8507efa5: NOKEYerror: Failed dependencies: perl(IO::Socket::SSL) is needed by percona-toolkit-3.1.0-2.el7.x86_64 perl(Digest::MD5) is needed by percona-toolkit-3.1.0-2.el7.x86_64[root@localhost download]# rpm -ivh percona-toolkit-3.1.0-2.el7.x86_64.rpmwarning: percona-toolkit-3.1.0-2.el7.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 8507efa5: NOKEYerror: Failed dependencies: perl(Digest::MD5) is needed by percona-toolkit-3.1.0-2.el7.x86_64 yum insatll perl-DBIyum install perl-DBD-MySQLyum install perl-IO-Socket-SSLyum install perl-Digest-MD5[root@localhost download]# rpm -ivh percona-toolkit-3.1.0-2.el7.x86_64.rpmwarning: percona-toolkit-3.1.0-2.el7.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 8507efa5: NOKEYPreparing... ################################# [100%]Updating / installing... 1:percona-toolkit-3.1.0-2.el7 ################################# [100%] [root@localhost download]# pt-duplicate-key-checker --help]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[github项目索引]]></title>
    <url>%2F2019%2F05%2F29%2Fgithub%E9%A1%B9%E7%9B%AE%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[interviewC/C++面试知识总结, 还有很多其他interview项目 JavaGuide这是一份 Java 学习指南，涵盖了大部分 Java 程序员所需要掌握的核心知识。 27天成为Java大神 LeetCodeAnimation这个项目用动画的形式呈现了 LeetCode 题目的思路，非常易于学习。 The-Art-Of-Programming-By-July面试和算法心得, 包含解题思路和c++代码 system-design-primer学习如何设计大型系统, 面试学习用 CS-Notes这是一份很完整的计算机学习笔记，一共分为十个模块，包括算法、操作系统、网络、面向对象、数据库、Java、系统设计、工具、编码实践、后记。 Java-SummarizeJava后端知识体系总结 go-study-indexGo 语言学习资料索引 ResumeSample程序员简历模板系列 USTC-Course中国科学技术大学课程资源 Awesome-python-applications这是一个 Python 程序集合，目前包含 195 个开源 Python 程序，而且数量还在不断增加，它按照主题划分，包含库和文档等链接。 follyAn open-source C++ library developed and used at Facebook Libcolibco是微信后台大规模使用的c/c++协程库, 构建高并发服务器应用]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flutter学习笔记]]></title>
    <url>%2F2019%2F05%2F22%2Fflutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Dart语法 scope_model三个主要类 Model 继承扩展这个类, 监听变化ScopedModel 将Model封装到ScopedModel, 可以让Model访问到所有子组件ScopedModelDescendant 找到合适的ScopedModel, 自动重建变化的Model 参考 常见组件 Padding 填充布局Flex 弹性布局align 对齐布局 CheckBox 复选框MaterialApp 使用墨水设计风格的应用Dropdown 下拉菜单GridView 网格视图列表, ListViewSlider 滑动条Opacity 不透明度, 控制组件显示隐藏 GestureDetector 手势识别Stack 帧布局, 层叠堆放Center 中心布局TabBar 选项栏FloatingActionButton 漂浮按钮Scaffold 布局控件, 参数appbar, body, floatingActionButton, drawer…]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养 笔记]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 温故而知新计算机软硬件结构1) 硬件架构SMP与多核SMP, Symmetrical Multi-Processing, 多个CPU, 理论上会跑的快, 实际应用在数据库, 网络服务器处理独立请求多核, 共享贵的缓存部件, 保留多个核心; 实际上就是SMP的简化版, 一般理解成同一个概念2) 软件架构操作系统功能对上提供抽象接口, 对下管理硬件资源 不让CPU打盹多道程序: 监控程序来调度分配CPU使用分时系统: 每个程序运行一段时间, 死循环霸占CPU就没办法了多任务系统: 进程隔离/优先级, CPU在多个进程间切换 内存虚拟内存实现需要硬件支持, 一般通过集成在CPU里部件MMU(memory manager uint)来管理内存页映射 线程轻量级进程LWP(Lightweight Process), 由线程ID、当前指令指针、寄存器集合和堆栈组成1) 访问权限私有数据：局部变量, 函数参数, TLS数据共享数据：全局变量, 堆数据, 函数里的静态变量, 打开的文件2) 调度与优先级线程至少有三种状态运行(正在执行), 就绪(可以执行, 但CPU被占用), 等待(等待I/O或同步事件发生, 无法执行)3) 线程安全可重入函数条件：不使用或返回(局部)静态或全局的非const变量(指针)仅依赖调用方提供的参数不依赖任何单个资源锁不调用不可重入函数 12345678910x=y=0thread1 thread2x=1; y=1;r1=y; r2=x;编译优化后x=y=0thread1 thread2r1=y; y=1;x=1; r2=x; volatile基本可以做到两件事：1) 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回2) 阻止编译器操作volatile变量的指令顺序 其中singleton模式加锁位置必须在if判断前, 保证只构造一次4) 多线程用户线程和内核线程可以是一对一, 一对多, 多对多 第二章 编译和连接隐藏了的过程预编译/编译/汇编/链接 12345678// 展开宏, #include, #ifdef #endif处理gcc -E test.cpp -o test.i// 编译...gcc -S test.cpp -o test.s// 转换成机器码gcc -c test.s -o test.o ld -static test.o -lgcc -l... 编译器做了什么词法分析/语法分析/语义分析/中间语言生成/目标代码生成和优化 链接器地址和空间分配/符号决议/重定位等步骤 第三章 目标文件里有什么目标文件格式windows PE-COFF, LINUX ELF , 都是COFF格式变种; linux下文件格式用file命令查看. ELF格式文件归为4类: 可重定位文件(.o, .boj), 可执行文件(a.out, .exe), 目标共享文件(.so,.dll), 核心转储文件(core dump) 目标文件构成 .o或a.out 说明 File Header 文件属性 .text section 代码段 .data section 初始化的全局变量和静态局部变量 .bss section 记录未初始化的全局变量和局部静态变量大小总和, 只是预留位置, 没有内容, 不占文件空间 123456789101112131415161718int global_init_var = 84; // .dataint global_uninit_var; // .bssvoid func(int i) //.text&#123; //.text printf(&quot;%d\n&quot;, i); //.text&#125; //.textint main() //.text&#123; //.text static int static_var = 1; // .data static int static_var2; // .bss static int static_var = 0 也是放在.bss int a = 1; //.text int b; //.text func(a+b+static_var+static_var2); //.text return 0; //.text&#125; 编译后主要有程序指令(.text)和程序数据(.data, .bss), 分开存储的好处：指令是只读, 数据可读写, 防止被意外修改CPU缓存, 提高命中率数据共享, 提高内存利用率 挖掘simpleSection.o1234567891011121314151617181920212223242526272851_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%file simpleSection.cpp simpleSection.cpp: C source, ASCII text51_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%file simpleSection.osimpleSection.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped51_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%objdump -h simpleSection.osimpleSection.o： 文件格式 elf64-x86-64节：Idx Name Size VMA LMA File off Algn 0 .text 00000057 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 0000000000000000 0000000000000000 00000098 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000008 0000000000000000 0000000000000000 000000a0 2**2 ALLOC 3 .rodata 00000004 0000000000000000 0000000000000000 000000a0 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 00000012 0000000000000000 0000000000000000 000000a4 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000b6 2**0 CONTENTS, READONLY 6 .eh_frame 00000058 0000000000000000 0000000000000000 000000b8 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA 51_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%size simpleSection.o text data bss dec hex filename 179 8 8 195 c3 simpleSection.o .rodata 只读数据段(const常量, 一些常量字符串), .comment 注释段, .note.GNU-stack 堆栈提示段, .eh_frame objdump -s 以16进制显示, -d 反汇编 -x 显示所可用的头信息，包括符号表、重定位入口 常用段名 说明 .rodata 只读数据, const变量 .comment 存放编译器版本信息 .debug 调试信息 .dynamic 动态链接信息 .hash 符号哈希表 .line 调试行号表, 源代码和编译指令对应表 .note 额外编译器信息 .strtab 字符串表, 存储文件中用到的各种字符串 .symtab 符号表 .shstrtab 段名表 .plt .got 动态链接的跳转表和全局入库表 .int .fini 程序初始化和终结代码段 用户也可以自定义指定段, 把变量或函数放到指定的段中attribute(section(“FOO”)) static int golbal_var = 1; ELF文件结构描述文件头12345678910111213141516171819202151_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%readelf -h simpleSection.oELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&apos;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (可重定位文件) Machine: Advanced Micro Devices X86-64 Version: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1048 (bytes into file) 标志： 0x0 本头的大小： 64 (字节) 程序头大小： 0 (字节) Number of program headers: 0 节头大小： 64 (字节) 节头数量： 13 字符串表索引节头： 10 文件头定义了ELF魔数, 文件机器字节长度, 数据存储方式, 版本, 运行平台, 硬件平台版本, 入口地址, 程序入口和长度段表的位置和长度, 段的数量 段表12345678910111213141516171819202122232425262728293031323334353651_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%readelf -S simpleSection.o共有 13 个节头，从偏移量 0x418 开始：节头： [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000057 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000370 0000000000000078 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 00000098 0000000000000008 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000a0 0000000000000008 0000000000000000 WA 0 0 4 [ 5] .rodata PROGBITS 0000000000000000 000000a0 0000000000000004 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000a4 0000000000000012 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000b6 0000000000000000 0000000000000000 0 0 1 [ 8] .eh_frame PROGBITS 0000000000000000 000000b8 0000000000000058 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 000003e8 0000000000000030 0000000000000018 I 11 8 8 [10] .shstrtab STRTAB 0000000000000000 00000110 0000000000000061 0000000000000000 0 0 1 [11] .symtab SYMTAB 0000000000000000 00000178 0000000000000180 0000000000000018 12 11 8 [12] .strtab STRTAB 0000000000000000 000002f8 0000000000000077 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 重定位表 , 字符串表 链接的接口(符号)符号查看123456789101112131415161718192021222324252627282951_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%nm simpleSection.o0000000000000000 D global_init_var0000000000000000 B global_uninit_var0000000000000022 T main U printf0000000000000000 T _Z4funci0000000000000004 d _ZZ4mainE10static_var0000000000000004 b _ZZ4mainE11static_var51_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%readelf -s simpleSection.o Symbol table &apos;.symtab&apos; contains 16 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS simpleSection.cpp 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 _ZZ4mainE10static_var 7: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 _ZZ4mainE11static_var2 8: 0000000000000000 0 SECTION LOCAL DEFAULT 7 9: 0000000000000000 0 SECTION LOCAL DEFAULT 8 10: 0000000000000000 0 SECTION LOCAL DEFAULT 6 11: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init_var 12: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_uninit_var 13: 0000000000000000 34 FUNC GLOBAL DEFAULT 1 _Z4funci 14: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 15: 0000000000000022 53 FUNC GLOBAL DEFAULT 1 main extern “C”编译后c++和c的符号不同, c++ 调用C语言接口memset, 通过头文件中条件宏来判断123456789#ifdef __cplusplusextern &quot;C&quot; &#123;#endifvoid memset(void* , int, size);#ifdef __cplusplus&#125;#endif 强符号、弱符号一般是同名变量，尽量不要写; 强引用覆盖弱引用比较有用12345678910111213141516171819202122232425#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; int pthread_create(pthread_t*, const pthread_attr_t*, void* (*)(void*), void*)__attribute__ ((weak));int main()&#123; if(pthread_create) &#123; printf(&quot;multi-thread.\n&quot;); &#125; else &#123; printf(&quot;single-thread.\n&quot;); &#125;&#125;51_zjdev[zhangbb]%g++ pthread.cpp -o pt51_zjdev[zhangbb]%./ptsingle-thread.51_zjdev[zhangbb]%g++ pthread.cpp -o pt -lpthread51_zjdev[zhangbb]%./ptmulti-thread. 第四章 静态链接空间与地址分配链接器在空间分配上采用相似段合并的方式, 例如.text与.text合并。扫描所有输入文件, 建立全局符号表, 计算出输出文件各段合并后的长度与位置, 并建立映射关系 符号解析与重定位123456789101112131415161718192021222351_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%cat a.c#include &lt;stdio.h&gt;#include &quot;b.c&quot;extern int shared;int main()&#123; int a = 100; swap(&amp;a, &amp;shared);&#125;51_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%cat b.c #include &lt;stdio.h&gt;int shared = 1;void swap(int* a, int* b)&#123; *a^=*b^=*a^=*b; &#125;51_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%gcc -c a.c b.c51_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%objdump -h a.o...... VMA(virtual memory address), LMA(Load Memory Addres), File off 文件偏移量可以计算出每个函数以及变量的地址 COMMON块多个符号类型不一致, 多个强符号链接时报错符号重定义int global attribute((nocommon)) // 强符号 C++相关问题模板、内联、虚函数, 模板在编译单元的目标文件中实例化,在链接时合并到代码段 函数级别链接, -ffunction-section, -ffdata-section, 在链接输出文件中去掉没有用到的函数和变量 全局对象构造和析构利用.init/.fini 段 ABI(Application Binary Interface) 静态库连接静态库可以看成是一组目标文件的集合, 链接过程控制-fno-buildin 编译器内置优化替换函数-static 静态链接-e 函数入库 第五章 Windows PE/COFF第六章 可执行文件的装载与进程装载方式覆盖装入和页映射, 用到哪个模块就装载, 暂时不用就放到磁盘中 可执行文件的装载进程的建立1) 创建一个独立的虚拟地址空间2) 读取可执行文件头, 建立可执行文件到虚拟内存的映射关系3) 将CPU的指令寄存器设置成可执行文件入库地址, 启动进程 页错误捕获后分配实际内存 进程虚拟空间分布对于相同权限的段, 把他们合并到一个段进行映射 ##]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高性能Linux服务器构建实战 笔记]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%AB%98%E6%80%A7%E8%83%BDLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CPU profiler]]></title>
    <url>%2F2019%2F03%2F21%2FCPU-profiler%2F</url>
    <content type="text"><![CDATA[使用CPU profiler有三部分: 库连接, 运行代码, 分析输出。CPU profiler的数据文件有单独的说明文档… 库连接 编译时连接 -lprofiler 设置全局环境变量, setenv LD_PRELOAD /usr/lib/libprofiler.so(不推荐, 用户设置没有限制) 以上两种方式并没有打开CPU profiler,仅仅只是在代码中插入链接符号. 1g++ test.cpp -o test -lprofiler 运行代码有三种方式可以打开CPU profiler: 设置CPUPROFILE环境变量, 例如setenv CPUPROFILE ~/data/prof/decode.prof 设置CPUPROFILESIGNAL, 定义未使用的信号控制输出 123456setenv CPUPROFILE ~/data/prof/test.profsetenv CPUPROFILESIGNAL 60// 开始kill -60 pid// 停止kill -60 pid include 头文件&lt;gperftools/profiler.h&gt;, 使用ProfilerStart(char* filename) 和 ProfilerStop()还有ProfilerFlush() and ProfilerStartWithOptions() 出于安全考虑, CPU分析不会写到文件中, 不能应用于setuid程序。 环境变量 name desc CPUPROFILE_FREQUENCY 默认100samples/second, 相当于一个样本10ms CPUPROFILE_REALTIME 默认不设置, 只要设置了(即使是0或空), 用ITIMER_REAL代替 ITIMER_PROF, 一般不设置 分析输出pprof是用于分析profile的脚本。有多种输出模式, 有类似gcc -pg 的输出(gprof)。pprof依赖dot/gv。 123456789101112131415161718192021pprof &lt;format&gt; [options] [binary] &lt;source&gt;% pprof /bin/ls ls.prof Enters &quot;interactive&quot; mode% pprof --text /bin/ls ls.prof Outputs one line per procedure% pprof --gv /bin/ls ls.prof Displays annotated call-graph via &apos;gv&apos;% pprof --gv --focus=Mutex /bin/ls ls.prof Restricts to code paths including a .*Mutex.* entry% pprof --gv --focus=Mutex --ignore=string /bin/ls ls.prof Code paths including Mutex but not string% pprof --list=getdir /bin/ls ls.prof (Per-line) annotated source listing for getdir()% pprof --disasm=getdir /bin/ls ls.prof (Per-PC) annotated disassembly for getdir()% pprof --text localhost:1234 Outputs one line per procedure for localhost:1234% pprof --callgrind /bin/ls ls.prof Outputs the call information in callgrind format 分析text输出12eg. 14 2.1% 17.2% 58 8.7% std::_Rb_tree::find value desc 14 samples 2.1% 在总samples的比例 17.2% 到该函数为止, 已经运行的函数占总samples的比例 58 函数加上函数里被调用者的总samples 8.7% 函数加上函数里被调用者的总samples 在总samples比例 std::_Rb_tree::find 函数名 分析Callgrind输出12% pprof --callgrind /bin/ls ls.prof &gt; ls.callgrind% kcachegrind ls.callgrind ## 网址 https://github.com/google/pprof https://zhuanlan.zhihu.com/p/59437135]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7 gv 安装]]></title>
    <url>%2F2019%2F03%2F21%2Fcentos7-gv-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[gv下载123456789101112131415161718192021222324252627282930313233[root@localhost download]# rpm -ivh gv-3.7.4-8.sdl7.x86_64.rpmwarning: gv-3.7.4-8.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYerror: Failed dependencies: /usr/bin/update-desktop-database is needed by gv-3.7.4-8.sdl7.x86_64 libXaw3d.so.8()(64bit) is needed by gv-3.7.4-8.sdl7.x86_64[root@localhost download]# yum install desktop-file-utils......[root@localhost download]# rpm -ivh gv-3.7.4-8.sdl7.x86_64.rpmwarning: gv-3.7.4-8.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYerror: Failed dependencies: libXaw3d.so.8()(64bit) is needed by gv-3.7.4-8.sdl7.x86_64 [root@localhost download]# rpm -ivh Xaw3d-1.6.2-4.sdl7.x86_64.rpmwarning: Xaw3d-1.6.2-4.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYPreparing... ################################# [100%]Updating / installing... 1:Xaw3d-1.6.2-4.sdl7 ################################# [100%][root@localhost download]# rpm -ivh gv-3.7.4-8.sdl7.x86_64.rpmwarning: gv-3.7.4-8.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYPreparing... ################################# [100%]Updating / installing... 1:gv-3.7.4-8.sdl7 ################################# [100%][root@localhost download]# gvgv: Unable to open the display.[root@localhost download]# gv -hUsage: gv [OPTION]... [FILE]PostScript and PDF viewer....]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高性能MySQL 读书笔记]]></title>
    <url>%2F2019%2F03%2F18%2F%E9%AB%98%E6%80%A7%E8%83%BDMySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TODO]]></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解http 读书笔记]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%9B%BE%E8%A7%A3http-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本概念定义HTTP(Hypertext Transfer Protocol) 超文本传输协议, 用HTML超文本标记语言(Hypertext Markup Language)作为创建网页的标准 特点支持客户/服务器模式简单快速：客户向服务器请求服务时，只需传送请求方法和路径, 常用的有GET、HEAD、POST灵活：允许传输任意类型的数据对象, 传输的类型由Content-Type加以标记无连接：限制每次连接只处理一个请求, 处理完后关闭连接无状态：协议对于事务处理没有记忆能力 网络基础HTTP使用的传输层协议为可靠的TCP协议，而网络层使用的是IP协议 URI和URLURI(Uniform Resource Identifier) 统一资源标识符(RFC2396定义), 就是由某个协议方案表示的资源的定位标识符, URL是URI的子集123http://www.rfc.com/rfc/rfc.txtftp://ftp.rfc.com/rfc/rfc.txt...... 简单的HTTP协议 方法 说明 GET 获取资源 POST 传输实际主体 PUT 传输文件 HEAD 获得报文首部 DELETE 删除文件 OPTIONS 询问支持的方法 TRACE 追踪路径 CONNECT 要求用隧道协议链接代理 使用cookie进行状态管理 http报文由报文首部和报文主体组成, 一般CR(Carriage Return 回车符0x0d)+LF(Line Feed 换行符0x0a)来划分 压缩编码常用的内容编码 gzip(GNU zip), compress(UNIX), default(zip), identity(不进行编码) 分块传输from-data, byteranges 内容协商返回服务器驱动(在服务端自动处理)/客户端驱动/透明协商 http状态码状态码类别 类别 原因 1xx 指示信息 接收的请求正在处理 2xx 成功 请求正常处理完毕 3xx 重定向 请求需要进行更进一步操作 4xx 客户端错误 服务器无法处理请求 5xx 服务端错误 服务器处理请求出错 2xx200 ok 请求被正常处理204 no content 请求被正常处理, 不返回任何实体, 浏览器页面不更新206 Partial content 范围请求响应 3xx301 Moved Permanently 永久重定向, 请求资源已被分配了新的URI302 Found 临时重定向, 请求资源已被分配了新的URI, 将来有可能还会发生改变303 See Other 请求对应资源存在另一个URI, 用GET方法定向获取304 Not Modified 客户端发送条件请求, 服务端允许访问资源, 但不满足条件, 返回304, 和重定向无关307 Temporary Redirect 临时重定向, 禁止POST变成GET, 实际取决于浏览器 4xx400 bad request 请求报文语法错误401 unauthorized 需要认证信息403 forbidden 请求资费的访问被拒绝404 not found 服务器上无法找到请求资源 5xx500 internal server err 服务端在执行请求发生了错误503 service unavaliable 服务器无法处理请求, 负载太大或停机 Web服务器代理只是转发请求, 每次代理转发追加Via信息 网关使通信线路上的服务器提供非HTTP协议服务 隧道建立一条与其他服务器通信线路, 使用SSL等加密手段通信 缓存指代理服务器或客户端本地磁盘内保存的副本 http首部https]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bloom Filter概念和原理]]></title>
    <url>%2F2019%2F03%2F18%2FBloom-Filter%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概念和原理布隆过滤器应用场景–查重]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法之美之线性表 笔记]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数组数组Array是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 数组支持随机访问, 通过下标访问的时间复杂度为0(1)。一般用vector容器来替代 为什么下标从0开始, 地址偏移计算 链表单链表 , 双向链表 , 循环链表 字符串回文判断思路: 找到中间节点 后半部分逆序 比较 后半部分恢复 如何轻松正确写出链表 重点留意边界处理 利用哨兵简化实现难度 举例画图, 辅助思考 多写多练, 没有捷径 单链表反转链表中环的检测两个有序的链表合并删除链表倒数第 n 个结点求链表的中间结点 栈用数组实现的栈, 顺序栈; 用链表实现的栈, 链式栈; 操作受限的线性表数据结构 支持动态扩容顺序栈入栈时间复杂度O(1), 有扩容时为O(n) 栈在函数调用中的应用 栈在表达式求值中的应用 栈在括号匹配中的应用 队列先进者先出，这就是典型的“队列”(排队); 操作受限的线性表数据结构用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列 基于链表的队列实现方法 循环队列确定好队空和队满的判定条件, 队空(head == tail), 队满(tail+1)%n=head 阻塞队列和并发队列队列空取数据 或 队列满插入数据 会阻塞; 并发时需要加锁控制轻松实现生产者-消费者模型]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法之美 笔记]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为什么学数据结构和算法 面试大厂, 不让数据结构和算法拖后腿 提高看待问题的深度, 解决问题的角度, 对编程还有追求 如何抓住重点, 系统高效的学习数据结构是为算法服务的，算法要作用在特定的数据结构之上。 首先要掌握复杂度分析 学习套路 来历 -&gt; 原理 -&gt; 解决问题 -&gt; 应用场景 20个最常用的数据结构和算法 建议 边学边练, 适度刷题多问, 多思考反复迭代, 不断沉淀 复杂度分析为什么需要复杂度分析, 而不是通过跑一遍程序统计、监控得到运行时间,内存消耗结果？ 测试结果非常依赖环境(不同环境下结果不同) 测试结果受数据规模影响大 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势, 叫渐近时间复杂度, 简称时间复杂度 分析方法 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 常见案例分析常量阶O(1)123int i = 8;int j = 6;int sum = i + j; 对数阶O(logn) , 线性对数阶O(nlogn)123456 i=1; while (i &lt;= n) &#123; i = i * 2; &#125; // 再执行n遍, 就是O(nlogn) 线性阶O(n) , 平方阶O(n^2), 指数阶O(2^n) 最好情况时间复杂度, 最坏情况时间复杂度, 平均情况时间复杂度, 均摊时间复杂度 均摊时间复杂度就是一种特殊的平均时间复杂度，我们没必要花太多精力去区分它们]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化之网络 笔记]]></title>
    <url>%2F2019%2F03%2F05%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux网络网络模型 OSI七层 功能 协议 应用层 负责为程序提供统一的接口 ftp telnet http dns 表示层 负责把数据转换成兼容接收系统的格式 NULL 会话层 负责维护计算机之间的通信连接 NULL 传输层 负责为数据加上传输表头(包含port), 形成数据包 TCP UDP 网路层 负责数据的路由和转发 IP ICMP IGMP RIP 数据链路层 负责MAC寻址, 错误侦测和改错 ARP RARP MTU PPP 物理层 负责在物理网络中传输数据帧 IEEE802 TCP/IP四层 功能 应用层 负责向用户提供一组应用程序, 比如HTTP/DNS/FTP 传输层 负责端到端的通信, 比如TCP/UDP 网络层 负责网络包的封装、寻址和路哟, 比如IP/ICMP 网络接口层 负责在物理网络中传输数据帧, 比如MAC寻址, 错误侦测和改错 OSI和TCP/IP关系 linux网络栈 TCP头(最长60个字节)UDP头IP头 Linux 通用 IP 网络栈的示意图 性能指标 带宽 表示链路的最大传输,单位为b/s(比特/秒) 吞吐量 单位时间内成功传输的数据量b/s(比特/秒)或B/s(字节/秒), 网络使用率=吞吐量/带宽 延时 网络请求发出后, 收到远端回复包的延迟 PPS packet per second(包/秒), 以网络包为单位的传输速率, 通常用来评估网络转发能力如硬件交换机 另外还有网络的可用性, 并发连接数, 丢包率, 重传率等指标 网络配置123456789101112131415161718192021[root@localhost ~]# ifconfig enp0s3enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.137.20 netmask 255.0.0.0 broadcast 192.255.255.255 inet6 fe80::a00:27ff:fe41:f483 prefixlen 64 scopeid 0x20&lt;link&gt; ether 08:00:27:41:f4:83 txqueuelen 1000 (Ethernet) RX packets 1190 bytes 124844 (121.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1004 bytes 123892 (120.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [root@localhost ~]# ip -s addr show dev enp0s32: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 08:00:27:41:f4:83 brd ff:ff:ff:ff:ff:ff inet 192.168.137.20/8 brd 192.255.255.255 scope global enp0s3 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:fe41:f483/64 scope link valid_lft forever preferred_lft forever RX: bytes packets errors dropped overrun mcast 137456 1311 0 0 0 0 TX: bytes packets errors dropped carrier collsns 134854 1070 0 0 0 0 ifconfig中的RUNNING 和 ip中的LOWER_UP 表示网络物理层是连通的, 即网线插好了 MTU 的大小 网络收发字节数、包数、错误数及丢包情况。详细指标如下 errors 发生错误的数据包数, 比如校验错误, 帧同步错误等 dropped 丢弃的数据包, 数据包已经收到了Ring Buffer, 但内存资源不足原因丢包 overrun 超限数据包数, 网络I/O速度过快, 导致Ring Buffer来不及处理(队列满) carrier 发送carrier错误的数据包数, 比如双工模式不匹配, 物理电缆线出问题等 collsns 碰撞数据包数 套接字信息1234567891011121314151617# head -n 3 表示只显示前面 3 行# -l 表示只显示监听套接字# -n 表示显示数字地址和端口 (而不是名字)# -p 表示显示进程信息$ netstat -nlp | head -n 3Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN 840/systemd-resolve# -l 表示只显示监听套接字# -t 表示只显示 TCP 套接字# -n 表示显示数字地址和端口 (而不是名字)# -p 表示显示进程信息$ ss -ltnp | head -n 3State Recv-Q Send-Q Local Address:Port Peer Address:PortLISTEN 0 128 127.0.0.53%lo:53 0.0.0.0:* users:((&quot;systemd-resolve&quot;,pid=840,fd=13))LISTEN 0 128 0.0.0.0:22 0.0.0.0:* users:((&quot;sshd&quot;,pid=1459,fd=3)) QUEUE LISTEN ESTABLISHED Recv-Q (sync backlog当前值, 当前使用了多少)表示Accept queue中等待被服务器accept() 套接字缓冲区中没有被应用收取的字节数(接受队列长度) Send-Q (sync backlog最大值, 全连接队列长度)即为Accept queue的最大值 还没有被远端主机确认的字节数(发送队列长度) 全连接的大小取决于min(backlog, somaxconn), backlog在创建socket时传入, somaxconn是系统参数半连接的大小取决于max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog), 不同版本会有差异 协议栈信息1234567891011121314151617181920212223242526[root@localhost ~]# netstat -s...Tcp: 0 active connections openings 1 passive connection openings 0 failed connection attempts 0 connection resets received 1 connections established 430 segments received 266 segments send out 0 segments retransmited 0 bad segments received. 0 resets sent... [root@localhost ~]# ss -sTotal: 187 (kernel 204)TCP: 6 (estab 1, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 0Transport Total IP IPv6* 204 - - RAW 0 0 0 UDP 5 3 2 TCP 6 4 2 INET 11 7 4 FRAG 0 0 0 网络吞吐和PPS1234567891011121314151617// 1 表示每隔1秒输出一组数据[root@localhost ~]# sar -n DEV 1Linux 3.10.0-693.el7.x86_64 (localhost.localdomain) 03/05/2019 _x86_64_ (1 CPU)10:06:56 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s10:06:57 PM enp0s3 1.00 1.00 0.06 0.22 0.00 0.00 0.0010:06:57 PM enp0s8 0.00 0.00 0.00 0.00 0.00 0.00 0.0010:06:57 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0010:06:57 PM docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00// rxpck/s 和 txpck/s 分别是接收和发送PPS, 单位为包/秒// rxkB/s 和 txkB/s 分别是接收和发送吞吐量, 单位是KB/秒// rxcmp/s 和 txcmp/s 分别是接收和发送的压缩包数据, 单位是包/秒// %ifutil 网络接口使用率, max(rxkB/s, txkB/s)/Bandwidth// 查看带宽, 如下为千兆网卡[root@localhost ~]# ethtool enp0s8 |grep Speed Speed: 1000Mb/s 连通性和延时1234567891011121314[root@localhost ~]# ping www.baidu.comPING www.a.shifen.com (183.232.231.172) 56(84) bytes of data.64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=1 ttl=49 time=27.1 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=2 ttl=49 time=28.2 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=3 ttl=49 time=28.3 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=4 ttl=49 time=27.6 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=5 ttl=49 time=27.6 ms^C--- www.a.shifen.com ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 22064msrtt min/avg/max/mdev = 27.184/27.833/28.343/0.440 ms// 第一部分是每个ICMP请求信息, 序列号, TTL(生存时间), 以及往返延时// 第二部分是总的统计 C10K 和 C1000K单机处理1W个并发连接请求 I/O模型优化I/O多路复用时, 两种事件通知方式 水平触发 只要文件描述符可以非阻塞的执行I/O, 就会触发通知。应用程序可以随时检查fd的状态,然后根据状态进行I/O操作。 边缘触发 只有在文件描述符状态发生改变时(I/O请求到达), 才会发生一次通知。此时需要应用尽可能多的执行I/O读写, 不及时处理通知就丢失了。 使用非阻塞I/O和水平触发通知(select/poll)都需要对fds进行轮询; 在32位系统中, select描述符最多1024个; 并且, 在select内部检查套接字状态是用轮询, 再加上应用的轮询, 时间复杂度O(n^2). poll对select改进, 使用固定长度的数组, 没有了最大描述符数量的限制; 应用程序还是需要轮询, 处理耗时跟描述符的数量就是O(n)关系. 另外应用程序调用select/poll, 需要把文件描述符集合从用户空间传入内核空间, 由内核空间修改后, 再传出到用户空间, 来回切换处理成本高. 使用非阻塞I/O和边缘触发通知(epoll) epoll使用红黑树在内核管理描述符集合, 应用程序在每次操作时不需要传入传出这个集合 epoll使用时间驱动机制, 只关注事件发生的描述符(就绪链表), 不需要轮询整个集合 使用异步I/O没有经验 工作模型优化 主进程 + 多个worker子进程 监听到相同端口多进程方式(开启SO_REUSEPORT), 只会有1个进程被唤醒 C10M跳过冗长的协议栈处理, 直接把网络包送到应用程序.有如下两种机制 DPDK 用户态网络标准, 跳过内核协议栈, 直接由用户态程序通过轮询来处理网络接收 XDP 允许网络包在进入内核前就进行处理(丢弃,转发,给上层应用) 评估系统网络性能各个协议层的基本测试 转发性能pktgen TCP/UDP性能1234567891011121314151617[root@localhost ~]# yum install -y iperf3# -s 表示启动服务端，-i 表示汇报间隔，-p 表示监听端口[root@localhost ~]# iperf3 -s -i 1 -p 10000# -c 表示启动客户端，192.168.0.30 为目标服务器的 IP# -b 表示目标带宽 (单位是 bits/s)# -t 表示测试时间# -P 表示并发数，-p 表示目标服务器监听端口[root@localhost ~]# iperf3 -c 127.0.0.1 -b 1G -t 15 -P 2 -p 10000[ ID] Interval Transfer Bandwidth Retr[ 4] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec 0 sender[ 4] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec receiver[ 6] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec 0 sender[ 6] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec receiver[SUM] 0.00-15.00 sec 3.48 GBytes 1.99 Gbits/sec 0 sender[SUM] 0.00-15.00 sec 3.48 GBytes 1.99 Gbits/sec receiver 从测试结果看带宽(吞吐量)超出预期1Gb/s HTTP性能ab 应用负载性能wk 总结 应用层 用wrk,Jmeter 传输层 iperf/netperf 再向下 pktgen DNS解析时快时慢域名与DNS解析DNS服务通过资源记录的方式, 管理数据 A记录 用来把域名转换成IP地址 CNAME记录 用来创建别名 NS记录 表示该域名对应的域名服务器地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@localhost ~]# cat /etc/resolv.conf; generated by /usr/sbin/dhclient-scriptnameserver 10.70.75.253[root@localhost ~]# yum install -y bind-utils[root@localhost ~]# nslookup time.geekbang.orgServer: 10.70.75.253Address: 10.70.75.253#53Non-authoritative answer:Name: time.geekbang.orgAddress: 39.106.233.176[root@localhost ~]# dig +trace +nodnssec time.geekbang.org; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-73.el7_6 &lt;&lt;&gt;&gt; +trace +nodnssec time.geekbang.org;; global options: +cmd. 518400 IN NS m.root-servers.net.. 518400 IN NS c.root-servers.net.. 518400 IN NS i.root-servers.net.. 518400 IN NS d.root-servers.net.. 518400 IN NS j.root-servers.net.. 518400 IN NS e.root-servers.net.. 518400 IN NS l.root-servers.net.. 518400 IN NS g.root-servers.net.. 518400 IN NS h.root-servers.net.. 518400 IN NS f.root-servers.net.. 518400 IN NS k.root-servers.net.. 518400 IN NS b.root-servers.net.. 518400 IN NS a.root-servers.net.;; Received 239 bytes from 10.70.75.253#53(10.70.75.253) in 46 msorg. 172800 IN NS a0.org.afilias-nst.info.org. 172800 IN NS a2.org.afilias-nst.info.org. 172800 IN NS b0.org.afilias-nst.org.org. 172800 IN NS b2.org.afilias-nst.org.org. 172800 IN NS c0.org.afilias-nst.info.org. 172800 IN NS d0.org.afilias-nst.org.;; Received 448 bytes from 199.7.91.13#53(d.root-servers.net) in 426 msgeekbang.org. 86400 IN NS dns10.hichina.com.geekbang.org. 86400 IN NS dns9.hichina.com.;; Received 96 bytes from 199.19.56.1#53(a0.org.afilias-nst.info) in 106 mstime.geekbang.org. 600 IN A 39.106.233.176;; Received 62 bytes from 106.11.211.56#53(dns10.hichina.com) in 40 ms 可以把主机名和IP地址对应关系, 写入到本机/ect/hosts中, 指定的主机名可以直接找到IP123456789101112[root@localhost ~]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6[root@localhost ~]# ping localhost4PING localhost (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.041 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.066 ms^C--- localhost ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 999msrtt min/avg/max/mdev = 0.041/0.053/0.066/0.014 ms 案例 DNS 未配置在/etc/resolve.conf 导致找到域名服务器 1234可以ping通IP, ping域名失败# nslookup -debug time.geekbang.org;; Connection to 127.0.0.1#53(127.0.0.1) for time.geekbang.org failed: connection refused.;; Connection to ::1#53(::1) for time.geekbang.org failed: address not available. DNS不稳定 12345678910111213# time nslookup time.geekbang.org;; connection timed out; no servers could be reached real 0m15.011suser 0m0.006ssys 0m0.006s$ ping -c3 8.8.8.8PING 8.8.8.8 (8.8.8.8): 56 data bytes64 bytes from 8.8.8.8: icmp_seq=0 ttl=30 time=134.032 ms64 bytes from 8.8.8.8: icmp_seq=1 ttl=30 time=431.458 ms延时太大导致 小结DNS优化方法 对DNS结果进行缓存 对DNS解析的结果进行预取 使用HTTPDNS代替常规的DNS解析, 避免域名劫持 基于DNS的全局负载均衡(GSLB), 根据用户位置返回距离最近的IP tcpdump和wireshark 分析网络流量略过 如何缓解DDos攻击带来的性能下降DDoS 的前身是 DoS（Denail of Service），即拒绝服务攻击，指利用大量的合理请求，来占用过多的目标资源，从而使目标服务无法响应正常请求。DDoS（Distributed Denial of Service） 则是在 DoS 的基础上，采用了分布式架构，利用多台主机同时攻击目标主机。 攻击原理 耗尽带宽 耗尽操作系统的资源 消耗应用程序的运行资源 案例模拟 优化 iptables 限制 修改半连接数量限制 开启 TCP SYN Cookies, 基于连接信息（包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie 小结在 Linux 服务器中，你可以通过内核调优、DPDK、XDP 等多种方法，来增大服务器的抗攻击能力，降低 DDoS 对正常服务的影响。而在应用程序中，你可以利用各级缓存、 WAF、CDN 等方式，缓解 DDoS 对应用程序的影响。 网络延迟变大]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统 笔记]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化之磁盘文件 笔记]]></title>
    <url>%2F2019%2F02%2F28%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文件系统 磁盘为系统提供了最基本的持久化存储文件系统则在磁盘的基础上, 提供了一个用来管理文件的树状结构 索引节点和目录 索引节点(inode), 用来记录文件的元数据, 比如inode编号, 文件大小, 访问权限修改日期, 数据位置等。它和文件一一对应, 跟文件内容一样, 会被持久化到磁盘, 也会占磁盘空间 目录项(dentry), 用来记录文件名字, 索引节点指针以及和其他目录项的关系。多个关联目录项构成文件系统的目录结构, 由内存维护的内存数据结构, 也叫目录缓存 磁盘格式化时被分为三个区 超级块, 存储整个文件系统的状态 索引节点区, 存储inode 数据存储区, 存储文件数据 虚拟文件系统linux系统文件系统四大基本要素, 目录项/索引节点/超级块/数据块区为支持不同文件系统, linux内核在用户进程和文件系统之间, 抽象出了一层虚拟文件系统(VFS)。VFS定义了一组所有文件系统都支持的数据结构和标准接口。 文件系统I/OVFS提供了一组文件访问接口。文件读写I/O的四种方式分类, 缓冲/非缓冲, 直接/非直接, 阻塞/非阻塞, 同步/异步 缓冲IO, 利用标准库缓存来加速文件访问, 标准库内部通过系统调度来访问文件(printf遇到换行符输出)非缓冲IO, 直接通过系统调用来访问文件, 不再经过标准库缓存 直接IO, 跳过操作系统页缓存, 直接和文件系统交互访问文件(数据库写)非直接IO, 文件读写时, 先要经过系统的页缓存, 再由内核或系统写入磁盘 阻塞IO, 执行操作后没有获得响应, 阻塞当前线程, 不会执行其他任务(管道或网络套接字O_NONBLOCK)非阻塞IO, 执行操作后不会阻塞当前线程, 可以执行其他程序, 通过轮询获取响应结果(select/poll) 同步IO, 执行IO操作后, 一直等到整个IO完成后, 才获得结果响应(O_SYNC文件数据和元数据写入磁盘)异步IO, 执行IO操作后, 不用等待完成和完成后响应, 可以继续执行。IO完成后通过事件方式通知应用程序 阻塞和非阻塞/同步和异步 是从两个不同角度划分, 描述的对象也不同, 分别是应用程序和系统。 查看工具12345678910111213141516171819202122232425[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 7.5G 9.5G 44% /devtmpfs 486M 0 486M 0% /devtmpfs 497M 0 497M 0% /dev/shmtmpfs 497M 6.6M 490M 2% /runtmpfs 497M 0 497M 0% /sys/fs/cgroup/dev/sda1 1014M 142M 873M 14% /boottmpfs 100M 0 100M 0% /run/user/0[root@localhost ~]# df -ihFilesystem Inodes IUsed IFree IUse% Mounted on/dev/mapper/centos-root 8.5M 101K 8.4M 2% /devtmpfs 122K 361 122K 1% /devtmpfs 125K 1 125K 1% /dev/shmtmpfs 125K 422 124K 1% /runtmpfs 125K 16 125K 1% /sys/fs/cgroup/dev/sda1 512K 328 512K 1% /boottmpfs 125K 1 125K 1% /run/user/0// 索引节点占磁盘容量, 在磁盘格式化时生成好的。磁盘空间充足, 索引节点空间不足 // 可能是小文件过多导致// 内核使用 Slab 机制，管理目录项和索引节点的缓存 cat /proc/slabinfo | grep -E &apos;^#|dentry|inode&apos; 总结为了降低慢速磁盘对性能的影响, 文件系统通过页缓存, 目录项缓存以及所有节点缓存,缓和磁盘延迟对应用的影响 磁盘I/O磁盘磁盘是持久化存储设备, 根据存储介质不同, 分为机械磁盘和固态磁盘.机械磁盘的最小读写扇区, 一般大小为512字节; 固态磁盘的最小读写单位是页, 通常大小是4K/8K 磁盘按接口分类, IDE/SCSI/SAS/SATA/FC. 不同接口分配不同设备名称, IDE-&gt;hd, SCSI/SATA-&gt;sd有多块同类型的磁盘时, 会按a,b,c等字母数序来编号 磁盘根据需要, 分为不同的区, 如/dev/sda1, /dev/sda2 另一种比较常用的架构, 磁盘阵列(RAID); 或者网络存储集群, 通过NFS, SMB, ISCSI等网络存储协议暴露给服务器使用。 通用块层在linux中, 磁盘作为一个块设备来管理. 为了减少不同块设备差异带来的影响, linux通过一个统一的通用块层来管理, 处于磁盘驱动和文件系统之间的一个块设备抽象层. 主要功能： 向上, 为文件系统和应用提供标准接口; 向下, 把各种异构块设备抽象, 提供统一框架管理对I/O请求排序合并, 提高磁盘读写效率 I/O栈 文件系统层, 包括VFS和其他文件系统的具体体现,提供标准接口访问文件 通用块层, 包括块设备I/O队列和I/O调度器, 对I/O请求排序合并, 然后发送给下一层设备 设备层, 包括存储设备和相应驱动程序, 负责最终物理设备的I/O操作 磁盘性能指标 使用率, 磁盘处理I/O的时间百分比饱和度, 磁盘I/O的繁忙程度, 100%时无法再接受新的请求IOPS, 每秒I/O请求数吞吐量, 每秒的I/O请求大小响应时间, I/O请求从发出到收到响应的时间间隔 查看工具iostat-&gt;iotop-&gt;pidstat1234567891011[root@localhost ~]# iostat -d -x 1Linux 3.10.0-693.el7.x86_64 (localhost) 03/04/2019 _x86_64_ (1 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilsda 0.00 0.01 0.28 0.11 15.38 1.14 83.63 0.00 11.81 8.90 19.28 2.47 0.10dm-0 0.00 0.00 0.26 0.11 14.69 1.04 84.72 0.00 11.39 7.51 20.90 1.93 0.07dm-1 0.00 0.00 0.01 0.00 0.19 0.00 55.94 0.00 36.47 36.47 0.00 34.90 0.02// await 平均每次设备 I/O 操作的等待时间(毫秒)// avgqu-sz 平均 I/O 队列长度// avgrq-sz 平均每次设备 I/O 操作的数据大小(扇区) util% 磁盘I/O使用率 r/s+w/s IOPS rkB/s+wkB/s 是吞吐量 r_await+w_await 12345678[root@localhost ~]# pidstat -d 1Linux 3.10.0-693.el7.x86_64 (localhost) 03/04/2019 _x86_64_ (1 CPU)07:45:24 AM UID PID kB_rd/s kB_wr/s kB_ccwr/s CommandkB_rd/s: 每秒进程从磁盘读取的数据量(以kB为单位)kB_wr/s: 每秒进程向磁盘写的数据量(以kB为单位)Command: 拉起进程对应的命令 案例分析：找出不停打印进程top：cpu的wa很高iostat: util% IO使用率高, 请求队列长pidstat -d : 找出进程, 理解应该用iotopstrace -pf pid :f 跟踪由fork调用所产生的子进程 , 确认具体调用系统函数lsof -p : 查看打开的文件 进程I/O高, 直接top+lsof解决 案例分析：sql执行慢12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758top+ iostat+ pidstat 确定mysql慢$ lsof -p 28014// 上一条命令退出时的返回值, 0表示成功, 1表示失败$ echo $?1// -t 表示显示线程，-a 表示显示命令行参数$ pstree -t -a -p 27458mysqld,27458 --log_bin=on --sync_binlog=1... ├─&#123;mysqld&#125;,27922 ├─&#123;mysqld&#125;,27923 └─&#123;mysqld&#125;,28014// lsof 需要进程号$ lsof -p 27458COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME...​mysqld 27458 999 38u REG 8,1 512440000 2601895 /var/lib/mysql/test/products.MYD// strace 确定在做什么$ strace -f -p 27458[pid 28014] read(38, &quot;934EiwT363aak7VtqF1mHGa4LL4Dhbks&quot;..., 131072) = 131072[pid 28014] read(38, &quot;hSs7KBDepBqA6m4ce6i6iUfFTeG9Ot9z&quot;..., 20480) = 20480[pid 28014] read(38, &quot;NRhRjCSsLLBjTfdqiBRLvN9K6FRfqqLm&quot;..., 131072) = 131072[pid 28014] read(38, &quot;AKgsik4BilLb7y6OkwQUjjqGeCTQTaRl&quot;..., 24576) = 24576[pid 28014] read(38, &quot;hFMHx7FzUSqfFI22fQxWCpSnDmRjamaW&quot;..., 131072) = 131072[pid 28014] read(38, &quot;ajUzLmKqivcDJSkiw7QWf2ETLgvQIpfC&quot;..., 20480) = 20480// 显示mysql使用目录, 只是为了进一步确认$ docker exec -i -t mysql mysql -e &apos;show global variables like &quot;%datadir%&quot;;&apos;+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| datadir | /var/lib/mysql/ |+---------------+-----------------+mysql&gt; show full processlist;+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+| Id | User | Host | db | Command | Time | State | Info |+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+| 27 | root | localhost | test | Query | 0 | init | show full processlist || 28 | root | 127.0.0.1:42262 | test | Query | 1 | Sending data | select * from products where productName=&apos;geektime&apos; |+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+2 rows in set (0.00 sec)# 切换到 test 库mysql&gt; use test;# 执行 explain 命令mysql&gt; explain select * from products where productName=&apos;geektime&apos;;+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+| 1 | SIMPLE | products | ALL | NULL | NULL | NULL | NULL | 10000 | Using where |+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+1 row in set (0.00 sec) /var/lib/mysql/test的4个文件： MYD 存储表的数据 MYI 存储表的索引 frm 存储表的元信息(表结构) opt 存储数据库的元信息(字符集) 没用索引….(top+strace) 另外, opensnoop监控打开文件 案例分析: redis慢写文件慢(top+strace) 系统I/O瓶颈分析套路linux系统I/O栈 iostat 发现磁盘IO瓶颈-&gt;pidstat确认进程, 分析读写-&gt;strace/lsof分析应用程序 I/O性能优化应用程序优化 1.用追加写代替随机写, 减少寻址开销, 加快I/O写的速度 2.借助缓存I/O, 充分利用系统缓存, 降低实际I/O的次数(mysql的MyISAM,查询依赖缓存) 3.在应用程序内部构建自己的缓存, 控制缓存数据和生命周期(批价mdb_cache) 4.频繁读写同一块磁盘, mmap代替, 减少读写次数(直接I/O) 5.在需要同步写的场景中, 尽量将写请求合并, fsync()代替O_SYNC(mdb一次提交N条数据) 6.在多个应用程序共享磁盘时, 为保证I/O不被一个进程独占, 可以使用cgroups的I/O子系统来限制进程/进程组的IOPS和吞吐量 7.在使用CFQ调度器时, ionice调整进程I/O优先级, 提高核心应用的优先级 1234567ionice -p 25089 -c 2 -n 7使用 ionice 之前查一下帮助文件，-c 是指定调度类型，这里选择的是 2，best-effort； -n 指定调度优先级，0 最高，7最低；-p 是指定进程号OPTIONS-c The scheduling class. 1 for real time, 2 for best-effort, 3 foridle.... 文件系统优化 1.选择合适的文件系统, 如xfs比ext4支持更大的磁盘分区和文件数, 支持大于16T的磁盘 2.优化文件系统的配置, 文件系统特性/日志模式/挂载选项(tune2fs 查看文件系统超级块) 3.优化文件系统缓存, /proc/sys/vm/vfs_cache_pressure 优化内核回收目录项缓存和索引节点缓存 4.利用tmpfs内存文件系统, 获得更好的I/O性能 磁盘优化 1.SSD替代HDD 2.利用RAID磁盘阵列 3.选择合适的I/O调度算法, SSD和虚拟机的磁盘一般用noop算法, 数据库一般使用deadline算法 4.磁盘隔离, 为I/O压力重的应用配置单独磁盘, 如数据库,日志 5.在顺序读较多的场景中, 增大磁盘的预读数据配置 6.优化内核设备I/O选项, 例如增加队列长度, 提高吞吐(I/O延迟可能增大) 123查看当前系统的I/O调度方法:cat /sys/block/sda/queue/schedulernoop anticipatory deadline [cfq]]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化之内存 笔记]]></title>
    <url>%2F2019%2F02%2F27%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux内存工作原理linux内核给每个进程提供了一个独立的虚拟地址空间, 并且这个地址空间是连续的。 内存映射虚拟地址空间分为内核空间和用户空间, 常见的32位和64位虚拟地址空间如下： 内存映射, 就是将虚拟内存地址映射到物理内存地址。内核为每个进程都维护一张页表, 记录映射关系： 页表实际存储在内存管理单元MMU中, 这样处理器直接通过硬件找出访问的内存。当进程访问虚拟地址在页表中查不到时, 会产生缺页异常, 进入内核空间分配物理内存, 更新进程页表, 最后返回用户空间, 恢复进程。 MMU最小单位4KB, 每次内存映射4KB或4KB的整数倍。 linux通过多级页表和大页两种机制来管理页表。 虚拟内存空间分布 C程序内存分布：1.程序段:程序段为程序代码在内存中的映射.一个程序可以在内存中多有个副本.2.初始化过的数据:在程序运行值初已经对变量进行初始化的3.未初始化过的数据:在程序运行初未对变量进行初始化的数据4.堆(stack):存储局部,临时变量,在程序块开始时自动分配内存,结束时自动释放内存.存储函数的返回指针.5.栈(heap):存储动态内存分配,需要程序员手工分配,手工释放. 虚拟内存参考 内存分配和回收小于128K用brk()分配, 否则用mmap()在文件映射段找一块内存分配。brk在释放时不会还给系统,缓存起来重复利用, 会产生内存碎片。mmap频繁会产生大量缺页异常, 内核管理负担增大。 系统在内存紧张时回收机制, LRU/SWAP/OOM 12$ dmesg | grep -i &quot;Out of memory&quot;Out of memory: Kill process 9329 (java) score 321 or sacrifice child 查看内存free/top/ps SHR 并不一定是共享的, 包括程序代码段, 非共享链接库 内存中的Buffer和cache定义Buffer-&gt;磁盘数据缓冲区, cache-&gt;文件数据缓存 用以下案例, vmstat 观察1234567891011121314151617// 首先清理缓存$ echo 3 &gt; /proc/sys/vm/drop_caches// 写文件$ dd if=/dev/urandom of=/tmp/file bs=1M count=500// 写磁盘, 相当于清磁盘// 然后运行 dd 命令向磁盘分区 /dev/sdb1 写入 2G 数据$ dd if=/dev/urandom of=/dev/sdb1 bs=1M count=2048// 读文件// 运行 dd 命令读取文件数据$ dd if=/tmp/file of=/dev/null// 读磁盘// 运行 dd 命令读取文件$ dd if=/dev/sda1 of=/dev/null bs=1M count=1024 123456789101112131415手动释放缓存区内存的方法1）清理pagecache（页面缓存）[root@backup ~]# echo 1 &gt; /proc/sys/vm/drop_caches 或者 sysctl -w vm.drop_caches=1 2）清理dentries（目录缓存）和inodes[root@backup ~]# echo 2 &gt; /proc/sys/vm/drop_caches 或者 sysctl -w vm.drop_caches=2 3）清理pagecache、dentries和inodes[root@backup ~]# echo 3 &gt; /proc/sys/vm/drop_caches 或者 sysctl -w vm.drop_caches=3 上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置： vm.drop_caches=1/2/3，然后sysctl -p生效即可！ 另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存[root@backup ~]# sync 查看工具BCC cachestat: 系统缓存命中情况cacheop: 进程缓存命中情况 centos上安装相当不方便 内存泄漏排查和优化valgrind/memleak/ 存在需要大量内存场景, 考虑栈内存或者内存池, 大页来优化内存分配管理 valgrind/mtrace/dmalloc/ccmalloc/memwatch/debug_new Swap交换分区原理说明内存紧张时, linux通过直接回收和定期扫描方式, 来释放文件页和内存页, 把内存分配给更需要的进程： 文件页直接清空, 或写回磁盘后释放缓存 匿名页需要通过swap换入换出 内核有个专门的线程来定期回收内存, kswapd0 阀值通过 /proc/zeroinfo 来查看, 通过/proc/sys/vm/min_free_kbytes 设置回收阀值 系统内存有剩余, 还是使用了swap。NUMA架构下, CPU分到不同的node上, 每个node有自己的本地空间。 查看工具12345678910111213141516171819202122232425262728293031[root@localhost ~]# numactl --hardwareavailable: 1 nodes (0)node 0 cpus: 0node 0 size: 1023 MBnode 0 free: 174 MBnode distances:node 0 0: 10 // 系统只有一个node, 内存大小1023M, 剩余174M[root@localhost ~]# cat /proc/zoneinfoNode 0, zone DMA pages free 1209 min 176 low 220 high 264 scanned 0 spanned 4095 present 3998 managed 3977 nr_free_pages 1209 nr_alloc_batch 44 nr_inactive_anon 462 nr_active_anon 332 nr_inactive_file 1476// free 剩余内存页, 同nr_free_pages// nr_active_anon/nr_inactive_anon 活跃和匿名内存页// nr_inactive_file 非活跃文件页// 当node内存不足, 从其他node寻找空闲内存, 或从本地内存回收。// 调整 /proc/sys/vm/zone_reclaim_mode 设置内存回收策略 /proc/sys/vm/swappiness 调整使用Swap的积极程度(范围0～100), 设置成0,当剩余内存 + 文件页小于页高阀值, 还是会发生swap 案例分析1234567891011121314151617// 写入空设备，实际上只有磁盘的读请求$ dd if=/dev/sda1 of=/dev/null bs=1G count=2048// S 显示swap使用情况[root@localhost ~]# sar -r -S 1Linux 3.10.0-693.el7.x86_64 (localhost.localdomain) 02/28/2019 _x86_64_ (1 CPU)03:56:49 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty03:56:50 AM 170920 845312 83.18 0 629936 364252 11.71 197604 523108 003:56:49 AM kbswpfree kbswpused %swpused kbswpcad %swpcad03:56:50 AM 2092556 496 0.02 40 8.06// 关闭swapswapoff -a// 清空swapswapoff -a &amp;&amp; swapon -a 内存分析套路]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[virtualbox网络设置]]></title>
    <url>%2F2019%2F02%2F25%2Fvirtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[CentOS网络配置说明12345678910111213141516171819202122232425262728293031323334353637# 网络类型：Ethernet以太网TYPE=Ethernet # MAC地址，ip addr 查看HWADDR=08:00:27:a7:93:d6# 引导协议：自动获取、static静态、none不指定 BOOTPROTO=none # 启动默认路由 DEFROUTE=yes # 不启用IPV4错误检测功能 IPV4_FAILURE_FATAL=no # 启用IPV6协议 IPV6INIT=yes # 自动配置IPV6地址 IPV6_AUTOCONF=yes# 启用IPV6默认路由 IPV6_DEFROUTE=yes# 不启用IPV6错误检测功能IPV6_FAILURE_FATAL=no# 网卡设备的别名NAME=eno16777736# 网卡设备的UUID唯一标识号 UUID=90528772-9967-46da-b401-f82b64b4acbc# 开机自动激活网卡 ONBOOT=yes # 网卡的IP地址IPADDR=192.168.1.199 # 子网掩码的位数, 如 NETMASK=255.255.255.0 和 PREFIX=24 的作用是一样的，PREFIX优先起作用 PREFIX=24 # 默认网关IP地址GATEWAY=192.168.1.1 # 子网掩码，不需要修改NETMASK=255.255.255.0IPV6_PEERDNS=yes IPV6_PEERROUTES=yes # DNS域名解析服务器的IP地址DNS1=6.6.6.6 DNS2=6.6.6.6 历史方案虚拟机可以访问网络, 和宿主机可以相互访问 环境vbox: 版本 5.2.linux: Centos7笔记本使用办公室有线网络 vbox配置 管理-&gt;主机网络管理-&gt;不启用dhcp, 设置虚拟网关 管理-&gt;全局设置-&gt;网络 设置-&gt;网络-&gt;网卡1-&gt;网卡2 宿主机网络共享 centos配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s3TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static#BOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s3UUID=cf96977f-80a6-4fb6-a68d-0a8836ee8287DEVICE=enp0s3ONBOOT=yesPREFIXO0=24IPADDR=192.168.137.20NETMASK=255.255.255.0PREFIX=8GATEWAY=192.168.137.1DNS1=10.1.1.8 // 需要和宿主机的DNS一致#DNS2=10.70.180.80DNS2=8.8.8.8[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s8TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=no#BOOTPROTO=staticBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s8UUID=f0095258-92b9-3ea4-bcb7-5f9eee4eda2b // nmcli con show 找到UUID(NetworkManager)DEVICE=enp0s8ONBOOT=yesPREFIXO0=24#IPADDR=192.168.137.20#NETMASK=255.255.255.0PREFIX=8#GATEWAY=192.168.137.1#DNS1=10.70.75.253#DNS2=10.70.180.80#DNS2=8.8.8.8DWADDR=08:00:27:09:ac:45 // ip add 找到MAC地址// 默认使用enp0s8[root@localhost ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.0.3.2 0.0.0.0 UG 0 0 0 enp0s810.0.3.0 0.0.0.0 255.255.255.0 U 0 0 0 enp0s8169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 enp0s3169.254.0.0 0.0.0.0 255.255.0.0 U 1003 0 0 enp0s8192.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 enp0s3[root@localhost ~]# cat /etc/resolv.conf; generated by /usr/sbin/dhclient-scriptnameserver 10.70.75.253nameserver 10.70.180.80nameserver 10.70.75.253nameserver 10.70.180.80search localdomain[root@localhost ~]# ifconfigenp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.137.20 netmask 255.0.0.0 broadcast 192.255.255.255 inet6 fe80::a00:27ff:fe41:f483 prefixlen 64 scopeid 0x20&lt;link&gt; ether 08:00:27:41:f4:83 txqueuelen 1000 (Ethernet) RX packets 316 bytes 33319 (32.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 212 bytes 41130 (40.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0enp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.0.3.15 netmask 255.255.255.0 broadcast 10.0.3.255 inet6 fe80::a00:27ff:fe09:ac45 prefixlen 64 scopeid 0x20&lt;link&gt; ether 08:00:27:09:ac:45 txqueuelen 1000 (Ethernet) RX packets 70 bytes 8437 (8.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 89 bytes 8116 (7.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 问题enp0s8 如果没有自动生成配置文件, 手工添加;更换网络后, 注意DNS也对应更改下; 原主机网络设备管理 网络地址转换NAT环境vbox: 版本 6.1linux: Centos7 vbox 配置 CentOS配置 桥接网卡vbox设置 CentOS配置 1234567891011121314151617[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s3 TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="dhcp"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="enp0s3"UUID="2bf83a8e-995a-4734-bd5c-3fa287976897"DEVICE="enp0s3"ONBOOT="yes"[root@localhost ~]#]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化 笔记]]></title>
    <url>%2F2019%2F02%2F20%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 序Linux 资源可能会碰到的性能问题，包括CPU性能、磁盘IO、内存以及网络性能 鸡汤提神：”想要得到你就要学会付出，要付出还要坚持；如果你真的觉得很难，那你就放弃，如果你放弃了就不要抱怨。人生就是这样，世界是平衡的，每个人都是通过自己的努力，去决定自己生活的样子” 总结鸡汤可以调整心态续命; 学习要会抓重点 第二章 目录性能分析，其实就是找出应用或系统的瓶颈，并设法去避免或者缓解，更高效的利用资源处理更多的请求。 性能分析套路: 选择指标评估应用程序和系统性能 为应用程序和系统设置性能目标 进行性能基准测试 性能分析定位瓶颈 优化系统和应用程序 性能监控和告警 建立整体系统性能的全局观是最核心, 工具图谱和学习思维导图, 以及几个学习小技巧 总结要学会思维导图整理思路 第三章 平均负载什么是平均负载平均负载, 是指在单位时间内, 系统处于可运行和不可中断状态的平均进程数, 也就是平均活跃进程。与CPU的使用率并没有直接的关系。 在 sched/loadavg.c 中计算平均值的算法为EMA，这种算法的目的主要是“距离目标预测窗口越近，则数据的价值越高，对未来影响越大” linux下进程有五种状态, 可运行状态是指在使用CPU或在等待CPU队列中的进程, 用PS可以看到R状态。不可中断状态进程是指正处于内核关键流程中的进程, 并且这些流程是不可打断的, 比如等待I/O响应（Uninterruptible Sleep，也称为Disk sleep)PS看到的D状态。 不可中断状态是系统对进程和硬件的一种保护机制。比如在写磁盘数据时，为了保证一致性, 必须等待磁盘响应。 可以用man查看uptime的说明, uptime看到的是活跃进程数的衰减平均值 平均负载为多少时合理 查看CPU个数 lscpu 或者 grep ‘model name’ /proc/cpuinfo | wc -linux下进程有五种状态 uptime 分析系统负载趋势, 1分钟的值&gt; 5分钟的值&gt; 15分钟的值 说明负载在增加, 如果是4个CPU,平均负载是1, 说明CPU有75%的空闲 案例一个单CPU的平均负载1.73, 0.60, 7.98, 整体趋势看, 负载在降低 平均负载与 CPU 使用率CPU使用率, 是单位时间内CPU的繁忙情况。平均负载统计是包括了等待CPU和等待I/O的进程。所以平均负载高, cpu使用率不一定高。 stress CPU压测工具mpstat 多核CPU性能分析工具, 实时查看CPU指标pidstat 进程性能分析工具, 实时查看进程CPU、内存、IO情况、上下问切换等指标 平均负载案例分析 场景一：CPU密集型进程 12345678910111213141516171819202122[root@zhangbb ~]# stress --cpu 1 --timeout 600stress: info: [2089] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd[root@zhangbb ~]# uptime 16:09:48 up 209 days, 5:29, 8 users, load average: 1.03, 0.41, 0.40[root@zhangbb ~]# mpstat 1 60Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:09:32 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle04:09:33 PM all 99.01 0.00 0.00 0.00 0.00 0.00 0.99 0.00 0.00 0.0004:09:34 PM all 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0004:09:35 PM all 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00[root@zhangbb ~]# pidstat -u 1 1Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:16:35 PM UID PID %usr %system %guest %CPU CPU Command04:16:36 PM 0 455 0.99 0.00 0.00 0.99 0 rsyslogd04:16:36 PM 0 2090 97.03 0.00 0.00 97.03 0 stress04:16:36 PM 0 28600 0.99 0.99 0.00 1.98 0 pritunl04:16:36 PM 992 28606 0.99 0.00 0.00 0.99 0 mongod 场景二：I/O密集型进程 123456789101112131415161718192021222324252627// 一个进程不停的sync[root@zhangbb ~]# stress -i 1 --timeout 600stress: info: [3110] dispatching hogs: 0 cpu, 1 io, 0 vm, 0 hdd[root@zhangbb ~]# uptime 16:19:34 up 209 days, 5:39, 8 users, load average: 5.41, 6.15, 3.59//虚拟机，缓冲区可能比较小，无法产生大的IO压力，这样大部分就都是系统调用的消耗了//使用下一代stress-ng，它支持更丰富的选项，比如 stress-ng -i 1 --hdd 1 --timeout 600（--hdd表示读写临时文件）[root@zhangbb ~]# mpstat 1 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:20:15 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle04:20:16 PM all 2.33 0.00 77.91 19.77 0.00 0.00 0.00 0.00 0.00 0.0004:20:17 PM all 2.27 0.00 77.27 19.32 0.00 0.00 1.14 0.00 0.00 0.0004:20:18 PM all 3.33 0.00 76.67 20.00 0.00 0.00 0.00 0.00 0.00 0.00Average: all 2.65 0.00 77.27 19.70 0.00 0.00 0.38 0.00 0.00 0.00[root@zhangbb ~]# pidstat -u 1 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:19:50 PM UID PID %usr %system %guest %CPU CPU Command04:19:51 PM 0 253 0.00 5.56 0.00 5.56 0 kworker/0:1H04:19:51 PM 0 3111 1.11 76.67 0.00 77.78 0 stress04:19:51 PM 0 20180 0.00 1.11 0.00 1.11 0 kworker/u2:004:19:51 PM 0 28600 2.22 0.00 0.00 2.22 0 pritunl04:19:51 PM 992 28606 1.11 0.00 0.00 1.11 0 mongod 场景三：大量进程场景 12stress -c 8 --timeout进程数超过CPU， uptime + mpstat + pidstat看平均负载 ==&gt; 分析CPU使用场景 ==&gt; 确定具体进程 总结要会分析CPU使用典型场景, 这章只是为了说明平均负载 第四章 CPU上下文切换CPU寄存器是CPU内置的容量小、但速度极快的内存。程序计数器用来存储CPU正在执行的指令位置、或者即将执行下一条指令的位置。以上两个是CPU运行任务前依赖的环境, 也被称为CPU上下文。切换就是保存和加载新的任务上下文到CPU寄存器和计数器。 根据任务的不同, CPU上下文切换分为几个场景, 进程、线程、中断上下文切换。系统调用通常称为特权模式的切换，而不是上下文切换。实际上，系统调用过程中,CPU上下文切换是无法避免的。 进程上下文切换一个进程切换到另一个进程, 在进程调度的时候发生。linux为每个CPU维护一个就绪队列将活跃进程按照优先级和CPU排序时间排序, 选择优先级高或等待CPU时间最长的进程运行。 进程调度场景： 为保证所有进程公平调度, CPU时间被划分为一段段的时间片，被轮流分配给各个进程。时间片耗尽,进程被挂起, 切换到其他正在等待CPU的进程。 进程资源不足, 挂起, 运行其他进程 sleep挂起 有优先级高的进程 发生硬件中断, 挂起, 执行内核中中断服务程序 线程上下文切换线程和进程最大的区别在于, 线程是调度的基本单位, 进程则是资源拥有的基本单位。内核调度对象实际是线程, 进程给线程提供了虚拟内存、全局变量等资源。 同个进程的线程上下文切换，因为虚拟内存共享, 只需要切换线程私有数据, 寄存器等不共享数据。 硬件中断上下文切换有限级最高 总结明白原理, 要能说得上来 第五章 上下文切换分析实践系统上下文切换123456789[root@zhangbb ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st29 0 0 72276 11420 436708 0 0 1 7 1 1 0 0 99 0 0// cs(context switch) 每秒上下文切换// in(interrupt) 每秒中断次数// r(Running or Runnable) 就绪队列的长度, 正在运行和等待的CPU进程数// b(Block) 处于不可中断状态睡眠的进程数 进程上下文切换12345678910111213141516171819[root@zhangbb ~]# pidstat -w 1Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/21/2019 _x86_64_ (1 CPU)02:14:40 PM UID PID cswch/s nvcswch/s Command02:14:42 PM 0 3 3.92 0.00 ksoftirqd/002:14:42 PM 0 9 13.73 0.00 rcu_sched02:14:42 PM 0 10 0.98 0.00 watchdog/002:14:42 PM 0 253 0.98 0.00 kworker/0:1H02:14:42 PM 0 336 1.96 0.00 systemd-journal02:14:42 PM 0 846 0.98 0.00 php-fpm02:14:42 PM 0 1028 0.98 0.00 kworker/0:002:14:42 PM 0 1494 8.82 0.00 kworker/0:102:14:42 PM 0 1778 0.98 0.98 pidstat02:14:42 PM 0 16712 0.98 0.00 kworker/u2:002:14:42 PM 0 28600 0.98 0.00 pritunl02:14:42 PM 0 29204 1.96 0.00 dockerd// cswch 每秒自愿上下文切换(进程无发获取资源导致切换, 例如I/O、内存不足)// nvcswch 每秒非自愿上下文切换(进程由于时间片已到导致切换, 例如大量进程争抢CPU) 实验1234567891011121314151617181920212223242526// 10个线程运行, 5分钟基准测试, 模拟线程切换[root@zhangbb ~]# sysbench --threads=10 --max-time=300 --max-requests=10000000 threads run[root@zhangbb ~]# vmstat 1 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st10 1 0 70764 24052 423232 0 0 1 7 1 0 0 0 99 0 0[root@zhangbb ~]# pidstat -wt -p 3355Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/21/2019 _x86_64_ (1 CPU)02:31:56 PM UID TGID TID cswch/s nvcswch/s Command02:31:56 PM 0 3355 - 0.00 0.00 sysbench02:31:56 PM 0 - 3355 0.00 0.00 |__sysbench02:31:56 PM 0 - 3356 0.07 0.43 |__sysbench02:31:56 PM 0 - 3357 0.07 0.44 |__sysbench02:31:56 PM 0 - 3358 0.06 0.45 |__sysbench02:31:56 PM 0 - 3359 0.07 0.44 |__sysbench02:31:56 PM 0 - 3360 0.07 0.43 |__sysbench02:31:56 PM 0 - 3361 0.07 0.43 |__sysbench02:31:56 PM 0 - 3362 0.07 0.43 |__sysbench02:31:56 PM 0 - 3363 0.07 0.43 |__sysbench02:31:56 PM 0 - 3364 0.07 0.43 |__sysbench02:31:56 PM 0 - 3365 0.07 0.43 |__sysbench// cs和in数据都不大，神奇的 总结单看上下切换意义不大，在CPU高的时候观察分析切换趋势 第六章 CPU使用率linux定义节拍率(内核表示HZ)，触发时间中断，并使用全局变量jiffies记录节拍数。 1234567[root@zhangbb ~]# grep &apos;CONFIG_HZ=&apos; /boot/config-$(uname -r)CONFIG_HZ=1000[root@zhangbb ~]# cat /proc/stat |grep cpucpu 7069586 162259 3931778 1794587448 203158 0 55664 3714828 0 0cpu0 7069586 162259 3931778 1794587448 203158 0 55664 3714828 0 0// CPU使用率指标user(us): 用户态CPU时间, 不包括nice, 包括guestnice(ni): 低优先级用户态时间system(sys): 内核态CPU时间idle(id): 空闲时间, 不包括等待I/O时间iowait(wa): 等待I/O的CPU时间irq(hi): 硬中断的CPU时间softirq(si): 软中断的CPU时间steal(st): 被其他虚拟机占用的CPU时间guest(): 运行虚拟机的CPU时间guest_nice(gnice): 以低优先级运行虚拟机的时间 CPU使用率计算公式CPU使用率 = 1 - $\dfrac{空闲时间}{总CPU时间}$ CPU平均使用率 = 1 - $\dfrac{空闲时间new - 空闲时间old}{总CPU时间new - 总CPU时间old}$ 性能工具输出的是一段时间内的CPU平均使用率, 注意时间间隔的设置。top默认3秒时间间隔, ps用的是整个进程的生命周期。 工具12345678910111213141516171819202122232425262728293031323334353637// top, 按1可以显示每个CPUtop - 14:48:43 up 24 days, 19:08, 11 users, load average: 3.16, 3.09, 3.06Tasks: 329 total, 1 running, 328 sleeping, 0 stopped, 0 zombie%Cpu0 : 3.1 us, 3.4 sy, 0.0 ni, 93.5 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu1 : 2.0 us, 4.7 sy, 0.0 ni, 92.9 id, 0.0 wa, 0.0 hi, 0.3 si, 0.0 st%Cpu2 : 90.7 us, 0.3 sy, 0.0 ni, 8.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu3 : 8.1 us, 1.0 sy, 0.0 ni, 90.2 id, 0.0 wa, 0.0 hi, 0.7 si, 0.0 st%Cpu4 : 97.0 us, 0.0 sy, 0.0 ni, 3.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu5 : 13.3 us, 3.0 sy, 0.0 ni, 82.7 id, 0.0 wa, 0.0 hi, 1.0 si, 0.0 st%Cpu6 : 3.1 us, 5.2 sy, 0.0 ni, 91.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu7 : 1.4 us, 1.7 sy, 0.0 ni, 96.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem: 66109508 total, 65666692 used, 442816 free, 223228 buffersKiB Swap: 2103292 total, 2103284 used, 8 free. 33262276 cached Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 23553 zjv8cs 20 0 23.118g 88184 75864 S 198.7 0.133 68458:16 sframe 28988 zjv8cs 20 0 24.418g 37268 19044 S 6.312 0.056 265:23.24 sframe 10138 zjv8cs 20 0 25.083g 54204 24276 S 5.980 0.082 171:07.74 sframe 1253 zjv8cs2 20 0 19.784g 19176 8492 S 4.651 0.029 71:39.65 sframe 1260 zjv8cs2 20 0 19.846g 19288 8596 S 4.319 0.029 71:15.20 sframe 26254 zjv8cs 20 0 23.542g 18972 8452 S 4.319 0.029 220:11.03 sframe 12796 zjv8cs2 20 0 20.365g 20172 8612 S 3.987 0.031 161:11.72 sframe [root@zhangbb ~]# pidstat 1 1 Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/22/2019 _x86_64_ (1 CPU)02:50:39 PM UID PID %usr %system %guest %CPU CPU Command02:50:40 PM 0 18909 0.00 1.98 0.00 1.98 0 pidstat02:50:40 PM 0 28600 1.98 1.98 0.00 3.96 0 pritunlAverage: UID PID %usr %system %guest %CPU CPU CommandAverage: 0 18909 0.00 1.98 0.00 1.98 - pidstatAverage: 0 28600 1.98 1.98 0.00 3.96 - pritunl// -g 选项是告诉perf record额外记录函数的调用关系, 相当与gstackperf record -g -p 1663perf report -i perf.data 找CPU使用率高的进程123456781. top 看整体CPU，但找不到对应进程2. pstree |grep stress 查看进程关系也找不到//这个时候perf出场了3. perf record -g 跑一段时间就可以找到4. execsnoop 一段bin/bash脚本监控短时进程 execsnoop 总结看懂CPU使用率, 短时进程占用CPU需要仔细找 第七章 大量不可中断和僵尸进程进程状态 R(Running/Runnable) 进程在CPU的就绪队列中, 正在运行或正在等待运行 D(Disk Sleep) 不可中断状态睡眠, 一般表示与硬件进行交互不允许中断 Z(Zombile) 进程已经结束, 父进程没有回收它的资源 S(Interruptible Sleep) 可中断状态睡眠, 因等待某个事件而被挂起 I(Idle) 空闲状态, 内核上没有任何负载 T/t 暂停(向进程发送SIGSTOP, SIGCONT恢复运行)或跟踪状态(gdb触发断点后变为跟踪状态) X(Dead) 消亡 僵尸进程产生(最后init进程回收)：当一个进程没有用你waitpid() 或 wait() 来等待子进程结束, 回收子进程资源。子进程结束时会向父进程发送SIGCHLD信号, 父进程可以注册信号函数, 异步回收资源。 查看进程状态12345678910111213Tasks: 84 total, 1 running, 83 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 6.2 sy, 0.0 ni, 93.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1016232 total, 598872 free, 123164 used, 294196 buff/cacheKiB Swap: 2093052 total, 2093052 free, 0 used. 738928 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 43304 3652 2472 S 0.0 0.4 0:00.92 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd $ ps aux | grep /approot 4009 0.0 0.0 4376 1008 pts/0 Ss+ 05:51 0:00 /approot 4287 0.6 0.4 37280 33660 pts/0 D+ 05:54 0:00 /approot 4288 0.6 0.4 37280 33668 pts/0 D+ 05:54 0:00 /app Tasks 统计了所有进程的状态;s表示会话的领导进程, +表示前台进程组。 会话是指共享同一个控制终端的一个或多个进程组进程组表示一组相关联的进程, 比如子进程是父进程的组成员 僵尸进程, top+mpstat+strace 都分析不出具体进程哪里导致, 用perf record -g 12345678910# -a 表示输出命令行选项# p 表 PID# s 表示指定进程的父进程$ pstree -aps 3084systemd,1 └─dockerd,15006 -H fd:// └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml └─docker-containe,3991 -namespace moby -workdir... └─app,4009 └─(app,3084) 第八章 Linux中断中断是一种异步事件处理机制, 可以提高系统并发处理能力。linux中断分为两个部分： 上半部分用来快速处理中断, 在中断禁止模式下运行, 主要处理跟硬件相关的或时间敏感的工作(硬中断) 下半部分用来处理上半部分未完成的工作, 通常以内核线程的方式运行(软中断) 例如网卡收到数据, 通过硬中断的方式通知内核有数据到了。上半部分就是把数据存到内存中, 更新硬件寄存器状态标记读完了, 再发送一个软中断信号; 下半部分从内存中找到数据, 按照协议逐层解析和处理, 直到把数据送给应用程序。下半部分为软中断, 网络收发, 内核调度, 定时和 RCU(Read-Copy Update) 锁等也是软中断 123456789101112131415161718192021222324252627282930// 软中断有10种类型, NET_TX 发送, NET_RX 收到52_zjdev[/data01/zjgrp/zjdev]%cat /proc/softirqs CPU0 CPU1 CPU2 CPU3 CPU4 CPU5 CPU6 CPU7 HI: 0 0 0 1 0 1 0 0 TIMER: 624542203 618314692 623983342 624076875 624124123 624035463 623433144 624038509 NET_TX: 1354 10585 1286 2616 1214 1197 1352 1312 NET_RX: 27576207 417105033 31251647 28771418 27476757 28494061 29043344 27354831 BLOCK: 0 0 0 0 0 0 0 0BLOCK_IOPOLL: 0 0 0 0 0 0 0 0 TASKLET: 96 536 87 129 78 92 76 81 SCHED: 187960212 193268976 186768826 186464769 186313710 186328311 185646819 185912615 HRTIMER: 31725 48363 32398 31972 32393 31312 33647 31754 RCU: 312851620 621342389 314557141 626218602 314804587 626018159 625412616 626075625 // 硬中断.......cat /proc/interrupts// 软中断内核线程, ksoftirqd/CPU 编号52_zjdev[/data01/zjgrp/zjdev]%ps aux | grep softirqroot 3 0.0 0.0 0 0 ? S 1月28 0:14 [ksoftirqd/0]root 13 0.0 0.0 0 0 ? S 1月28 0:48 [ksoftirqd/1]root 18 0.0 0.0 0 0 ? S 1月28 0:25 [ksoftirqd/2]root 23 0.0 0.0 0 0 ? S 1月28 0:16 [ksoftirqd/3]root 28 0.0 0.0 0 0 ? S 1月28 0:14 [ksoftirqd/4]root 33 0.0 0.0 0 0 ? S 1月28 0:14 [ksoftirqd/5]root 38 0.0 0.0 0 0 ? S 1月28 0:13 [ksoftirqd/6]root 43 0.0 0.0 0 0 ? S 1月28 0:12 [ksoftirqd/7]zjdev 23982 0.0 0.0 12964 932 pts/9 S+ 10:34 0:00 grep softirq 第九章 软中断CPU使用率升高工具：sar: 系统活动报告工具, 实时查看系统当前活动hpping3：tcp/id 协议数据包工具, sync flood 1234567891011121314151617181920212223242526272829303132# top 运行后按数字 1 切换到显示所有 CPU$ toptop - 10:50:58 up 1 days, 22:10, 1 user, load average: 0.00, 0.00, 0.00Tasks: 122 total, 1 running, 71 sleeping, 0 stopped, 0 zombie%Cpu0 : 0.0 us, 0.0 sy, 0.0 ni, 96.7 id, 0.0 wa, 0.0 hi, 3.3 si, 0.0 st%Cpu1 : 0.0 us, 0.0 sy, 0.0 ni, 95.6 id, 0.0 wa, 0.0 hi, 4.4 si, 0.0 st... PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 7 root 20 0 0 0 0 S 0.3 0.0 0:01.64 ksoftirqd/0 16 root 20 0 0 0 0 S 0.3 0.0 0:01.97 ksoftirqd/1 2663 root 20 0 923480 28292 13996 S 0.3 0.3 4:58.66 docker-containe 3699 root 20 0 0 0 0 I 0.3 0.0 0:00.13 kworker/u4:0 3708 root 20 0 44572 4176 3512 R 0.3 0.1 0:00.07 top 1 root 20 0 225384 9136 6724 S 0.0 0.1 0:23.25 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.03 kthreadd...[root@localhost ~]# watch -d cat /proc/softirqsEvery 2.0s: cat /proc/softirqs Tue Feb 26 21:54:03 2019 CPU0 HI: 6 TIMER: 67166 NET_TX: 1817 NET_RX: 6051 BLOCK: 9899BLOCK_IOPOLL: 0 TASKLET: 45 SCHED: 0 HRTIMER: 0 RCU: 16504 总结软中断CPU使用率升高是个常见的性能问题, 实际生产一般是网络收发导致, 尤其是网络接收软中断 第十章 系统CPU瓶颈分析套路]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vector容器]]></title>
    <url>%2F2019%2F02%2F18%2Fvector%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[内存分配 reservesizecapacity 内存释放 cleareraseswapshrink_to_fit 其他 dataemplace_back]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++比java快吗]]></title>
    <url>%2F2019%2F02%2F07%2Fc-%E6%AF%94java%E5%BF%AB%E5%90%97%2F</url>
    <content type="text"><![CDATA[参考文章地址 The test suite Loading Program Executable(加载程序可执行文件) Running Program Instructions(运行程序指令) Allocating Memory(内存分配) Accessing System Resources(访问系统资源) EnvironmentPlatform: linux/windowsHardware configuration: cpu,memorySoftware: c++/jdk version Loading Program Executable(LPE)There are two main contributors to this size difference: executable size and selective loading. executable sizec++一般比java大, jvm包含运行需要的库？ selective loadingc++在执行前加载全部可执行文件。链接库加载分为静态和动态加载, 静态加载是指在执行前加载，动态加载是指在运行时调用对应函数。动态加载时没有类型校验, 库变更会导致不可预知的错误。 java在需要时动态加载 Running Program Instructions(RPI)There are two possible methods a JVM uses to do so: a bytecode interpreter or a just-in-time(JIT) compiler.没有JIT(即时编译技术)的JVM在执行每一条指令时都会看到它，因此它不能动态地执行这些类型的优化。但是，JIT可以对整个类文件执行代码优化。因此，与JIT和本地C++应用程序运行的Java程序之间唯一的显著性能差异将是执行类文件的初始翻译所需的时间和执行的优化类型。实际应用中程序多次使用相同的类, JIT智能编译用到次数多的类, 因此翻译过程的开销通常是微不足道的。 编译器的优化参数也是很关键的, 例如对无效代码(Dead Code)是执行还是直接删除c++ RTTI: Run-Time Type Identification, 主要是typeid操作符和4个类型转换关键字 Test Description C++(sec) Java(JIT) Java(Bytecode interpreter) Integer division This test loops 10 million times on an integer division. 1.8 1.8 4.8 Dead code This test loops 10 million times and performs an operation that is never used. 3.7 3.7 9.5 Dead code with Integer division This test loops 10 million times and performs an operation that is never used and one that is. 5.7 5.7 20 Floating-point division This test loops 10 million times on a floating-point division. 1.6 1.6 8.7 Static method This test loops 10 million times calling a static method which contains an Integer division. 1.8 1.8 6.0 Member method This test loops 10 million times calling a member method which contains an Integer division. 1.8 1.8 10 Virtual member method The Member method test performed above is not really valid. In Java all Member methods are virtual. This test loops 10 million times calling a Virtual member method which contains an Integer division. 1.8 1.8 10 Virtual member method with down cast and Run-Time Type Identification (RTTI) This test loops 10 million times calling a Virtual method on a class that has been down cast using RTTI. 11 4.3 12 Virtual member method with invalid down cast and Run-Time Type Identification (RTTI) This test loops 10 million times calling a Virtual method on a class that has been down cast using RTTI. crash crash crash Allocating Memory(AM)JAVA的GC机制避免内存泄漏人工检查时间, 内存碎片问题。c++ 直接通过glibc来分配。Allocating and freeing 10 million 32-bit integers took 0.812 seconds in C++ and 1.592 seconds in Java. Accessing System Resources (ASR)文件/网络操作方面, java跨平台移植方便(jdk封装)，c++无法比拟的优势]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux内核设计与实现]]></title>
    <url>%2F2019%2F01%2F31%2FLinux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[linux内核简介应用程序、内核、硬件关系 linux版本号说明2.6.26.1 = 主板版号.从版本号.修改定版本号.开发版本号(奇数开发，偶数稳定) linxu内核开发者社区 获取内核源码 编译和开发 进程管理进程是处于执行期的程序, 包含打开文件/挂起信号/处理器状态/ 线程]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis设计原理]]></title>
    <url>%2F2019%2F01%2F31%2Fredis%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络字节序]]></title>
    <url>%2F2019%2F01%2F24%2F%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[理解字节序 大端字节序：高位字节在前, 低位字节在后, 是人类读取字节的方法小端字节序：低位字节在前, 高位字节在后 int32 num = 0x1234567的大端字节序和小端字节序的写法如下 地址 0x100 0x101 0x102 0x103 大端 0x01 0x23 0x45 0x67 小端 0x67 0x45 0x23 0x01 网络字节序网络字节顺序采用大端字节序, 是TCP/IP中规定好的一种数据表示格式;与具体的CPU类型、操作系统等无关, 保证数据在不同主机之间传输时能够被正确解释。 主机字节序 处理器 操作系统 字节排序 Alpha 全部 Little endian HP-PA NT Little endian HP-PA UNIX Big endian Intelx86 全部 Little endian Motorola680x 全部 Big endian MIPS NT Little endian MIPS UNIX Big endian PowerPC NT Little endian PowerPC 非NT Big endian RS/6000 UNIX Big endian SPARC UNIX Big endian IXP1200 ARM核心 Little endian 字节序判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081inline int64 htonl64(const char* pIn )&#123; if (pIn == NULL) &#123; return 0; &#125; int32 nIsNet = 0x12345678; if (*(char *)&amp;nIsNet == 0x12) &#123; nIsNet = 1; &#125; else &#123; nIsNet = 0; &#125; unsigned char szBuffer[16]; if (nIsNet == 1) &#123; memcpy(szBuffer, pIn, 8); &#125; else &#123; for (int32 i = 0, j = 7; i &lt; 8; ++i, --j) &#123; szBuffer[i] = pIn[j]; &#125; &#125; int64 llValue; memcpy(&amp;llValue, szBuffer, sizeof(int64)); return llValue;&#125;;inline int64 ntohl64(const char* pIn )&#123; if (pIn == NULL) &#123; return 0; &#125; int32 nIsNet = 0x12345678; if (*(char *)&amp;nIsNet == 0x12) &#123; nIsNet = 1; &#125; else &#123; nIsNet = 0; &#125; unsigned char szBuffer[8]; if (nIsNet == 1) &#123; memcpy(szBuffer, pIn, 8); &#125; else &#123; //!&lt; 取高4字节. int32 nRetH; int32 nTmpRetH; memcpy(&amp;nTmpRetH, pIn, sizeof(int32)); nRetH = ntohl(nTmpRetH); //!&lt; 取低4字节. int32 nRetL; int32 nTmpRetL; memcpy(&amp;nTmpRetL, pIn + sizeof(int32), sizeof(int32)); nRetL = ntohl(nTmpRetL); //! 整合. memcpy(szBuffer, &amp;nRetL, sizeof(int32)); memcpy(szBuffer + sizeof(int32), &amp;nRetH, sizeof(int32)); &#125; int64 llValue; memcpy(&amp;llValue, szBuffer, sizeof(int64)); return llValue;&#125;; 32位整数转换为网络字节序12345/* 大端字节序 */i = (data[0]&lt;&lt;24) | (data[1]&lt;&lt;16) | (data[2]&lt;&lt;8) | (data[3]&lt;&lt;0);/* 小端字节序 */i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24);]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[零拷贝]]></title>
    <url>%2F2019%2F01%2F23%2F%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[为什么需要零拷贝 零拷贝技术概述简单一点来说，零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术避免数据拷贝 零拷贝技术分类直接IO对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输：这类零拷贝技术针对的是操作系统内核并不需要对数据进行直接处理的情况，数据可以在应用程序地址空间的缓冲区和磁盘之间直接进行传输，完全不需要 Linux 操作系统内核提供的页缓存的支持。 123int open(const char *pathname, int oflag, … /*, mode_t mode * / ) ;O_DIRECT 该描述符提供对直接 I/O 的支持 打开文件指定O_DIRECT 属性时, read/write是直接I/O操作 优点 直接 I/O 最主要的优点就是通过减少操作系统内核缓冲区和应用程序地址空间的数据拷贝次数，降低了对文件读取和写入时所带来的 CPU 的使用以及内存带宽的占用缺点 直接 I/O 的开销非常大, 造成磁盘的同步读, 也会导致应用程序关闭缓慢, 通常会和使用异步 I/O 结合使用 mmap/sendfile/splice避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝 mmap通过使用 mmap() 来代替 read(), 应用程序调用了 write() 之后，操作系统内核将数据从原来的内核缓冲区中拷贝到与 socket 相关的内核缓冲区中 sendfilesendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，所以 sendfile()只是适用于应用程序地址空间不需要对所访问数据进行处理的情况 splicesplice() 可以被看成是类似于基于流的管道的实现，管道可以使得两个文件描述符相互连接，splice 的调用者则可以控制两个设备（或者协议栈）在操作系统内核中的相互连接。在 Linux 2.6.23中，sendfile() 利用了 splice() 这种机制来实现的 1long splice(int fdin, int fdout, size_t len, unsigned int flags); 写时复制拷贝复制的一种策略, 例如fork/string都有使用, 缓冲区共享 快速缓冲区(Fast Buffers)原理介绍应用程序将 fbuf 传递给操作系统内核，这样就能减少传统的 write 系统调用所产生的数据拷贝开销]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[excel数据处理]]></title>
    <url>%2F2019%2F01%2F21%2Fexcel%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Sqlite 简介使用菜鸟教程网站 桌面工具下载安装SQLite Database Browser, 免费开源，支持简单的创建/打开/修改/删除 SQL 数据库。不懂SQL小白也支持操作. 下载地址 右键解压到当前文件夹，解压后如下(可以剪切或复制到其他目录): 进入”DB Browser for SQLite”, 找到如下*.exe，右键创建桌面快捷方式(方便使用) Python脚本python for windows download 第三放库安装：1234win + rcmdpip install openpyxlpip install lxml openpyxl官方手册 1#!/usr/bin/python3]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[malloc死锁]]></title>
    <url>%2F2019%2F01%2F18%2Fmalloc%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[进程bt信息&lt;! – more –&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(gdb) bt#0 0x00007ff5083f65cb in __lll_lock_wait_private () from /lib64/libc.so.6#1 0x00007ff508382bca in _L_lock_10550 () from /lib64/libc.so.6#2 0x00007ff508380705 in malloc () from /lib64/libc.so.6#3 0x00007ff5086bdc47 in start_fde_sort (count=33, accu=0x7ff4cab0b1a0) at ../../../libgcc/unwind-dw2-fde.c:409#4 init_object (ob=0x7ff4babf1be0 &lt;current_sl&gt;) at ../../../libgcc/unwind-dw2-fde.c:771#5 search_object (ob=ob@entry=0x7ff4babf1be0 &lt;current_sl&gt;, pc=pc@entry=0x7ff5086bca07 &lt;_Unwind_Backtrace+55&gt;) at ../../../libgcc/unwind-dw2-fde.c:961#6 0x00007ff5086be492 in _Unwind_Find_registered_FDE (bases=0x7ff4cab0b528, pc=0x7ff5086bca07 &lt;_Unwind_Backtrace+55&gt;) at ../../../libgcc/unwind-dw2-fde.c:1025#7 _Unwind_Find_FDE (pc=0x7ff5086bca07 &lt;_Unwind_Backtrace+55&gt;, bases=bases@entry=0x7ff4cab0b528) at ../../../libgcc/unwind-dw2-fde-dip.c:448#8 0x00007ff5086baee6 in uw_frame_state_for (context=context@entry=0x7ff4cab0b480, fs=fs@entry=0x7ff4cab0b2d0) at ../../../libgcc/unwind-dw2.c:1241#9 0x00007ff5086bc130 in uw_init_context_1 (context=context@entry=0x7ff4cab0b480, outer_cfa=outer_cfa@entry=0x7ff4cab0b730, outer_ra=0x7ff5083f6f46 &lt;backtrace+86&gt;) at ../../../libgcc/unwind-dw2.c:1562#10 0x00007ff5086bca08 in _Unwind_Backtrace (trace=0x7ff5083f6dd0 &lt;backtrace_helper&gt;, trace_argument=0x7ff4cab0b730) at ../../../libgcc/unwind.inc:283#11 0x00007ff5083f6f46 in backtrace () from /lib64/libc.so.6#12 0x00007ff508324d52 in backtrace_and_maps () from /lib64/libc.so.6#13 0x00007ff5083777ff in __libc_message () from /lib64/libc.so.6#14 0x00007ff50837d06e in malloc_printerr () from /lib64/libc.so.6#15 0x00007ff50837d32c in malloc_consolidate () from /lib64/libc.so.6#16 0x00007ff50837e588 in _int_malloc () from /lib64/libc.so.6#17 0x00007ff508380710 in malloc () from /lib64/libc.so.6#18 0x00007ff508c59258 in operator new (sz=sz@entry=1024) at ../../../../libstdc++-v3/libsupc++/new_op.cc:50#19 0x00007ff50a0ccc0d in allocate (this=0x7ff4b085a878, __n=&lt;optimized out&gt;) at /usr/local/gcc-5.5.0/include/c++/5.5.0/ext/new_allocator.h:104#20 allocate (__a=..., __n=&lt;optimized out&gt;) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/alloc_traits.h:491#21 _M_allocate (this=0x7ff4b085a878, __n=&lt;optimized out&gt;) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/stl_vector.h:170#22 std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;::_M_emplace_back_aux&lt;std::__cxx11::b---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---asic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;&amp;) (this=0x7ff4b085a878) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/vector.tcc:412#23 0x00007ff4fdaab81d in push_back ( __x=&lt;unknown type in /data01/zjgrp/zjv8cs2/lib/libjsoncppD.so, CU 0x2217a, DIE 0x35d11&gt;, this=0x7ff4b085a878) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/stl_vector.h:932#24 Json::Value::resolveReference (this=0x7ff4b085a870, key=0x7ff4c428ca30 &quot;list_12_BONUS_INFO_LIST&quot;, isStatic=isStatic@entry=false) at src/lib_json/json_value.cpp:1052#25 0x00007ff4fdaab947 in Json::Value::operator[] (this=&lt;optimized out&gt;, key=&lt;optimized out&gt;) at src/lib_json/json_value.cpp:1034#26 0x00007ff4fe2f820f in sdl::JsonEncoder::PutListBegin (this=0x7ff4af3479d0, szListName=0x7ff4d0880501 &quot;BONUS_INFO_LIST&quot;, iSize=&lt;optimized out&gt;) at src/codec_json.cpp:1054#27 0x00007ff5012cd013 in sdl::visitor::encode_list_vector (pEncoder=0x7ff4af3479d0, sdltype=&lt;optimized out&gt;, pVal=0x7ff4cab0c830, name=0x7ff4d0880501 &quot;BONUS_INFO_LIST&quot;) at src/sdl_stream.cpp:897#28 0x00007ff5012ccdf5 in sdl::visitor::encode_struct (pEncoder=0x7ff4af3479d0, sdltype=&lt;optimized out&gt;, pVal=0x7ff4cab0c710, name=&lt;optimized out&gt;) at src/sdl_stream.cpp:874#29 0x00007ff4d0fcd31d in visit (p=0x7ff4cab0c710, sdltype=11, this=0x7ff4cab0c530) at /data01/zjgrp/zjv8bm/ob_rel/include/public/sdl/sdl_stream.h:311#30 operator&lt;&lt; (v=..., this=0x7ff4cab0c530) at /data01/zjgrp/zjv8bm/ob_rel/include/public/sdl/sdl_stream.h:365#31 charging::dump_xdr&lt;MRatmsInterfaceRatingDef::SRatingUpdate&gt; (data=..., level=1) at ../base/dump_xdr.h:16#32 0x00007ff4d0fdf43d in charging::CMdbOperatorChain::Update (this=0x7ff4c429f130, xdr=..., subXdr=..., baseData=...) at mdb_operate_chain.cpp:99#33 0x00007ff4d274325a in charging::CRevRatingAlgo::risk_addup_charge (this=this@entry=0x7ff4c41feef0, xdr=..., subXdr=..., pData=pData@entry=0x7ff4cab0cef0) at RiskRatingAlgo.cpp:336#34 0x00007ff4d2743b4d in charging::RiskRatingAddupAlgo::DoIt (this=0x7ff4c41feef0, xdr=..., subXdr=..., pData=0x7ff4cab0cef0) at RiskRatingAlgo.cpp:443#35 0x00007ff4d274afca in charging::CRatingInterface::rating_algo (this=this@entry=0x7ff4cab0d787, listXdr=..., algoType=algoType@entry=7, pSession=pSession@entry=0x7ff4c4019b90) at ratingInterface.cpp:57#36 0x00007ff4d27561c7 in MRatingApp::CIRatingAppImp::risk_addup (this=this@entry=0x7ff4cab0d7f0, pSession=pSession@entry=0x7ff4c4019b90, listXdr=..., cErrorMsg=...) at rating_sdl_i.cpp:78#37 0x00007ff4d2752fcf in MRATINGAPP_IRATINGAPP_RISK_ADDUP (pSession=pSession@entry=0x7ff4c4019b90, in=..., out=..., pErrorMsg=pErrorMsg@entry=0x1d79c18) at rating_imp.cpp:184#38 0x00007ff4db5d145f in tp::AppLib::ExecIntf (---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- funcHandle=funcHandle@entry=0x7ff4d2752d60 &lt;MRATINGAPP_IRATINGAPP_RISK_ADDUP(sdl::SdlSession*, sdl::CSdlBasicParamObject&amp;, sdl::CSdlBasicParamObject&amp;, sdl::CSdlErrorMsg*)&gt;, pIntfName=pIntfName@entry=0x1a40270 &quot;MRATINGAPP_IRATINGAPP_RISK_ADDUP&quot;, pSession=pSession@entry=0x7ff4c4019b90, paramIn=..., paramOut=..., cErrorMsg=...) at tp_interface.cpp:38#39 0x00007ff4db5d7fad in tp::Service::ExecService (this=this@entry=0x1a38b40, pRet=pRet@entry=0x1d7aec8, pAttr=pAttr@entry=0x1d7aef0) at tp_service.cpp:74#40 0x00007ff4f81a5d1f in tp::RpcReqProcess::ProcessRpcTask (this=this@entry=0x1d79970, pReqMsg=pReqMsg@entry=0x7ff4cab0e250, pResMsg=pResMsg@entry=0x7ff4cab0e260, pService=0x1a38b40) at rpc_proc.cpp:121#41 0x00007ff4f81a625f in tp::RpcReqProcess::ProcessRpcReq (this=this@entry=0x1d79970, pRpcReq=pRpcReq@entry=0x7ff4cab0e250, pRpcResp=pRpcResp@entry=0x7ff4cab0e260) at rpc_proc.cpp:208#42 0x00007ff4f81a6aa4 in tp::RpcReqProcess::Run (this=0x1d79970, inMsg=..., outMsg=...) at rpc_proc.cpp:62#43 0x00007ff4f81a2553 in tp::SCB4DirectProc::OnReadable (this=0x1d8aa10, pChannel=0x7ff4b40020b0) at event_proc.cpp:39#44 0x00007ff506dc1394 in OnChannelEvent (ops=1, pChannel=0x7ff4b40020b0, this=0x1d841e0) at src/cdk_rpc_socket_server.cpp:109#45 cdk::rpc::SocketServer::SocketServerImpl::OnEvent (this=0x1d841e0, hSock=&lt;optimized out&gt;, ops=1, pArg=&lt;optimized out&gt;) at src/cdk_rpc_socket_server.cpp:87#46 0x00007ff507636cc4 in cdk::io::EventLoop2::EventCallback (fd=29, events=&lt;optimized out&gt;, arg=0x1d8a490) at src/linux/../cdk_os_io_eventloop2.h:93#47 0x00007ff50232ecbb in event_persist_closure () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#48 0x00007ff50232ee31 in event_process_active_single_queue () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#49 0x00007ff50232f100 in event_process_active () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#50 0x00007ff50232f79b in event_base_loop () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#51 0x00007ff507635f7a in cdk::io::EventLoop2::Run (this=0x1d8a490, timeout=&lt;optimized out&gt;) at src/linux/../cdk_os_io_eventloop2.h:184#52 0x00007ff506dc044c in cdk::rpc::SocketServer::Run (this=0x1d841c0, iTimeout=iTimeout@entry=5000) at src/cdk_rpc_socket_server.cpp:362#53 0x00007ff4f81a8c0e in tp::RpcServerRunnable::Run (this=0x1d84140) at rpc_server_imp.cpp:357#54 0x00007ff50a0dbde6 in cdk::Thread::Run (this=0x1d8caa0) at src/cdk_thread.cpp:118#55 0x00007ff50a0dc719 in cdk::ExecFunc (pData=0x1d8caa0) at src/cdk_thread.cpp:35#56 0x00007ff509a6f0a4 in start_thread () from /lib64/libpthread.so.0#57 0x00007ff5083ea04d in clone () from /lib64/libc.so.6 malloc原理分析libc库版本和源码1252_zjdev[/data01/zjgrp/zjdev]%ls -ltr /lib64/libc.so.6lrwxrwxrwx 1 root root 12 1月 23 2018 /lib64/libc.so.6 -&gt; libc-2.19.so glibc源码下载 API手册 malloc MT-Safe Multi Thread 多线程安全AS-Safe Async Singal 异步信号不安全AC-Safe Async Cancel 异步取消不安全 内存管理源码分析]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[limit限制]]></title>
    <url>%2F2019%2F01%2F17%2Flimit%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[系统调用ulimit1234567891011121314151617[root@zhangbb ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 3893max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 65535pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 65535virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 库函数 #include &lt;sys/time.h&gt; #include &lt;sys/resource.h&gt;int getrlimit(int resource, struct rlimit rlim);int setrlimit(int resource, const struct rlimit rlim); 12345678910111213141516171819202122232425262728293031323334#include &lt;sys/resource.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;int main()&#123; struct rlimit r; if(getrlimit(RLIMIT_AS, &amp;r) &lt; 0) &#123; perror(&quot;getrlimit error&quot;); return 0; &#125; printf(&quot;RLIMIT_AS cur %d, max %d\n&quot;, r.rlim_cur, r.rlim_max); if(getrlimit(RLIMIT_STACK, &amp;r) &lt; 0) &#123; perror(&quot;getrlimit error&quot;); return 0; &#125; printf(&quot;RLIMIT_STACK cur %d, max %d\n&quot;, r.rlim_cur, r.rlim_max); if(getrlimit(RLIMIT_MEMLOCK , &amp;r) &lt; 0) &#123; perror(&quot;getrlimit error&quot;); return 0; &#125; printf(&quot;RLIMIT_MEMLOCK cur %d, max %d\n&quot;, r.rlim_cur, r.rlim_max); return 0;&#125;52_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%./testRLIMIT_AS cur -1, max -1RLIMIT_STACK cur -1, max -1RLIMIT_MEMLOCK cur 65536, max 65536 参考 getrusage获取运行进程使用资源]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[strace命令]]></title>
    <url>%2F2019%2F01%2F14%2Fstrace%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一个简单的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd; int i = 0; fd = open(&quot;./test.cpp&quot;, O_RDONLY); if(fd &lt; 5) i = 5; else i = 2; return i;&#125;g++ test.cpp -o teststrace -o test.strace ./testvim test.strace 1 execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 32 vars */]) = 0 2 brk(NULL) = 0x149b000 3 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d939000 4 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory) 5 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3 6 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=54597, ...&#125;) = 0 7 mmap(NULL, 54597, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb83d92b000 8 close(3) = 0 9 open(&quot;/usr/lib64/libstdc++.so.6&quot;, O_RDONLY|O_CLOEXEC) = 310 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 \262\5\0\0\0\0\0&quot;..., 832) = 83211 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=991616, ...&#125;) = 012 mmap(NULL, 3171168, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83d41200013 mprotect(0x7fb83d4fb000, 2093056, PROT_NONE) = 014 mmap(0x7fb83d6fa000, 40960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xe8000) = 0x7fb83d 6fa00015 mmap(0x7fb83d704000, 82784, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb83d70400 016 close(3) = 017 open(&quot;/usr/lib64/libm.so.6&quot;, O_RDONLY|O_CLOEXEC) = 318 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\20S\0\0\0\0\0\0&quot;..., 832) = 83219 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1137016, ...&#125;) = 020 mmap(NULL, 3150120, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83d110000 21 mprotect(0x7fb83d211000, 2093056, PROT_NONE) = 022 mmap(0x7fb83d410000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x100000) = 0x7fb83d 41000023 close(3) = 024 open(&quot;/usr/lib64/libgcc_s.so.1&quot;, O_RDONLY|O_CLOEXEC) = 325 read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\220*\0\0\0\0\0\0&quot;..., 832) = 83226 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=88776, ...&#125;) = 027 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92a000 28 mmap(NULL, 2184192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83cefa00029 mprotect(0x7fb83cf0f000, 2093056, PROT_NONE) = 030 mmap(0x7fb83d10e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14000) = 0x7fb83d1 0e00031 close(3) = 032 open(&quot;/usr/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 333 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\340$\2\0\0\0\0\0&quot;..., 832) = 83234 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2151672, ...&#125;) = 035 mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83cb2d00036 mprotect(0x7fb83ccef000, 2097152, PROT_NONE) = 037 mmap(0x7fb83ceef000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x7fb83 ceef00038 mmap(0x7fb83cef5000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb83cef500 039 close(3) = 040 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92900041 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92700042 arch_prctl(ARCH_SET_FS, 0x7fb83d927740) = 043 mprotect(0x7fb83ceef000, 16384, PROT_READ) = 044 mprotect(0x7fb83d10e000, 4096, PROT_READ) = 045 mprotect(0x7fb83d410000, 4096, PROT_READ) = 046 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92600047 mprotect(0x7fb83d6fa000, 32768, PROT_READ) = 048 mprotect(0x600000, 4096, PROT_READ) = 049 mprotect(0x7fb83d93a000, 4096, PROT_READ) = 050 munmap(0x7fb83d92b000, 54597) = 051 open(&quot;./test.cpp&quot;, O_RDONLY) = 352 exit_group(5) = ?53 +++ exited with 5 +++#格式为：系统调用的名称( 参数... ) = 返回值 错误标志和描述#line1: 对于命令行下执行的程序，execve(或exec系列调用中的某一个)均为strace输出系统调用中的第一个。strace首先调用fork 或clone函数新建一个子进程，然后在子进程中调用exec载入需要执行的程序(这里为./test)#line2: 以NULL作为参数调用brk，返回值为内存管理的起始地址(若在子进程中调用malloc，则从 0x149b000 地址开始分配空间)#line4: 使用mmap函数进行匿名内存映射，以此来获取4096bytes内存空间，该空间起始地址为 0x7fb83d939000#line3: 调用access函数检验/etc/ld.so.preload是否存在#line5: 打开/etc/ld.so.cache, 返回文件描述符3#line6: fstat函数获取/etc/ld.so.cache文件信息#line7: 调用mmap函数将/etc/ld.so.cache文件映射至内存#line8: close关闭文件描述符为3指向的/etc/ld.so.cache文件#line10: 调用read，从/usr/lib64/libstdc++.so.6该libc库文件中读取832bytes，即读取ELF头信息#line13: 使用 mprotect 函数对 0x7fb83d4fb000 起始的2093056 进行保护(PROT_NONE表示不能访问，PROT_READ表示可以读取)#line50: 调用 munmap 函数，将/etc/ld.so.cache文件从内存中去映射，与Line 4的mmap对应#line51: 对应源码中使用到的唯一的系统调用 open 函数，使用其打开./test.cpp文件#line532: 返回5，退出 几乎都用于进行进程初始化工作：装载被执行程序、载入libc函数库、设置内存映射等。源码中的if语句或其他代码在相应strace输出中并没有体现，因为它们并没有唤起系统调用。strace只关心程序与系统之间产生的交互，因而strace不适用于程序逻辑代码的排错和分析。 命令选项 -T: 记录各个系统调用花费的时间，精确到微秒-r: 以第一个系统调用(通常为execve)计时，精确到微秒-t: 时：分：秒-tt: 时：分：秒 . 微秒-ttt: 计算机纪元以来的秒数 . 微秒-p: 跟踪正在运行的进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@zhangbb test]# strace -Tr ./test 0.000000 execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 32 vars */]) = 0 &lt;0.000442&gt; 0.000687 brk(NULL) = 0xd49000 &lt;0.000009&gt; 0.000059 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5783000 &lt;0.000012&gt; 0.000067 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory) &lt;0.000024&gt; 0.000098 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000015&gt; 0.000071 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=54597, ...&#125;) = 0 &lt;0.000010&gt; 0.000072 mmap(NULL, 54597, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f57a5775000 &lt;0.000060&gt; 0.000079 close(3) = 0 &lt;0.000009&gt; 0.000044 open(&quot;/usr/lib64/libstdc++.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000036&gt; 0.000057 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 \262\5\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000014&gt; 0.000043 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=991616, ...&#125;) = 0 &lt;0.000010&gt; 0.000032 mmap(NULL, 3171168, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a525c000 &lt;0.000017&gt; 0.000043 mprotect(0x7f57a5345000, 2093056, PROT_NONE) = 0 &lt;0.000015&gt; 0.000043 mmap(0x7f57a5544000, 40960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xe8000) = 0x7f57a5544000 &lt;0.000014&gt; 0.000042 mmap(0x7f57a554e000, 82784, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f57a554e000 &lt;0.000012&gt; 0.000041 close(3) = 0 &lt;0.000009&gt; 0.000041 open(&quot;/usr/lib64/libm.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000015&gt; 0.000040 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\20S\0\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000011&gt; 0.000029 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1137016, ...&#125;) = 0 &lt;0.000010&gt; 0.000029 mmap(NULL, 3150120, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a4f5a000 &lt;0.000012&gt; 0.000029 mprotect(0x7f57a505b000, 2093056, PROT_NONE) = 0 &lt;0.000013&gt; 0.000028 mmap(0x7f57a525a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x100000) = 0x7f57a525a000 &lt;0.000012&gt; 0.000041 close(3) = 0 &lt;0.000009&gt; 0.000036 open(&quot;/usr/lib64/libgcc_s.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000014&gt; 0.000037 read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\220*\0\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000010&gt; 0.000028 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=88776, ...&#125;) = 0 &lt;0.000009&gt; 0.000037 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5774000 &lt;0.000011&gt; 0.000032 mmap(NULL, 2184192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a4d44000 &lt;0.000022&gt; 0.000040 mprotect(0x7f57a4d59000, 2093056, PROT_NONE) = 0 &lt;0.000014&gt; 0.000030 mmap(0x7f57a4f58000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14000) = 0x7f57a4f58000 &lt;0.000015&gt; 0.000049 close(3) = 0 &lt;0.000009&gt; 0.000033 open(&quot;/usr/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000015&gt; 0.000033 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\340$\2\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000010&gt; 0.000028 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2151672, ...&#125;) = 0 &lt;0.000009&gt; 0.000029 mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a4977000 &lt;0.000012&gt; 0.000028 mprotect(0x7f57a4b39000, 2097152, PROT_NONE) = 0 &lt;0.000014&gt; 0.000028 mmap(0x7f57a4d39000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x7f57a4d39000 &lt;0.000015&gt; 0.000045 mmap(0x7f57a4d3f000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f57a4d3f000 &lt;0.000012&gt; 0.000037 close(3) = 0 &lt;0.000009&gt; 0.000050 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5773000 &lt;0.000010&gt; 0.000039 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5771000 &lt;0.000014&gt; 0.000050 arch_prctl(ARCH_SET_FS, 0x7f57a5771740) = 0 &lt;0.000010&gt; 0.000169 mprotect(0x7f57a4d39000, 16384, PROT_READ) = 0 &lt;0.000014&gt; 0.000040 mprotect(0x7f57a4f58000, 4096, PROT_READ) = 0 &lt;0.000012&gt; 0.000054 mprotect(0x7f57a525a000, 4096, PROT_READ) = 0 &lt;0.000013&gt; 0.000877 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5770000 &lt;0.000013&gt; 0.000090 mprotect(0x7f57a5544000, 32768, PROT_READ) = 0 &lt;0.000014&gt; 0.000033 mprotect(0x600000, 4096, PROT_READ) = 0 &lt;0.000013&gt; 0.000032 mprotect(0x7f57a5784000, 4096, PROT_READ) = 0 &lt;0.000014&gt; 0.000029 munmap(0x7f57a5775000, 54597) = 0 &lt;0.000024&gt; 0.000156 open(&quot;./test.cpp&quot;, O_RDONLY) = 3 &lt;0.000030&gt; 0.000097 exit_group(5) = ? 0.000147 +++ exited with 5 +++]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gdb打印容器]]></title>
    <url>%2F2019%2F01%2F14%2Fgdb%E6%89%93%E5%8D%B0%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[打印STL容器GDB在一些环境上不能直接打印容器, 需要指定容器参数如vector._M_impl._M_start，一个个打印 gdbinit将以下内容追加到~/.gdbinit文件的尾部，然后再启动gdb，如果gdb已经启动，则可以source ~/.gdbinit来立即生效123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683# # STL GDB evaluators/views/utilities - 1.03## The new GDB commands: # are entirely non instrumental # do not depend on any &quot;inline&quot;(s) - e.g. size(), [], etc# are extremely tolerant to debugger settings# # This file should be &quot;included&quot; in .gdbinit as following:# source stl-views.gdb or just paste it into your .gdbinit file## The following STL containers are currently supported:## std::vector&lt;T&gt; -- via pvector command# std::list&lt;T&gt; -- via plist or plist_member command# std::map&lt;T,T&gt; -- via pmap or pmap_member command# std::multimap&lt;T,T&gt; -- via pmap or pmap_member command# std::set&lt;T&gt; -- via pset command# std::multiset&lt;T&gt; -- via pset command# std::deque&lt;T&gt; -- via pdequeue command# std::stack&lt;T&gt; -- via pstack command# std::queue&lt;T&gt; -- via pqueue command# std::priority_queue&lt;T&gt; -- via ppqueue command# std::bitset&lt;n&gt; -- via pbitset command# std::string -- via pstring command# std::widestring -- via pwstring command# void * array[] -- via parray command this command for print content infomantion of point array## The end of this file contains (optional) C++ beautifiers# Make sure your debugger supports $argc## Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL# Inspired by intial work of Tom Malnar,# Tony Novac (PhD) / Cornell / Stanford,# Gilad Mishne (PhD) and Many Many Others.# Contact: dan_c_marinescu@yahoo.com (Subject: STL)## Modified to work with g++ 4.3 by Anders Elton# Also added _member functions, that instead of printing the entire class in map, prints a member.## std::vector&lt;&gt;#define pvector if $argc == 0 help pvector else set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start set $size_max = $size - 1 end if $argc == 1 set $i = 0 while $i &lt; $size printf &quot;elem[%u]: &quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end if $argc == 2 set $idx = $arg1 if $idx &lt; 0 || $idx &gt; $size_max printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max else printf &quot;elem[%u]: &quot;, $idx p *($arg0._M_impl._M_start + $idx) end end if $argc == 3 set $start_idx = $arg1 set $stop_idx = $arg2 if $start_idx &gt; $stop_idx set $tmp_idx = $start_idx set $start_idx = $stop_idx set $stop_idx = $tmp_idx end if $start_idx &lt; 0 || $stop_idx &lt; 0 || $start_idx &gt; $size_max || $stop_idx &gt; $size_max printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max else set $i = $start_idx while $i &lt;= $stop_idx printf &quot;elem[%u]: &quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end end if $argc &gt; 0 printf &quot;Vector size = %u\n&quot;, $size printf &quot;Vector capacity = %u\n&quot;, $capacity printf &quot;Element &quot; whatis $arg0._M_impl._M_start endenddocument pvector Prints std::vector&lt;T&gt; information. Syntax: pvector &lt;vector&gt; &lt;idx1&gt; &lt;idx2&gt; Note: idx, idx1 and idx2 must be in acceptable range [0..&lt;vector&gt;.size()-1]. Examples: pvector v - Prints vector content, size, capacity and T typedef pvector v 0 - Prints element[idx] from vector pvector v 1 2 - Prints elements in range [idx1..idx2] from vectorend## std::list&lt;&gt;#define plist if $argc == 0 help plist else set $head = &amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 2 printf &quot;elem[%u]: &quot;, $size p *($arg1*)($current + 1) end if $argc == 3 if $size == $arg2 printf &quot;elem[%u]: &quot;, $size p *($arg1*)($current + 1) end end set $current = $current._M_next set $size++ end printf &quot;List size = %u \n&quot;, $size if $argc == 1 printf &quot;List &quot; whatis $arg0 printf &quot;Use plist &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the list.\n&quot; end endenddocument plist Prints std::list&lt;T&gt; information. Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx Examples: plist l - prints list size and definition plist l int - prints all elements and list size plist l int 2 - prints the third element in the list (if exists) and list sizeenddefine plist_member if $argc == 0 help plist_member else set $head = &amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 3 printf &quot;elem[%u]: &quot;, $size p (*($arg1*)($current + 1)).$arg2 end if $argc == 4 if $size == $arg3 printf &quot;elem[%u]: &quot;, $size p (*($arg1*)($current + 1)).$arg2 end end set $current = $current._M_next set $size++ end printf &quot;List size = %u \n&quot;, $size if $argc == 1 printf &quot;List &quot; whatis $arg0 printf &quot;Use plist_member &lt;variable_name&gt; &lt;element_type&gt; &lt;member&gt; to see the elements in the list.\n&quot; end endenddocument plist_member Prints std::list&lt;T&gt; information. Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx Examples: plist_member l int member - prints all elements and list size plist_member l int member 2 - prints the third element in the list (if exists) and list sizeend## std::map and std::multimap#define pmap if $argc == 0 help pmap else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Map &quot; whatis $tree printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot; end if $argc == 3 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u].left: &quot;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p *($arg2*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 4 set $idx = $arg3 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u].left: &quot;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p *($arg2*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end if $argc == 5 set $idx1 = $arg3 set $idx2 = $arg4 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) set $valueLeft = *($arg1*)$value set $valueRight = *($arg2*)($value + sizeof($arg1)) if $valueLeft == $idx1 &amp;&amp; $valueRight == $idx2 printf &quot;elem[%u].left: &quot;, $i p $valueLeft printf &quot;elem[%u].right: &quot;, $i p $valueRight set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end printf &quot;Map size = %u\n&quot;, $tree_size endenddocument pmap Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well. Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap m - prints map size and definition pmap m int int - prints all elements and map size pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map sizeenddefine pmap_member if $argc == 0 help pmap_member else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Map &quot; whatis $tree printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot; end if $argc == 5 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u].left: &quot;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p (*($arg3*)$value).$arg4 if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 6 set $idx = $arg5 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u].left: &quot;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p (*($arg3*)$value).$arg4 set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end printf &quot;Map size = %u\n&quot;, $tree_size endenddocument pmap_member Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well. Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2 pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalueend## std::set and std::multiset#define pset if $argc == 0 help pset else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Set &quot; whatis $tree printf &quot;Use pset &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the set.\n&quot; end if $argc == 2 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u]: &quot;, $i p *($arg1*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 3 set $idx = $arg2 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u]: &quot;, $i p *($arg1*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end printf &quot;Set size = %u\n&quot;, $tree_size endenddocument pset Prints std::set&lt;T&gt; or std::multiset&lt;T&gt; information. Works for std::multiset as well. Syntax: pset &lt;set&gt; &lt;T&gt; &lt;val&gt;: Prints set size, if T defined all elements or just element(s) having val Examples: pset s - prints set size and definition pset s int - prints all elements and the size of s pset s int 20 - prints the element(s) with value = 20 (if any) and the size of send## std::dequeue#define pdequeue if $argc == 0 help pdequeue else set $size = 0 set $start_cur = $arg0._M_impl._M_start._M_cur set $start_last = $arg0._M_impl._M_start._M_last set $start_stop = $start_last while $start_cur != $start_stop p *$start_cur set $start_cur++ set $size++ end set $finish_first = $arg0._M_impl._M_finish._M_first set $finish_cur = $arg0._M_impl._M_finish._M_cur set $finish_last = $arg0._M_impl._M_finish._M_last if $finish_cur &lt; $finish_last set $finish_stop = $finish_cur else set $finish_stop = $finish_last end while $finish_first != $finish_stop p *$finish_first set $finish_first++ set $size++ end printf &quot;Dequeue size = %u\n&quot;, $size endenddocument pdequeue Prints std::dequeue&lt;T&gt; information. Syntax: pdequeue &lt;dequeue&gt;: Prints dequeue size, if T defined all elements Deque elements are listed &quot;left to right&quot; (left-most stands for front and right-most stands for back) Example: pdequeue d - prints all elements and size of dend## std::stack#define pstack if $argc == 0 help pstack else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = $size - 1 while $i &gt;= 0 p *($start_cur + $i) set $i-- end printf &quot;Stack size = %u\n&quot;, $size endenddocument pstack Prints std::stack&lt;T&gt; information. Syntax: pstack &lt;stack&gt;: Prints all elements and size of the stack Stack elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop) Example: pstack s - prints all elements and the size of send## std::queue#define pqueue if $argc == 0 help pqueue else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = 0 while $i &lt; $size p *($start_cur + $i) set $i++ end printf &quot;Queue size = %u\n&quot;, $size endenddocument pqueue Prints std::queue&lt;T&gt; information. Syntax: pqueue &lt;queue&gt;: Prints all elements and the size of the queue Queue elements are listed &quot;top to bottom&quot; (top-most element is the first to come on pop) Example: pqueue q - prints all elements and the size of qend## std::priority_queue#define ppqueue if $argc == 0 help ppqueue else set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start set $i = $size - 1 while $i &gt;= 0 p *($arg0.c._M_impl._M_start + $i) set $i-- end printf &quot;Priority queue size = %u\n&quot;, $size printf &quot;Priority queue capacity = %u\n&quot;, $capacity endenddocument ppqueue Prints std::priority_queue&lt;T&gt; information. Syntax: ppqueue &lt;priority_queue&gt;: Prints all elements, size and capacity of the priority_queue Priority_queue elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop) Example: ppqueue pq - prints all elements, size and capacity of pqend## std::bitset#define pbitset if $argc == 0 help pbitset else p /t $arg0._M_w endenddocument pbitset Prints std::bitset&lt;n&gt; information. Syntax: pbitset &lt;bitset&gt;: Prints all bits in bitset Example: pbitset b - prints all bits in bend## std::string#define pstring if $argc == 0 help pstring else printf &quot;String \t\t\t= \&quot;%s\&quot;\n&quot;, $arg0._M_data() printf &quot;String size/length \t= %u\n&quot;, $arg0._M_rep()._M_length printf &quot;String capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity printf &quot;String ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount endenddocument pstring Prints std::string information. Syntax: pstring &lt;string&gt; Example: pstring s - Prints content, size/length, capacity and ref-count of string send## std::wstring#define pwstring if $argc == 0 help pwstring else call printf(&quot;WString \t\t= \&quot;%ls\&quot;\n&quot;, $arg0._M_data()) printf &quot;WString size/length \t= %u\n&quot;, $arg0._M_rep()._M_length printf &quot;WString capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity printf &quot;WString ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount endenddocument pwstring Prints std::wstring information. Syntax: pwstring &lt;wstring&gt; Example: pwstring s - Prints content, size/length, capacity and ref-count of wstring send## C++ related beautifiers (optional)#set print pretty onset print object onset print static-members onset print vtbl onset print demangle onset demangle-style gnu-v3set print sevenbit-strings off## pointer array#define parray if $argc &lt; 1 help parray else if $argc == 1 set $i = 0 set $current = *($arg0 + $i) while $current != 0 printf &quot;[array element number: %u] \n&quot;, $i p *$current set $i++ set $current = *($arg0 + $i) end printf &quot;array size = %u\n&quot;, $i end if $argc == 2 printf &quot;arg1 is %u\n&quot;, $arg1 printf &quot;[array element number: %u] \n&quot;, $arg1 p *(*($arg0 + $arg1)) end if $argc == 3 set $i = $arg1 printf &quot; idx1 = %u, idx2 = %u \n&quot; , $i, $arg2 while $i &lt; $arg2 printf &quot;[array element number: %u] \n&quot;, $i p *(*($arg0 + $i)) set $i++ end printf &quot;array size = %u\n&quot;, $i end endenddocument parray Prints array infomation. Syntax: parray &lt;array&gt; [elemnum | [idx1, idx2]] Example: parray array parray array elenum parray array idx1 idx2end]]></content>
      <categories>
        <category>gdb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux自旋锁]]></title>
    <url>%2F2019%2F01%2F10%2Flinux%E8%87%AA%E6%97%8B%E9%94%81%2F</url>
    <content type="text"><![CDATA[自旋锁 读写自旋锁]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[thinking in c++ reflection]]></title>
    <url>%2F2019%2F01%2F08%2Fthinking-in-c-reflection%2F</url>
    <content type="text"><![CDATA[什么是反射Java是原生支持反射机制的，通过Class类可以通过名称获得类对象，进一步操作。Python也支持反射机制，可以通过globals()获取对象map，也可以通过inspect模块，提供了自省的方法。但是C++呢？C++原生不支持反射机制，RTTI（运行时类型识别）也仅仅提供了类型的判断。 开闭原则是设计模式的原则之一，对修改是封闭，对扩展开放。一般来说，需要我们对类进行抽象，针对抽象的类进行编程。许多的设计模式中，为了能够满足这一点，我们常常使用一个配置文件，映射字符串与类型。然后通过反射机制获得字符串对应的对象，然后自动装配已达到易于扩展的目的。 反射作用 获取类型的信息，包括属性、方法动态调用方法动态构造对象从程序集中获得类型 使用场景 序列化（Serialization 数据写磁盘）和数据绑定（Data Binding）远程方法调用（RMI）对象/关系数据映射（O/R mapping） 实现思路 使用map，映射字符串和生产函数每次构造新类型时，将生产函数注册到map中工厂函数通过map获得生产函数，建造不同的对象 code 参考boost qt Mirror C++ reflection library RTTR]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ping的过程]]></title>
    <url>%2F2018%2F12%2F26%2Fping%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对于Ping的过程，你真的了解吗？]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试练习]]></title>
    <url>%2F2018%2F12%2F22%2F%E9%9D%A2%E8%AF%95%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[http://blog.sina.com.cn/s/blog_aeec1b700102uwqb.html linux tsc 分布式锁 osi七层网络模型，五层网络模型，每次层分别有哪些协议死锁产生的条件， 以及如何避免死锁，银行家算法，产生死锁后如何解决如何判断链表有环虚拟机类加载机制，双亲委派模型，以及为什么要实现双亲委派模型虚拟机调优参数拆箱装箱的原理JVM垃圾回收算法CMS G1hashset和hashmap的区别，haspmap的底层实现put操作，扩容机制，currenthashmap如何解决线程安全,1.7版本以及1.8版本的不同md5加密的原理有多少种方法可以让线程阻塞，能说多少说多少synchronized和reetrantlock锁AQS同步器框架，countdowmlatch，cyclebarrier，semaphore，读写锁 02—二面 B-Tree索引，myisam和innodb中索引的区别BIO和NIO的应用场景讲讲threadlocal数据库隔离级别，每层级别分别用什么方法实现，三级封锁协议,共享锁排它锁，mvcc多版本并发控制协议，间隙锁数据库索引？B+树？为什么要建索引？什么样的字段需要建索引，建索引的时候一般考虑什么？索引会不会使插入、删除作效率变低，怎么解决？数据库表怎么设计的？数据库范式？设计的过程中需要注意什么？共享锁与非共享锁、一个事务锁住了一条数据，另一个事务能查吗？Spring bean的生命周期？默认创建的模式是什么？不想单例怎么办？ 03—三面 高并发时怎么限流线程池的拒接任务策略springboot的启动流程集群、负载均衡、分布式、数据一致性的区别与关系数据库如果让你来垂直和水平拆分，谁先拆分，拆分的原则有哪些(单表数据量多大拆)最后谈谈Redis、Kafka、 Dubbo，各自的设计原理和应用场景 头条一面 1.讲讲jvm运行时数据库区2.讲讲你知道的垃圾回收算法3.jvm内存模型jmm4.内存泄漏与内存溢出的区别 select、epool 的区别？底层的数据结构是什么？6.mysql数据库默认存储引擎，有什么优点7.优化数据库的方法，从sql到缓存到cpu到操作系统，知道多少说多少8.什么情景下做分表，什么情景下做分库9.linkedList与arrayList区别 适用场景10.array list是如何扩容的 volatile 关键字的作用？Java 内存模型？12.java lock的实现，公平锁、非公平锁13.悲观锁和乐观锁，应用中的案例，mysql当中怎么实现，java中的实现 02—头条二面 Java 内存分配策略？多个线程同时请求内存，如何分配？Redis 底层用到了哪些数据结构？使用 Redis 的 set 来做过什么？Redis 使用过程中遇到什么问题？搭建过 Redis 集群吗？如何分析“慢查询”日志进行 SQL/索引 优化？MySQL 索引结构解释一下？（B+ 树）MySQL Hash 索引适用情况？举下例子？ 03—头条三面 如何保证数据库与redis缓存一致的Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？如何保证 Redis 高并发、高可用？Redis 的主从复制原理，以及Redis 的哨兵原理？如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。MySQL数据库主从同步怎么实现？秒杀模块怎么设计的，如何压测，抗压手段]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2018%2F12%2F19%2FMakefile%2F</url>
    <content type="text"><![CDATA[Makefile 包含 变量/注释/文件指示/显式规则/隐晦规则 变量= 基本赋值, 可以使用后面的变量:= 覆盖之前的值, 前面的变量不能使用后面的变量?= 如果没被赋值过就赋值+= 追加赋值，用空格隔开方式追加$(shell cmd) 用shell函数赋值\$(var:=) 替换环境变量可以直接使用嵌套调用Makefile, export 声明变量传递给下一层Makefile 123456789101112131415161718192021# 赋值foo = $(bar)bar = a.cpp b.cpp# 嵌套赋值会报错A = $(B)B = $(A)# := 赋值, 只是不能使用后面的变量, foo是a.cppfoo := $(bar) a.cppbar := b.cpp# ?= 如果foo未被定义过则赋值, 否则什么也不做foo ?= bar # += 追加foo = a.cppfoo += b.cpp# shell赋值dir = $(shell pwd)# 替换 将字符串结尾的a替换成b, 结尾指空格和结束符$(var:a=b)$(var:%.o=%.c)# @echo 打印变量, 没有@时会回显命令@echo "bar=&gt;$(bar)" 目标变量foo.o : foo.cpp$(CXX) $(CFLAG) foo.cpp 注释12# 注释bar = a.cpp 文件指指示12# 包含NGCmakeinclude NGCmake 函数1$(function &lt;arg&gt;) 或 $&#123;function &lt;arg&gt;&#125; 字符串操作 函数 名称 功能 返回 $(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;) 字符串替换 把text里from替换成to 替换后的字符串 $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 模式字符串替换 text中以空格、回车、TAB是否符合pattern, 若符合, 用replacement替换 替换后的字符串 $(strip &lt;string&gt;) 去空格 去掉开头和结尾空字符 处理后的字符串 $(findstring &lt;find&gt;,&lt;in&gt;) 查找字符串 在in中查找find 找到返回find，否则返回空 $(filter &lt;pattern…&gt;,&lt;text&gt;) 过滤函数 保留符合pattern的单词，可以有多个模式 符合的字符串 $(filter-out &lt;pattern…&gt;,&lt;text&gt;) 去除函数 去除符合模式的单词 处理后的字符串 $(srot &lt;list&gt;) 排序 单词按升序排 排序后字符串 $(word &lt;n&gt;,&lt;text&gt;) 取单词 取第n个单词, 从1开始 单词或空 $(wordlist &lt;n&gt;,&lt;m&gt;,&lt;text&gt;) 取单词 去n到m的单词 单词或空 $(words &lt;text&gt;) 统计个数 统计单词个数 单词数量 $(firstword &lt;text&gt;) 取首个单词 等价于$(word 1,&lt;text&gt;) 首个单词 1CFLAGS+=$(patsubst %,-I%,$(subst :, ,$(VPATH))) 文件名操作 函数 名称 功能 返回 $(dir &lt;names…&gt;) 取目录 取出names反斜杠的目录 目录或./ $(notdir &lt;names…&gt;) 取文件名 去掉反斜杠前面的目录部分 文件名序列 $(suffix &lt;names…&gt;) 取文件序列后缀 去掉非后缀部分 .cpp等后缀 或 空 $(basename &lt;names…&gt;) 取文件序列前缀 去掉后缀部分 $(addsuffix &lt;suffix&gt;,&lt;names…&gt;) 加后缀 加后缀 文件序列名 $(addprefix &lt;prefix&gt;,&lt;names…&gt;) 加前缀 加前缀 文件序列名 $(join &lt;list1&gt;,&lt;list2&gt;) 链接 list1+list2 链接后的字符串 控制和调用 $(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)循环执行 123names := a b c dfiles := $(foreach n,$(names),$(n).o)# ouput: a.o b.o c.o d.o $(if &lt;condition&gt;,&lt;then-part&gt;) 12345ifeq ($(CXX), gcc)$(CXX) -o test $(object) $(lib_gcc)else$(CXX) -o test $(object) $(lib_others)endif $(call &lt;expression&gt;,&lt;param1&gt;,&lt;param2&gt;…)创建新的函数 1234reserve := $(1) $(2)f = $(call reserve,a,b)f的值是a b $(origin &lt;var&gt;)变量是哪里来的, undefined, default, file, command line, override, automatic shell函数text := $(shell cat foo) 控制Make函数 函数 名称 功能 返回 $(error &lt;text…&gt;) 产生一个致命错误 提示错误信息 提示 $(warning &lt;text…&gt;) 输出告警信息 提示告警信息 提示 显示规则123# 通配符: */%/[...]targest : prerequisites command 文件搜索// 为符合模式的文件指定搜索目录vpath // 为符合模式的文件清除搜索目录vpath // 清楚搜索目录vpath 伪目标1234567891011121314151617181920212223242526272829303132# make clean会执行 "rm -rf *.o"# 但如果当前目录下存在clean文件, 规则没有依赖文件，目标被认为是最新的，不会去执行rm命令clean: rm -rf *.o # .PHONY 显示的标记一个伪目标, 还能避免重名# 工作目录下存在clean文件也会执行rm命令.PHONY: cleanclean: rm -rf *.o # 多个伪目标，伪目标之间有依赖# make cleanobj 相当于一个子程序.PHONY: cleanall cleanobj cleandiff cleanall : cleanobj cleandiff rm program cleanobj : rm *.o cleandiff : rm *.diff # 多个伪目标，每个伪目标有自己的依赖# make all, 重建all依赖的文件(prog1,prog2,prog3)all: prog1 prog2 prog3.PHONY: all.PHONY : all prog1 : prog1.o utils.o cc -o prog1 prog1.o utils.o prog2 : prog2.o cc -o prog2 prog2.o prog3 : prog3.o cc -o prog3 prog3.o 静态规则&lt;targets…&gt; : : … 1234object = foo.o bar.o all: $(object)$(object): %.o: %.c $CC -c $(FLAG) $&lt; -o $@ 自动生成依赖关系cc -M name.c 会生成name.d 依赖关系文件 隐含规则自动推到 语言 规则 命令 C n.o 目标文件自动退到依赖n.c $(CC) -c $(CPPFLAGS) $(CFLAGS) C++ n.o 目标文件自动退到依赖n.cc $(CXX) -c $(CPPFLAGS) $(CFLAGS) 模式规则规则中包含%, 自动化变量在模式规则中使用12%.o : %.c$(CC) -c $(CFLAGS) $(CPPFLAGS) $&amp;lt; -o $@ 自动化变量 变量 含义 $@ 目标文件集, 在模式规则中表示符合模式定义的集合 $% 目标是库文件(.a/.lib), 则表示目标成员; 否则为空 $&lt; 依赖列表的第一个文件名称, 依赖目标是以模式(%)定义,则表示符合模式的文件集 $? 时间戳比目标文件新的依赖文件列表, 空格分隔 $^ 依赖目标集合, 同一个文件不可重复 $+ 依赖目标集合, 同一个文件可重复 $* 目标模式中”%”及其之前部分 12foo.a : bar.o $% 表示 bar.o, $@ 表示 foo.a 重载内建隐含规则实践分析]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法和数据结构-树]]></title>
    <url>%2F2018%2F12%2F18%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树的类别二叉树、二叉搜索树、平衡二叉树、红黑树、B树、B+树、字典树 二叉树二叉树，插入有序的数据，会退化成链表，需要调整数据均匀分布，保证平衡性(搜索效率)书的查找性能取决于树的高度 二叉搜索树(BST)平衡二叉树(AVL)windows对进程地址空间的管理用到了AVL树 红黑树广泛用在C++的STL中, 如map和set. B树多路搜索树，每个节点可以拥有多于两个孩子节点。M路的B树最多有用M个孩子节点。 设计成多路是为了降低树的高度，但是无限多路时退化成有序数组。一般用于文件索引，为什么不用红黑树和有序数组？文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。B树索引可以每次加载一个节点，一步一步往下找。在内存中黑红树比B树效率高，但涉及到磁盘，B树更优。 B+树在B树基础上进行改造，数据都在叶子结点，同时叶子结点之间用指针形成链表。 为什么要这样设计？这也是和业务场景相关的，数据库中select数据，不一定只选一条，很多时候会选多条，比如按照id排序后选10条。如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。 选出7~19，在叶子节点中就可以找到。 字典树(Trie)用在统计和排序大量字符串，如自动机一个典型应用是前缀匹配，比如在我们输入时，搜索引擎会给予提示字典树]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库水平、垂直拆分]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[水平、垂直分库]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[死锁和银行家算法]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%AD%BB%E9%94%81%E5%92%8C%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MD5加密算法]]></title>
    <url>%2F2018%2F12%2F01%2FMD5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是MD5加密算法MD5消息摘要算法是一种被广泛使用的密码散列函数, 属Hash算法一类, MD5算法对输入任意长度的消息进行运行，产生一个128位(16字节)的散列值(hash value)。 应用场景文件一致性验证MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。 1251_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%md5sum test.cpp 731b8735653acd4c4cdbd05883fe90d1 test.cpp 数字签名MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。 算法原理以下所描述的消息长度、填充数据都以位(Bit)为单位，字节序为小端字节。 数据填充对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满足X mod 512=448。根据此公式得出需要填充的数据长度。填充方法：在消息后面进行填充，填充第一位为1，其余为0。 添加消息长度在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。在此步骤进行完毕后，最终消息长度就是512的整数倍 数据处理准备需要用到的数据： 4个常数： A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476; 4个函数：F(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z); G(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z)); H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z)); 把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行 计算，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个 变量为最后的结果，即MD5值。 具体计算的实现较为复杂，建议查阅相关书籍，下面给出在C++上的实现代码。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#ifndef MD5H#define MD5H#include &lt;math.h&gt;#include &lt;Windows.h&gt;void ROL(unsigned int &amp;s, unsigned short cx); //32位数循环左移实现函数void ltob(unsigned int &amp;i); //B\L互转，接受UINT类型unsigned int* MD5(const char* mStr); //接口函数，并执行数据填充，计算MD5时调用此函数#endif#include &quot;MD5.h&quot;/*4组计算函数*/inline unsigned int F(unsigned int X, unsigned int Y, unsigned int Z)&#123; return (X &amp; Y) | ((~X) &amp; Z);&#125;inline unsigned int G(unsigned int X, unsigned int Y, unsigned int Z)&#123; return (X &amp; Z) | (Y &amp; (~Z));&#125;inline unsigned int H(unsigned int X, unsigned int Y, unsigned int Z)&#123; return X ^ Y ^ Z;&#125;inline unsigned int I(unsigned int X, unsigned int Y, unsigned int Z)&#123; return Y ^ (X | (~Z));&#125;/*4组计算函数结束*//*32位数循环左移实现函数*/void ROL(unsigned int &amp;s, unsigned short cx)&#123; if (cx &gt; 32)cx %= 32; s = (s &lt;&lt; cx) | (s &gt;&gt; (32 - cx)); return;&#125;/*B\L互转，接收UINT类型*/void ltob(unsigned int &amp;i)&#123; unsigned int tmp = i;//保存副本 byte *psour = (byte*)&amp;tmp, *pdes = (byte*)&amp;i; pdes += 3;//调整指针，准备左右调转 for (short i = 3; i &gt;= 0; --i) &#123; CopyMemory(pdes - i, psour + i, 1); &#125; return;&#125;/*MD5循环计算函数，label=第几轮循环（1&lt;=label&lt;=4），lGroup数组=4个种子副本，M=数据（16组32位数指针）种子数组排列方式: --A--D--C--B--，即 lGroup[0]=A; lGroup[1]=D; lGroup[2]=C; lGroup[3]=B;*/void AccLoop(unsigned short label, unsigned int *lGroup, void *M)&#123; unsigned int *i1, *i2, *i3, *i4, TAcc, tmpi = 0; //定义:4个指针； T表累加器； 局部变量 typedef unsigned int(*clac)(unsigned int X, unsigned int Y, unsigned int Z); //定义函数类型 const unsigned int rolarray[4][4] = &#123; &#123; 7, 12, 17, 22 &#125;, &#123; 5, 9, 14, 20 &#125;, &#123; 4, 11, 16, 23 &#125;, &#123; 6, 10, 15, 21 &#125; &#125;;//循环左移-位数表 const unsigned short mN[4][16] = &#123; &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 &#125;, &#123; 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12 &#125;, &#123; 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2 &#125;, &#123; 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9 &#125; &#125;;//数据坐标表 const unsigned int *pM = static_cast&lt;unsigned int*&gt;(M);//转换类型为32位的Uint TAcc = ((label - 1) * 16) + 1; //根据第几轮循环初始化T表累加器 clac clacArr[4] = &#123; F, G, H, I &#125;; //定义并初始化计算函数指针数组 /*一轮循环开始（16组-&gt;16次）*/ for (short i = 0; i &lt; 16; ++i) &#123; /*进行指针自变换*/ i1 = lGroup + ((0 + i) % 4); i2 = lGroup + ((3 + i) % 4); i3 = lGroup + ((2 + i) % 4); i4 = lGroup + ((1 + i) % 4); /*第一步计算开始: A+F(B,C,D)+M[i]+T[i+1] 注:第一步中直接计算T表*/ tmpi = (*i1 + clacArr[label - 1](*i2, *i3, *i4) + pM[(mN[label - 1][i])] + (unsigned int)(0x100000000UL * abs(sin((double)(TAcc + i))))); ROL(tmpi, rolarray[label - 1][i % 4]);//第二步:循环左移 *i1 = *i2 + tmpi;//第三步:相加并赋值到种子 &#125; return;&#125;/*接口函数，并执行数据填充*/unsigned int* MD5(const char* mStr)&#123; unsigned int mLen = strlen(mStr); //计算字符串长度 if (mLen &lt; 0) return 0; unsigned int FillSize = 448 - ((mLen * 8) % 512); //计算需填充的bit数 unsigned int FSbyte = FillSize / 8; //以字节表示的填充数 unsigned int BuffLen = mLen + 8 + FSbyte; //缓冲区长度或者说填充后的长度 unsigned char *md5Buff = new unsigned char[BuffLen]; //分配缓冲区 CopyMemory(md5Buff, mStr, mLen); //复制字符串到缓冲区 /*数据填充开始*/ md5Buff[mLen] = 0x80; //第一个bit填充1 ZeroMemory(&amp;md5Buff[mLen + 1], FSbyte - 1); //其它bit填充0，另一可用函数为FillMemory unsigned long long lenBit = mLen * 8ULL; //计算字符串长度，准备填充 CopyMemory(&amp;md5Buff[mLen + FSbyte], &amp;lenBit, 8); //填充长度 /*数据填充结束*/ /*运算开始*/ unsigned int LoopNumber = BuffLen / 64; //以16个字为一分组，计算分组数量 unsigned int A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;//初始4个种子，小端类型 unsigned int *lGroup = new unsigned int[4]&#123; A, D, C, B&#125;; //种子副本数组,并作为返回值返回 for (unsigned int Bcount = 0; Bcount &lt; LoopNumber; ++Bcount) //分组大循环开始 &#123; /*进入4次计算的小循环*/ for (unsigned short Lcount = 0; Lcount &lt; 4;) &#123; AccLoop(++Lcount, lGroup, &amp;md5Buff[Bcount * 64]); &#125; /*数据相加作为下一轮的种子或者最终输出*/ A = (lGroup[0] += A); B = (lGroup[3] += B); C = (lGroup[2] += C); D = (lGroup[1] += D); &#125; /*转换内存中的布局后才能正常显示*/ ltob(lGroup[0]); ltob(lGroup[1]); ltob(lGroup[2]); ltob(lGroup[3]); delete[] md5Buff; //清除内存并返回 return lGroup;&#125; 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &quot;MD5.h&quot;int main(int argc, char **argv)&#123; char tmpstr[256], buf[4][10]; std::cout &lt;&lt; &quot;请输入要加密的字符串：&quot;; std::cin &gt;&gt; tmpstr; unsigned int* tmpGroup = MD5(tmpstr); sprintf_s(buf[0], &quot;%8X&quot;, tmpGroup[0]); sprintf_s(buf[1], &quot;%8X&quot;, tmpGroup[3]); sprintf_s(buf[2], &quot;%8X&quot;, tmpGroup[2]); sprintf_s(buf[3], &quot;%8X&quot;, tmpGroup[1]); std::cout &lt;&lt;&quot;MD5:&quot;&lt;&lt; buf[0] &lt;&lt; buf[1] &lt;&lt; buf[2] &lt;&lt; buf[3] &lt;&lt; std::endl; delete[] tmpGroup; return 0; //在此下断点才能看到输出的值&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++11特性]]></title>
    <url>%2F2018%2F11%2F28%2Fc-11%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[语法糖关键字auto auto声明的变量必须要初始化，否则编译器不能判断变量的类型auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数不会影响编译、运行效果 decltype类型指示符123int a = 1;int&amp; b = a;decltype(a) c = 2; nullptr 空指针, 类型是指针, 主要用于重载 function123456789101112131415161718192021222324#include &lt;functional&gt;int add(int a, int b)&#123; return a+b;&#125;class Add&#123; public: int operator()(int x,int y) &#123; return x+y; &#125;&#125;;int main()&#123; function&lt;int(int, int)&gt; f1 = add; // 函数 function&lt;int(int, int)&gt; f2 = Add(); // 类对象 function&lt;int(int, int)&gt; f2 = [](int a, int b)&#123; return a+b; &#125;; //lambda表达式 cout&lt;&lt; f1(a,b) &lt;&lt; f2(a,b) &lt;&lt; f3(a,b) &lt;&lt; endl;&#125; 范围for语句123456789vector&lt;int&gt; vct&#123;1,2,3,4,5&#125;;for(auto &amp;num : vct)&#123; num +1;&#125;for(auto num : vct)&#123; cout&lt;&lt; num &lt;&lt; endl;&#125; decltype推导规则：1 exp 是标识符、类访问表达式，decltype(exp) 和 exp 的类型一致2 exp 是函数调用，decltype(exp) 和返回值的类型一致3 其他情况，若 exp 是一个左值，则 decltype(exp) 是 exp 类型的左值引用，否则和 exp 类型一致 2 如果e是一个将亡值，那么decltype（e）为T&amp;&amp;3 如果e是一个左值，那么decltype（e）为T&amp;4 decltype（e）为T 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ------------------------------------------------// 规则1 标识符表达式和类访问表达式class Foo&#123; public: static const int Number = 0; int x;&#125;;int n = 0;volatile const int &amp; x = n;decltype(n) a = n; // a -&gt; intdecltype(x) b = n; // b -&gt; const volatile int &amp;decltype(Foo::Number) c = 0; // c -&gt; const intFoo foo;decltype(foo.x) d = 0; // d -&gt; int，类访问表达式// ------------------------------------------------// 规则2 函数调用(非标识符表达式，也非类访问表达式)int&amp; func_int_r(void); // 左值（lvalue，可简单理解为可寻址值）int&amp;&amp; func_int_rr(void); // x值（xvalue，右值引用本身是一个xvalue）int func_int(void); // 纯右值（prvalue，将在后面的章节中讲解）const int&amp; func_cint_r(void); // 左值const int&amp;&amp; func_cint_rr(void); // x值const int func_cint(void); // 纯右值const Foo func_cfoo(void); // 纯右值// 下面是测试语句int x = 0;decltype(func_int_r()) a1 = x; // a1 -&gt; int &amp;decltype(func_int_rr()) b1 = 0; // b1 -&gt; int &amp;&amp;decltype(func_int()) c1 = 0; // c1 -&gt; intdecltype(func_cint_r()) a2 = x; // a2 -&gt; const int &amp;decltype(func_cint_rr()) b2 = 0; // b2 -&gt; const int &amp;&amp;// 对于纯右值而言，只有类类型可以携带 cv 限定符，此外则一般忽略掉 cv 限定decltype(func_cint()) c2 = 0; // c2 -&gt; int decltype(func_cfoo()) ff = Foo(); // ff -&gt; const Foo// ------------------------------------------------// 规则3 带括号的表达式和加法运算表达式(其他情况)struct Foo &#123; int x; &#125;;const Foo foo = Foo();decltype(foo.x) a = 0; // a -&gt; intdecltype((foo.x)) b = a; // b -&gt; const int &amp;int n = 0, m = 0;decltype(n + m) c = 0; // c -&gt; intdecltype(n += m) d = c; // d -&gt; int &amp; std::atomiclambda表达式 text [ capture ] ( params ) mutable exception attribute -&gt; ret { body } [ capture ] ( params ) -&gt; ret { body } [ capture ] ( params ) { body } [ capture ] { body } [ capture ] desc [a,&amp;b] a变量以值的方式呗捕获，b以引用的方式被捕获 [this] 以值的方式捕获 this 指针 [&amp;] 以引用的方式捕获所有的外部自动变量 [=] 以值的方式捕获所有的外部自动变量 [] 不捕获外部的任何变量 123456int main()&#123; int boys=4, girls=3; auto totalChild = [=]()-&gt;int&#123;return boys+grils;&#125;; cout&lt;&lt; totalChild() &lt;&lt; endl;&#125; 右值引用：移动语义与完美转发有指针成员的类，拷贝构造时，会浪费资源。因此引入了移动语义。1234567891011121314&#123;a = b + c;# 等号左边是左值，等号右边是右值# 可以取地址,有名字的就是左值(&amp;a)，反之就是右值(a+b)&#125;MyString(MyString&amp;&amp; str) &#123; std::cout &lt;&lt; &quot;Move Ctor source from &quot; &lt;&lt; str._data &lt;&lt; endl; _len = str._len; _data = str._data; str._len = 0; str._data = NULL;&#125; std::movestl容器智能指针线程12345#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;atomic&gt; 现代C++教程，快速上手c++11/14/17/20 参考特性说明]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Big-O]]></title>
    <url>%2F2018%2F11%2F26%2FBig-O%2F</url>
    <content type="text"><![CDATA[from web]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--UnitTest++]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-UnitTest%2F</url>
    <content type="text"></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--sqlite3]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-sqlite3%2F</url>
    <content type="text"><![CDATA[SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。 教程]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--tcmalloc]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-tcmalloc%2F</url>
    <content type="text"><![CDATA[glibc每一种分配器都宣称自己快（fast）、可拓展（scalable）、效率高（memory efficient） 数据结构 头部 名称 说明 Arena header malloc_state 包括bins、top chunk、last remainder chunk等 Heap Header heap_info 每个thread arena 维护一个或多个堆 Chunk header malloc_chunk 每个堆被分为若干 chunk, 每个都有自己的 chunk header tcmalloctcmalloc是一个内存分配器，管理堆内存，主要影响malloc和free，用于降低频繁分配、释放内存造成的损耗,并且有效的控制内存碎片。 解决了什么问题实现原理]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--libevent]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-libevent%2F</url>
    <content type="text"><![CDATA[使用简介 初始化 event_init()/event_base_new() 通过event对象对文件描述符进行监控 event_set()/event_add()/event_dispatch() 读写I/O事件 bufferevent_enable()/bufferevent_disable(), bufferevent_read()/bufferevent_write() 定时事件 evtimer_set()/ evtimer_add()/ evtimer_del() 对文件描述符指定超时时间 timeout_set()/timeout_add()/timeout_del() 异步DNS evdns_init()/evdns_resolve_ipv4()/evdns_resolve_reverse() http server evhttp_new()/evhttp_bind_socket()/evhttp_set_cb()/evhttp_set_gencb() rpc server and clients 设计原理 基于Reactor模式 Handle 事件源, 如Linux下的文件描述符Event Handle 为事件处理提供一组有效接口, 对应绑定一个事件源Reactor 事件管理接口, 内部使用Event Demultiplexer注册/注销事件, 运行事件循环, 当事件就绪时, 调用对应回调函数Event Demultiplexer 事件多路分发机制, 由select,poll,epoll等实现 源码分析event用event_new创建时设置好监听事件/回调函数, 或event_set设置 点击显代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct event &#123; struct event_callback ev_evcallback; // 回调函数, event_base 调用 /* for managing timeouts */ union &#123; TAILQ_ENTRY(event) ev_next_with_common_timeout; int min_heap_idx; // 索引值指明该event结构体在堆的位置 &#125; ev_timeout_pos; // 定时事件 evutil_socket_t ev_fd; // 文件描述符 或 信号 struct event_base *ev_base; // 管理者指针 union &#123; // 用union节省内存, 只会用一种类型事件 /* used for io events */ struct &#123; LIST_ENTRY (event) ev_io_next; // 双向链表, 可以有多个文件描述符 struct timeval ev_timeout; &#125; ev_io; /* used by signal events */ struct &#123; LIST_ENTRY (event) ev_signal_next; short ev_ncalls; /* Allows deletes in callback */ short *ev_pncalls; &#125; ev_signal; &#125; ev_; // I/O 或 信号事件 short ev_events; // 关注的事件类型 I/O事件(EV_READ/EV_WRITE/EV_CLOSED)... short ev_res; /* result passed to event callback */ struct timeval ev_timeout; // 超时时间&#125;;struct event_callback &#123; TAILQ_ENTRY(event_callback) evcb_active_next; short evcb_flags; // event 的状态跟踪, 已经初始化等状态 ev_uint8_t evcb_pri; /* smaller numbers are higher priority */ ev_uint8_t evcb_closure; // 回调函数类型, 在初始化event时赋值 /* allows us to adopt for different types of events */ union &#123; void (*evcb_callback)(evutil_socket_t, short, void *); void (*evcb_selfcb)(struct event_callback *, void *); void (*evcb_evfinalize)(struct event *, void *); void (*evcb_cbfinalize)(struct event_callback *, void *); &#125; evcb_cb_union; void *evcb_arg;&#125;; event_base根据event_config创建event_base 点击显代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061struct event_config &#123; TAILQ_HEAD(event_configq, event_config_entry) entries; // 字符串, 避免使用指定的I/O复用函数 int n_cpus_hint; // CPU个数，仅提示 struct timeval max_dispatch_interval; int max_dispatch_callbacks; // int limit_callbacks_after_prio; // enum event_method_feature require_features; // 边缘触发/只用epoll等特性设置 enum event_base_config_flag flags; // 其他标记&#125;;enum event_base_config_flag &#123; EVENT_BASE_FLAG_NOLOCK = 0x01, // event_base 不分配锁, 多线程不安全 EVENT_BASE_FLAG_IGNORE_ENV = 0x02, // 不检测EVENT_*环境变量, EVENT_BASE_FLAG_STARTUP_IOCP = 0x04, // Windows必需的IOCP分发逻辑 EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08, // timeout判断使用缓存时间, 否则每次通过系统时间获取(性能相对低) EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10, // 若使用epoll, changelist可以更快的修改套接字监听状态 EVENT_BASE_FLAG_PRECISE_TIMER = 0x20 // USING_TIMERFD&#125;;struct event_base &#123; const struct eventop *evsel; // 从全局 eventop 中选择对应的I/O复用函数 void *evbase; // eventop 参数的对象 struct event_changelist changelist; // 变更 struct event_io_map io; // I/O 事件列表 struct event_signal_map sigmap; // 信号事件列表 struct min_heap timeheap; // 最小堆超时 struct evcallback_list *activequeues; // 需要执行的回调函数队列 &#125;;struct event_base *event_base_new_with_config(const struct event_config *cfg)&#123; ... for (i = 0; eventops[i] &amp;&amp; !base-&gt;evbase; i++) &#123; if (cfg != NULL) &#123; /* determine if this backend should be avoided */ if (event_config_is_avoided_method(cfg, eventops[i]-&gt;name)) continue; if ((eventops[i]-&gt;features &amp; cfg-&gt;require_features) != cfg-&gt;require_features) continue; &#125; /* also obey the environment variables */ if (should_check_environment &amp;&amp; event_is_method_disabled(eventops[i]-&gt;name)) continue; base-&gt;evsel = eventops[i]; // 选择I/O复用函数 base-&gt;evbase = base-&gt;evsel-&gt;init(base); &#125; ...&#125; event_add点击显代码 1234567891011121314151617181920212223242526272829303132333435363738intevent_add_nolock_(struct event *ev, const struct timeval *tv, int tv_is_absolute)&#123; ... if ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED|EV_SIGNAL)) &amp;&amp; !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE|EVLIST_ACTIVE_LATER))) &#123; if (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED)) res = evmap_io_add_(base, ev-&gt;ev_fd, ev); // 添加到I/O map, 一个fd可以有多个event else if (ev-&gt;ev_events &amp; EV_SIGNAL) res = evmap_signal_add_(base, (int)ev-&gt;ev_fd, ev); // 添加到信号 map if (res != -1) event_queue_insert_inserted(base, ev); // 把event注册到event_base中 if (res == 1) &#123; /* evmap says we need to notify the main thread. */ notify = 1; res = 0; &#125; &#125; ...&#125;// 改变event 的状态, event_base中事件个数static voidevent_queue_insert_inserted(struct event_base *base, struct event *ev)&#123; EVENT_BASE_ASSERT_LOCKED(base); if (EVUTIL_FAILURE_CHECK(ev-&gt;ev_flags &amp; EVLIST_INSERTED)) &#123; event_errx(1, &quot;%s: %p(fd &quot;EV_SOCK_FMT&quot;) already inserted&quot;, __func__, ev, EV_SOCK_ARG(ev-&gt;ev_fd)); return; &#125; INCR_EVENT_COUNT(base, ev-&gt;ev_flags); ev-&gt;ev_flags |= EVLIST_INSERTED;&#125; event_base_dispatch点击显代码 1234567891011121314151617181920212223242526272829303132intevent_base_loop(struct event_base *base, int flags)&#123; ... event_queue_make_later_events_active(base); clear_time_cache(base); res = evsel-&gt;dispatch(base, tv_p); // 调用系统的I/O复用函数, 添加到激活队列 if (res == -1) &#123; event_debug((&quot;%s: dispatch returned unsuccessfully.&quot;, __func__)); retval = -1; goto done; &#125; update_time_cache(base); timeout_process(base); if (N_ACTIVE_CALLBACKS(base)) &#123; int n = event_process_active(base); // 先从队列中删除, 再执行回调函数 if ((flags &amp; EVLOOP_ONCE) &amp;&amp; N_ACTIVE_CALLBACKS(base) == 0 &amp;&amp; n != 0) done = 1; &#125; else if (flags &amp; EVLOOP_NONBLOCK) done = 1; &#125; ...&#125; TAILQ_HEAD点击显代码 123456```&#123;% endfold %&#125;## HT_HEAD&#123;% fold 点击显代码 %&#125; ` ## 应用memcache spserver chrome]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--boost]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-boost%2F</url>
    <content type="text"></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式存储简介]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx功能简介]]></title>
    <url>%2F2018%2F11%2F20%2Fnginx%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Nginx功能 反向代理 负载均衡 HTTP服务器 正向代理 反向代理负载均衡HTTP服务器正向代理]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fork/vfork/clone]]></title>
    <url>%2F2018%2F11%2F20%2Ffork-vfork-clone%2F</url>
    <content type="text"><![CDATA[fork/vfork/clone 系统调用 描述 fork fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容 vfork vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行 clone Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone fork12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; int count = 1; int child; child = fork( ); if(child &lt; 0) &#123; perror(&quot;fork error : &quot;); &#125; else if(child == 0) // fork return 0 in the child process because child can get hid PID by getpid( ) &#123; printf(&quot;This is son, his count is: %d (%p). and his pid is: %d\n&quot;, ++count, &amp;count, getpid()); &#125; else // the PID of the child process is returned in the parent’s thread of execution &#123; printf(&quot;This is father, his count is: %d (%p), his pid is: %d\n&quot;, count, &amp;count, getpid()); &#125; return EXIT_SUCCESS;&#125;output:This is father, his count is: 1 (0x7ffe32f99cc8), his pid is: 26649This is son, his count is: 2 (0x7ffe32f99cc8). and his pid is: 26650 父子两个进程的pid不同，堆栈和数据资源都是完全的复制子进程改变了count的值，而父进程中的count没有被改变子进程与父进程count的地址（虚拟地址）是相同的（注意他们在内核中被映射的物理地址不同） 写入时复制(Copy-on-write)完全复制包含4个步骤, 非常耗时 为子进程的页表分配页帧为子进程的页分配页帧初始化子进程的页表把父进程的页复制到子进程相应的页中 写时复制则父进程和子进程共享页帧而不是复制页帧, 页面的访问权限也设成只读, 当发生修改时产生页面出错异常(page_fault int14)中断,此时CPU会执行系统提供的异常处理函数do_wp_page()来解决这个异常. do_wp_page()会对这块导致写入异常中断的物理页面进行取消共享操作,为写进程复制一新的物理页面, 使父进程A和子进程B各自拥有一块内容相同的物理页面. vfork123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; int count = 1; int child; // child = vfork( ); printf(&quot;Before create son, the father&apos;s count is:%d\n&quot;, count); if((child = vfork())&lt; 0) &#123; perror(&quot;fork error : &quot;); &#125; else if(child == 0) // fork return 0 in the child process because child can get hid PID by getpid( ) &#123; printf(&quot;This is son, his count is: %d (%p). and his pid is: %d\n&quot;, ++count, &amp;count, getpid()); exit(0); &#125; else // the PID of the child process is returned in the parent’s thread of execution &#123; printf(&quot;After son, This is father, his count is: %d (%p), his pid is: %d\n&quot;, ++count, &amp;count, getpid()); exit(0); &#125; return EXIT_SUCCESS;&#125;output:Before create son, the father&apos;s count is:1This is son, his count is: 2 (0x7ffe635dbc18). and his pid is: 26921After son, This is father, his count is: 3 (0x7ffe635dbc18), his pid is: 26920 vfork创建出的子进程（线程）共享了父进程的count变量，2者的count指向了同一个内存 注意事项： 由vfork创造出来的子进程还会导致父进程挂起，除非子进程exit或者execve才会唤起父进程由vfok创建出来的子进程共享了父进程的所有内存，包括栈地址，直至子进程使用execve启动新的应用程序为止由vfork创建出来得子进程不应该使用return返回调用者，或者使用exit()退出，但是它可以使用_exit()函数来退出 fork/vfork 区别联系 func copy run fork 子进程拷贝父进程的数据段，代码段 执行次序不确定 vfork 子进程与父进程共享数据段 保证子进程先运行 clone1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int clone(int (fn)(void ), void *child_stack, int flags, void *arg); #include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define FIBER_STACK 8192int a;void * stack;int do_something(void*)&#123; printf(&quot;This is son, the pid is:%d, the a is: %d\n&quot;, getpid(), ++a); free(stack); exit(1);&#125;int main()&#123; void * stack; a = 1; stack = malloc(FIBER_STACK);//为子进程申请系统堆栈 if(!stack) &#123; printf(&quot;The stack failed\n&quot;); exit(0); &#125; printf(&quot;creating son thread!!!\n&quot;); clone(&amp;do_something, (char *)stack + FIBER_STACK, CLONE_VM|CLONE_VFORK, 0);//创建子线程 printf(&quot;This is father, my pid is: %d, the a is: %d\n&quot;, getpid(), a); exit(1);&#125;output:creating son thread!!!This is son, the pid is:27528, the a is: 2This is father, my pid is: 27527, the a is: 2 clone/fork/vfork区别与联系最终都是调用do_fork函数完成, 只是参数不同]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++关键字]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[volatile 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回阻止编译器操作volatile变量的指令顺序 123456volatile int i=10; int a = i; ... //其他代码，并未明确告诉编译器，对i进行过操作 //编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中int b = i; inline对于内联函数, 编译器在符号表里方式函数声明(名字, 参数类型, 返回值类型),如果编译器没发现错误, 函数代码也被放入符号表里。在调用一个内联函数时, 编译器如果检查类型正确, 内联函数代码会直接替换函数调用(宏替换也是一样), 省去了函数调用开销。 inline 是一种用来实现的关键字, 不是用来声明的关键字; 用户也不要知道函数是否内联, 推荐风格如下123456789101112//头文件class A&#123;public: void Foo(int i);&#125;;// 实现文件inline void A::Foo(int i)&#123; ......&#125; explicit 防止由构造函数定义的隐式转换 1234567891011121314class things&#123;public: explicit things(const std::string&amp;name =&quot;&quot;): m_name(name),height(0),weight(0)&#123;&#125; int CompareTo(const things &amp; other); std::string m_name; int height; int weight;&#125;;things a;std::string nm =&quot;book_1&quot;;int result = a.CompareTo(things(nm));//必须显示使用构造函数 extern 被 extern 修饰函数或变量(不能和static同时修饰), 在本模块内全局可见 被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和连接的 1234567//file1.c: int x=1; int f()&#123;do something here&#125;//file2.c: extern int x; int f(); void g()&#123;x=f();&#125; C语言调用C++1234567891011121314151617#ifdef __cplusplusextern &quot;C&quot; &#123;#endifNAMESPACE_BILLING40_FRAME CThread* create_instanceRating();#ifdef __cplusplus&#125;#endif// C的代码文件c.c中调用c++函数extern NAMESPACE_BILLING40_FRAME CThread* create_instanceRating();int main(int argc,char** argv)&#123; print(3); return 0;&#125; C++调用C语言1234567891011121314151617181920212223242526// cHeader.h#ifndef C_HEADER#define C_HEADER extern void print(int i); #endif C_HEADER// cHeader.c#include &lt;stdio.h&gt;#include &quot;cHeader.h&quot;void print(int i)&#123; printf(&quot;cHeader %d\n&quot;,i);&#125;// c++的*.cpp文件中调用extern &quot;C&quot;&#123;#include &quot;cHeader.h&quot;&#125; int main(int argc,char** argv)&#123; print(3); return 0;&#125; typedef 定义类型别名 1234567891011121314typedef int* PINT; // 一般用大写PINT pa, pb; // 同时声明了两个指向int变量的指针typedef float REAL; // 跨平台编译typedef struct tagPOINT&#123;int x;int y;&#125;SPOINT;SPOINT sa; // 省略了一个structint mystrcmp(const pstr, const pstr); typedef int (*PF) (const char *, const char *);PF p = mystrcmp; const1234const int *A; // 修饰指向的对象，A可变，A指向的对象不可变int const *A; // 修饰指向的对象，A可变，A指向的对象不可变int *const A; // 修饰指针A， A不可变，A指向的对象可变 const int *const A; // 指针A和A指向的对象都不可变 virtual 虚表存放的位置一般存放在模块的常量段中，从始至终都只有一份? 和编译器有关, 在gcc编译器的实现中虚函数表vtable存放在可执行文件的只读数据段.rodata中 问题参考1问题参考2 重载、覆盖、隐藏成员函数被重载的特征：（同名不同参）（1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual 关键字可有可无。覆盖是指派生类函数覆盖基类函数，特征是：(虚函数)（1）不同的范围（分别位于派生类与基类）；（2）函数名字相同；（3）参数相同；（4）基类函数必须有virtual 关键 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：(behavior depends on type of the pointer)（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） assertvoid print_number(int myInt) { assert (myInt!=NULL); // 条件表达式为假就退出 printf (“%d\n”,myInt);} using1.命名空间2.继承时, 在子类中使用基类成员3.指定别名123456789101112131415template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;class vector : protected _Vector_base&lt;_Tp, _Alloc&gt;&#123;protected: using _Base::_M_allocate; using _Base::_M_deallocate; using _Base::_M_impl; using _Base::_M_get_Tp_allocator;&#125;;template &lt;typename T&gt;using Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;; // usageVec&lt;int&gt; vec; newnew: 关键字, 先分配内存, 再构造对象operate new: 只能在类中重载placement new: 是operator new的一个重载版本, 预先分配好内存中构造对象, 必须显示调用对象析构函数1234567891011121314151617181920212223242526272829303132333435void *operator new( size_t, void *p ) throw() &#123; return p; &#125;Widget * p = new Widget; //ordinary new pi = new (ptr) int; //placement new, ptr 指向内存// --------------class Test&#123;public:Test(int i): m_i(i) &#123;&#125;~Test()&#123;cout&lt;&lt;&quot;~Test.&quot;&lt;&lt;endl;&#125;public: int m_i;&#125;;int main()&#123; int* p = new int[1024]; cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; endl; Test* ptr = new(p) Test(5); cout&lt;&lt; &quot;ptr-&gt;m_i=&quot; &lt;&lt; ptr-&gt;m_i &lt;&lt; endl; cout&lt;&lt; &quot;ptr=&quot; &lt;&lt; ptr&lt;&lt; endl; ptr = new(p+sizeof(Test)) Test(6); cout&lt;&lt; &quot;ptr-&gt;m_i=&quot; &lt;&lt; ptr-&gt;m_i &lt;&lt; endl; cout&lt;&lt; &quot;ptr=&quot; &lt;&lt; ptr&lt;&lt; endl; delete[] p;&#125;// output, 没有调用~Test.p=0x1632560ptr-&gt;m_i=5ptr=0x1632560ptr-&gt;m_i=6ptr=0x1632560 define/undeftypename模板类型在实例化之前, 有三种可能 静态数据成员/静态成员函数/嵌套类型。typedef创建了存在类型的别名，而typename告诉编译器 std::vector::size_type 是一个类型而不是一个成员。 1typedef typename std::vector&lt;T&gt;::size_type size_type;]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++函数指针]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[函数名到底是什么东西呢？ 常用函数调用1234567891011121314#include &lt;iostream&gt;using namespace std;void Func(int a); // void Func(int); 声明int main()&#123; Func(5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125; 函数指针变量的声明和使用1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void Func(int a); // 或void Func(int);void (*FuncP)(int); // 或void (*FuncP)(int a);int main()&#123; Func(5); (*Func)(5); // 一般不这样写 FuncP = &amp;Func; (*FuncP)(5); FuncP(5); FuncP = Func; FuncP(5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125; 为了书写与数学函数形式一样方便, C语言的设计者允许如下操作: FuncP 和 Func是一样的，都是函数指针 (*Func)(5) = Func(5), 与数学函数形式一样 FunP函数指针变量也可以FunP(10)的形式来调用 赋值时，即可FunP=&amp;Func形式，也可FunP=MyFun 定义函数的指针类型1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef int* INTP; // 定义一个类型void Func(int a); // 声明一个函数typedef void (*FuncType)(int); // 定义一个函数指针类型FuncType FuncP; // 声明一个函数指针变量int main()&#123; FuncP = Func; FuncP(5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125; 函数指针作为参数1234567891011121314151617181920#include &lt;iostream&gt;using namespace std; void Func(int a); typedef void (*FuncType)(int); int int CallFunc(FuncType p, int);(FuncType p, int a);int main()&#123; CallFunc(Func, 5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125;int CallFunc(FuncType p, int)&#123; p(a);&#125; 地址跳转1(*(void (*)(void))(0x30700000))(); (void ()(void)) 转化为一个函数指针fp, 上面表达式同 (fp)()]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++实现final]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E5%AE%9E%E7%8E%B0final%2F</url>
    <content type="text"><![CDATA[有时候我们希望一个类不能被继承，这种类称为final类，一个类如果有一个虚拟私有继承的基类，那么该类不能被继承。在C++11标准之前要实现这种技术，需要巧妙地利用一些细节首先我们要明确以下几点： 类的构造函数或析析构函数声明为私有的，那么该类不能被继承，但同时该类也不能使用派生类只能访问基类的公有成员和保护成员，如果是私有继承，基类中所有成员到子类中将成为私有的，子类的派生类也即子类的子类只能访问其直接父类的公有成员或保护成员，不能访问最原始基类的任何成员虚继承时, 由最终子类构造基类 123456789101112class FinalBase&#123;protected: //FinalBase()&#123;&#125; //~FinalBase()&#123;&#125;&#125;;class Filal : virtual private FinalBase&#123;public: Filal() &#123; cout&lt;&lt;&quot;final class.&quot;&lt;&lt;endl; &#125;&#125;; Final 就是一个final类, 不能被继承。gcc4.7以前有些版本编译器需要声明保护的基类构造或析构。 在C++11标准中，引入了final关键字，实现就简单多了。 123class Test final&#123;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++菱形继承]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[菱形继承是什么封装，继承，多态，这是C++语言的三大特性，而每次在谈到继承时不可避免的要谈到一个问题：菱形继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;class Base&#123;public: Base() &#123; cout&lt;&lt;&quot;Base&quot;&lt;&lt;endl; &#125; ~Base() &#123; cout&lt;&lt;&quot;~Base&quot;&lt;&lt;endl; &#125; void show()&#123; cout &lt;&lt; &quot;Base::show a=&quot; &lt;&lt; a &lt;&lt; endl; &#125; int a=0;&#125;;class A : public Base&#123;public: A() &#123; cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;&quot;~A&quot;&lt;&lt;endl; &#125;&#125;;class B : public Base&#123;public: B() &#123; cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; &#125; ~B() &#123; cout&lt;&lt;&quot;~B&quot;&lt;&lt;endl; &#125;&#125;;class C : public A, public B&#123;public: C() &#123; cout&lt;&lt;&quot;C&quot;&lt;&lt;endl; &#125; ~C() &#123; cout&lt;&lt;&quot;~C&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; C c; cout&lt;&lt; &quot;sizeof(Base)=&quot;&lt;&lt; sizeof(Base) &lt;&lt; endl; cout&lt;&lt; &quot;sizeof(C)=&quot;&lt;&lt; sizeof(c) &lt;&lt; endl;&#125;// output: BaseABaseBCsizeof(Base)=4sizeof(C)=8~C~B~Base~A~Base 从输出结果来看, 构造顺序按声明的顺序，C类的大小8是有2个Base对象。当用C对象调用show方法，会产生“二义性”问题。 域限定方式可解决：12C c;c.A::show(); 还有就可以使用虚继承的方式 虚继承虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态。对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象，共享基类子对象称为虚基类。虚基类用virtual声明继承关系就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Base&#123;public: Base() &#123; cout&lt;&lt;&quot;Base&quot;&lt;&lt;endl; &#125; ~Base() &#123; cout&lt;&lt;&quot;~Base&quot;&lt;&lt;endl; &#125; void show()&#123; cout &lt;&lt; &quot;Base::show a=&quot; &lt;&lt; a &lt;&lt; endl; &#125; int a=0;&#125;;class A : virtual public Base&#123;public: A() &#123; cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;&quot;~A&quot;&lt;&lt;endl; &#125;&#125;;class B : virtual public Base&#123;public: B() &#123; cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; &#125; ~B() &#123; cout&lt;&lt;&quot;~B&quot;&lt;&lt;endl; &#125;&#125;;class C : public A, public B&#123;public: C() &#123; cout&lt;&lt;&quot;C&quot;&lt;&lt;endl; &#125; ~C() &#123; cout&lt;&lt;&quot;~C&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; C c; cout&lt;&lt; &quot;sizeof(Base)=&quot;&lt;&lt; sizeof(Base) &lt;&lt; endl; cout&lt;&lt; &quot;sizeof(C)=&quot;&lt;&lt; sizeof(c) &lt;&lt; endl;&#125;// output:BaseABCsizeof(Base)=4sizeof(C)=24~C~B~A~Base 输出24 = (2个8字节的C类虚基指针) + sizeof(A)+sizeof(B) = 16 + 4 + 4 典型应用123class istream : virtual public ios&#123;...&#125;;class ostream : virtual public ios&#123;...&#125;;class iostream : public istream, public ostream&#123;...&#125;; 注意 虚继承只是解决了菱形继承中派生类多个基类内存拷贝的问题，并没有解决多重继承的二义性问题 通常每个类只会初始化自己的直接基类，如果不按虚继承处理，那么在菱形继承中会出现基类被初始多次的情况。在虚继承中，对初始化进行了特殊处理，由最底层派生类的构造函数初始化虚基类]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人能力总结]]></title>
    <url>%2F2018%2F11%2F16%2F%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[优缺点阐述，也作为个人能力提升的计划。 决策能力决策正确与错误, 会达到、超出、背离预期结果，需要提升分析和判断能力。 时间管理合理安排和利用时间，提高工作效率。工作繁琐, 测试问题，需求讨论，代码开发，一天都很忙碌.掌握工作流程，讲究方法。QA：描述清楚背景和目的，很多时候就是低级的配置问题。discuss：不必要的讨论不参加dev：先文档后代码，理清思路，高质量，少bug。 沟通能力简单说先得搞明白对方意思。耐心观察和聆听，从对方表情和言语了解对方思路，再有效沟通。情绪化的负作用很大，影响沟通效果，在突发事件无法分析和决断，最终使工作开展困难。QA：”让我测这测那，我TMD不测了!”, “还没解决，快点快点!”PSO：””DEV：”你们改是最合理的!” “太复杂，影响太大，改不了！”CUST：”为什么不能支持!, 你们这么干这么干…” 激励技巧应变能力驾驭能力组织和协调能力的体现, 为有效完成目标, 需要调动所有成员积极性。首先要提升自己的语言组织和宣导能力，提升自己实操技能，敢于承担和付出， 取得大家认可。 培训能力定期对自己总结和分析，提升自己语言组织和表达能力，将自己知识和经验分享 学习能力自我反思，学习别人优点，更多的技能知识]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[缓存算法]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[LRU算法算法原理全称Least Recently Used, 也就是最近最少使用, 是一种内存管理算法, 最早应用于Linux系统。基于一种假设：长期不被使用的数据, 在未来用到的几率不大。因此当数据占据一定阈值时，移除掉最近最少被使用的数据。 哈希表是由若干个Key-Value所组成。在“逻辑”上，Key-Value是无所谓排列顺序的。在哈希链表当中，这些Key-Value不再是彼此无关的存在，而是被一个链条串了起来。每一个Key-Value都具有它的前驱Key-Value、后继Key-Value，就像双向链表中的节点一样。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库设计三范式]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库设计三范式为了建立冗余小、结构合理的数据库，设计数据库必须遵循一定的原则。实际工最常用的三范式： 第一范式(确保每列保持原子性)第一范式是最基本的范式，表中的所有字段都是不可分割的原子值。 例如将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式 第二范式(确保表中每列都和主键相关)第二范式在第一范式的基础上，确保表中每一列都与主键相关，而不能与主键的某一部分相关(主要针对联合主键)。 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示: 订单编号 商品编号 商品名称 价格 客户 联系方式 001 1 车 10000 张三 88888888 002 2 帽子 5 李四 99999999 这个表中是以订单编号和商品编号作为联合主键。在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关, 所以在这里违反了第二范式的设计原则。 如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美订单信息表 订单编号 客户 联系方式 001 张三 88888888 002 李四 99999999 订单项目表 订单编号 商品编号 数量 001 1 1 002 2 1 商品信息表 商品编号 商品名称 价格 1 车 10000 2 帽子 5 这样设计，在很大程度上减小了数据库的冗余。 第三范式(确保每列都是和主键直接相关，而不是间接相关)第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 传递函数依赖：假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，依赖A-〉C是传递依赖。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 理解 1NF是对属性的原子性约束，要求属性具有原子性，不可再分解。通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计 2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性。数据记录不重复冗余 3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余 其他 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖） 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源协议区别]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[详细区别]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式锁实现]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之CAP理论(1)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8BCAP%E7%90%86%E8%AE%BA-1%2F</url>
    <content type="text"><![CDATA[CAP理论2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。 CAP理论为：一个分布式系统最多只能同时满足一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)这三项中的两项。 Consistency一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。 对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。 一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。 Availability可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间 对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。 Partition tolerance分区容错性指“the system continues to operate despite arbitrary message lossor failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。 简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。 CAP理论中的CA和数据库事务中ACID的CA并完全是同一回事儿. 两者之中的A都是C都是一致性(Consistency).CAP中的A指的是可用性 (Availability),而ACID中的A指的是原子性(Atomicity),切勿混为一谈. CAP权衡CA without P分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。 比如我们熟知的关系型数据库，如My Sql和Oracle就是保证了可用性和数据一致性，但是他并不是个分布式系统。一旦关系型数据库要考虑主备同步、集群部署等就必须要把P也考虑进来。 CP without A如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。 一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况,就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。 设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。 无论是像Redis、HBase这种分布式存储系统，还是像Zookeeper这种分布式协调组件。数据的一致性是他们最最基本的要求。一个连数据一致性都保证不了的分布式存储要他有何用？ 在我的Zookeeper介绍（二）——Zookeeper概述一文中其实介绍过zk关于CAP的思考，这里再简单回顾一下： ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持 同步、一致。所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了。 AP without C要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。 这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。 你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的(但是可能实际已经没票了)，你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。 但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。 对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之一致性算法Raft(6)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Raft-6%2F</url>
    <content type="text"><![CDATA[前言Raft 也是一个 易于理解一致性算法，和 Paxos 目标相同, 区别在于选举的 具体过程 不同。 什么是Raft协议Raft 协议组织的集群中有三类角色： Leader（领袖） Follower（群众） Candidate（候选人） 一个 Server 进程在某一时刻，只能是其中 一种类型，但这不是固定的。不同的时刻，它可能拥有不同的类型，一个 Server 进程的类型是如何改变的，后面会有解释。 就像一个民主社会，领袖由民众投票选出。刚开始没有 领袖，所有集群中的 参与者 都是 群众，那么首先开启一轮大选。在大选期间 所有群众 都能参与竞选，这时所有群众的角色就变成了 候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除 领袖 的 候选人 又变回 群众角色 服从领袖领导。 这里提到一个概念 「任期」，用术语 Term 表达。关于 Raft 协议的核心概念和术语就这么多，而且和现实民主制度非常匹配，所以很容易理解。 三类角色的变迁图如下： Leader选举过程在极简的思维下，一个最小的 Raft 民主集群需要 三个参与者（如下图：A、B、C），这样才可能投出多数票。 初始状态 ABC 都是 Follower，然后发起选举这时有 三种 可能的情形发生。下图中前二种都能选出 Leader，第三种则表明 本轮投票无效（Split Votes）。对于第三种，每方都投给了自己，结果没有任何一方获得多数票。之后 每个参与方 随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。这里的关键就是随机timeout，最先从 timeout 中恢复发起投票的一方，向还在 timeout 中的另外两方 请求投票，这时它就只能投给自己，导致很快达成一致。 选出 Leader 后，Leader 通过 定期 向所有 Follower 发送 心跳信息 维持其统治。若 Follower 一段时间未收到 Leader 的 心跳，则认为 Leader 可能已经挂了，然后再次发起 选举 过程。 Leader对一致性的影响Raft 协议 强依赖 Leader 节点的 可用性，以确保集群 数据的一致性。数据的流向 只能从 Leader 节点向Follower 节点转移。具体过程如下： 当 Client 向集群 Leader 节点 提交数据 后，Leader 节点 接收到的数据 处于 未提交状态（Uncommitted） 接着 Leader 节点会 并发地 向所有 Follower 节点 复制数据 并 等待接收响应 集群中至少 超过半数 的节点 已接收 到数据后， Leader 再向 Client 确认数据 已接收 一旦向 Client 发出数据接收 Ack 响应后，表明此时 数据状态 进入 已提交（Committed），Leader 节点再向 Follower 节点发通知告知该 数据状态已提交 在这个过程中，主节点 可能在 任意阶段 挂掉，看下 Raft 协议如何针对不同阶段保障 数据一致性 的。 情形1数据到达 Leader 节点前，这个阶段 Leader 挂掉不影响一致性，不用多说。 情形2数据到达 Leader 节点，但未复制到 Follower 节点。这个阶段 Leader 挂掉，数据属于 未提交状态，Client 不会收到 Ack 会认为 超时失败 可安全发起 重试。 Follower 节点上没有该数据，重新选主 后 Client 重试 重新提交 可成功。原来的 Leader 节点 恢复 后作为Follower 加入集群，重新从 当前任期 的新 Leader 处 同步数据，强制保持和 Leader 数据一致。 情形3情形4情形5情形6情形7验证结果综上穷举分析了 最小集群（3 节点）面临的所有情况，可以看出 Raft 协议都能很好的应对 一致性问题，并且很容易理解。 小结Paxos 算法是 Leslie Lamport 在 1990 年就公开发表在了自己的网站上，想想我们是什么时候才听说的？什么时候才有一个可用的实现？而 Raft 算法是 2013 年发表的，大家在参考 Raft开源实现库，可以看到有很多基于不同语言的 开源实现库，这就是 可理解性 的重要性。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之一致性算法Paxos(5)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos-5%2F</url>
    <content type="text"><![CDATA[前言世界上只有一种一致性算法, 就是Paxos(帕克索斯), 出自一位 Google 大神之口。 Paxos解决了2PC，3PC中的各种硬伤, 在很多大长都有工程实践。比如阿里的 OceanBase 分布式数据库，底层就是使用的 Paxos 算法。再比如 Google 的 chubby 分布式锁 也是用的这个算法。可见该算法在分布式系统中的地位，甚至于Paxos 就是 分布式一致性 的代名词。 1. Paxos算法是什么Paxos 算法是 基于消息传递 且具有 高效容错特性 的一致性算法，目前公认的解决 分布式一致性问题 最有效 的算法之一。2. 解决了什么问题(产生背景)在常见的 分布式系统 中，总会发生 节点宕机 或 网络异常 (包括消息的 重复、丢失、延迟、乱序、网络分区)等情况。Paxos 算法主要就是解决如何在一个 发生如上故障 的分布式系统中，快速正确的在集群内 对某个值达成一致，并且保证 整个系统的一致性。 3. 算法详解角色 Proposer: Proposer 可以 提出提案 (Proposal)Acceptor: Acceptor 可以 接受提案。一旦接受提案，提案 里面的 value 值就被选定了Leaner: Acceptor 告诉 Learner 哪个提案被选定了，那么 Learner 就学习这个被选择的 value在具体的实现中，一个进程即可能是Proposer,也可能是Acceptor，也可能是Learner。 注意：提案的范围&gt;value.后面会讲到，[提案=编号+Value].也可表示为[M,V].以下描述中暂定: 提案=P，Value=V 问题描述Paxos 算法的核心是 一致性。所以将从一致性问题的描述来讲解该算法怎么解决实际问题。 一致性算法的前置条件 在被提出的 P 中，只有一个 V 被选中如果没有 P 被提出，就没有 V 被选中在 P 被选定后，进程都可以学习被选中的 P 不同角色通过发送消息进行通信 每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个 value 被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值 消息在传递过程中可能出现 任意时长的延迟，可能会 重复，也可能 丢失，但是消息不会被 损坏 推导过程只有一个Acceptor 问题：如果这个 Acceptor 宕机，那么整个系统服务不可用 多个Acceptor 问题：如何在多 Proposer 和多 Acceptor 情况下，选定一个 value？ 讲解步骤分两阶段：约定 P1 和 约定 P2。 约定P1 P1 ：一个 Acceptor 必须接受一个它收到的第一个 P。 如果每个 Proposer 会产生不同的 P，那么多个 Proposer 必定产生多个 P，发给多个 Acceptor。根据 约定 P1，Acceptor 分别接受到 P，就会导致不同的 V 被选定，如下图所示：如上图所示，P1 会产生的问题: v1、v2、v3 都没有被选定，因为他们只有被一个 Acceptor 接受。对于上述问题，我们需要一个额外的约定: P1a : 一个提案 P 被选定，需要被半数以上 Acceptor 接受. 对于 P1a，其实就意味着 一个Acceptor必须接受不止一个提案。显然，这与 P1 相矛盾，所以需要重新设计提案。原来的设计是: [提案P = value]，现在重新设计 [提案P = 提案编号 + value]，可表示为 [M，V]。 新问题：多提案被选定，如何保证被选定的提案 P 具有相同的value? 约定P2 P2 : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且被选定的 P，其 value 的值也是 V0。 对于 P2 中的 “被选定”：一个提案要被选定，首先至少要被一个 Acceptor 批准。因此，可以理解 P2 为： P2a : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且 [被Acceptor批准] 的P，其 value值也是 V0。 只要满足 P2a，就能满足 P2。多提案被选择 的问题解决了，但是由于 网络不稳定 或者 宕机 的原因(不可避免)会产生新问题： 假设有 5 个 Acceptor。Proposer2 提出 [M1,V1]的提案，Acceptor2~5（半数以上）均接受了该提案，于是对于 Acceptor2~5 和 Proposer2 来讲，它们都认为 V1 被选定。Acceptor1 刚刚从 宕机状态 恢复过来（之前 Acceptor1 没有收到过任何提案），此时 Proposer1 向 Acceptor1 发送了 [M2,V2] 的提案（V2≠V1且M2&gt;M1）。对于 Acceptor1 来讲，这是它收到的 第一个提案。根据 P1（一个 Acceptor 必须接受它收到的 第一个提案），Acceptor1 必须接受该提案。同时 Acceptor1 认为 V2 被选定。 这就出现了两个问题： Acceptor1 认为 V2 被选定，Acceptor2~5 和Proposer2 认为 V1 被选定。出现了不一致。 V1 被选定了，但是 编号更高 的被 Acceptor1 接受的提案 [M2,V2] 的 value 为 V2，且 V2≠V1。这就跟 P2a（如果某个 value 为 v的提案被选定了，那么每个 编号更高 的被 Acceptor 接受的提案的 value必须也是 v）矛盾了 基于以上问题，所有就有了 P2b: P2b : 如果 P[M0,V0] 被选定后，任何 Proposer 产生的 P，其值也是 V0 对于 P2b 中的描述，怎样保证 任何Proposer产生的P，其值也是V0 ？只要满足 P2c 即可： P2c: 对于任意的 M、V，如果 [M,V] 被提出，那么存在一个半数以上的 Acceptor 组成的组合 S，满足以下两个条件中的任何一个： S 中没有一个接受过编号小于 M 的提案。 S 中的 Acceptor 接受过的最大编号的提案的 value 为 V。 算法流程Proposer提出提案(一). 学习阶段：Prepare请求Proposer 选择一个新的提案 P[MN,?] 向 Acceptor 集合 S（数目在半数以上）发送请求，要求 S 中的每一个 Acceptor 做出如下响应: 如果 Acceptor 没有接受过提案，则向 Proposer 保证 不再接受编号小于N的提案 如果 Acceptor 接受过请求，则向 Proposer 返回 已经接受过的编号小于N的编号最大的提案 (二). 接受阶段：Acceptor请求 如果 Proposer 收到 半数以上 的 Acceptor 响应，则 生成编号为 N，value 为 V 的提案[MN,V]，V 为所有响应中 编号最大 的提案的 value 如果 Proposer 收到的响应中 没有提案，那么 value 由 Proposer 自己生成，生成后将此提案发给 S，并期望 Acceptor 能接受此提案 Acceptor接受提案Acceptor 可以忽略任何请求（包括 Prepare 请求和 Accept 请求）而不用担心破坏 算法的安全性。什么时候 Acceptor 可以响应一个请求? P1b：一个 Acceptor 只要尚未响应过任何编号大于 N 的 Prepare 请求，那么就可以接受这个编号为 N 的提案。 如果 Acceptor 收到一个编号为 N 的 Prepare 请求，在此之前它已经 响应过 编号大于 N 的Prepare 请求。根据 P1b，该 Acceptor 不可能接受编号为 N 的提案。因此，该 Acceptor 可以忽略 编号为 N 的 Prepare 请求。当然，也可以回复一个 error，让 Proposer 尽早知道自己的提案 不会被接受。 因此，一个 Acceptor 只需记住: 已接受的编号最大的提案 已响应的请求的最大编号 4. Paxos算法描述5. Learner学习提案6. 如何保证Paxos算法的活性7. 小结Paxos 在 节点宕机恢复、消息无序或丢失、网络分化 的场景下能保证 数据的一致性。而 Paxos的描述侧重于 理论，在实际项目应用中，处理了 N 多实际细节后，可能已经变成了另外一种算法，这时候正确性已经无法得到理论的保证。 要证明分布式一致性算法的正确性通常比实现算法还困难。所以很多系统实际中使用的都是以 Paxos理论 为基础而 衍生 出来的变种和简化版。例如 Google 的 Chubby、MegaStore、Spanner 等系统，ZooKeeper 的 ZAB 协议，还有更加容易理解的 Raft 协议。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之3PC(4)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B3PC-4%2F</url>
    <content type="text"><![CDATA[前言三阶段提交对二阶段提交存在的问题进行了改进： 引入超时机制 - 同时在协调者和参与者中都引入超时机制。 在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。 3PC定义三阶段提交(Three-phase commit), 是二阶段提交的改进版本。所谓的三个阶段分别是：询问，然后再锁资源，最后真正提交。 第一阶段：CanCommit 第二阶段：PreCommit 第三阶段：Do Commit 3PC过程一、CanCommit协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。 事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。 响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态；否则反馈No。 二、PreCommit协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。 执行事务预提交 发送预提交请求 协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态 事务预提交 参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 准备阶段中的“执行事务”，也会 Undo 和 Redo 信息记录到事务日志中 各参与者响应反馈 如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）。 中断事务 发送中断请求 协调者向所有参与者节点发出 abort 请求 中断事务 参与者如果收到 abort 请求或者超时了，都会中断事务 三、DoCommit该阶段进行真正的事务提交，分为执行提交，或中断事务。 执行提交 发送提交请求 协调者接收到各参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。 事务提交 参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。 响应反馈 事务提交完之后，向协调者发送 ACK 响应 完成事务 协调者接收到所有参与者的 ACK 响应之后，完成事务 中断事务协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。 发送中断请求 协调者向所有参与者发送 abort 请求。 事务回滚 参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。 反馈结果 参与者完成事务回滚之后，向协调者发送 ACK 消息。 中断事务 协调者接收到参与者反馈的 ACK 消息之后，完成事务的中断。 优缺点 优点相对于二阶段提交，三阶段提交主要解决的单点故障问题，并减少了阻塞的时间。因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。 缺点三阶段提交也会导致数据一致性问题。由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之2PC(3)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B2PC-3%2F</url>
    <content type="text"><![CDATA[前言由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 PhaseCommitment Protocol）和Paxos算法。 本文要介绍的2PC协议，分为两个阶段提交一个事务。并通过协调者和各个参与者的配合，实现分布式一致性。 角色 XA概念 作用 协调者 事务管理器 协调各个参与者,对分布式事务进行提交或回滚 参与者 资源管理器 分布式集群中的节点 分布式事务分布式事务是指会涉及到操作多个数据库的事务。目的是为了保证分布式系统中的数据一致性关键： 需要记录事务在任何节点所做的所有动作 事务进行的所有操作要么全部提交，要么全部回滚 XA规范XA规范是由 X/Open组织（即现在的 Open Group ）定义的分布式事务处理模型。 X/Open DTP模型（ 1994 ）包括： 应用程序（ AP ） 事务管理器（ TM ）：交易中间件等 资源管理器（ RM ）：关系型数据库等 通信资源管理器（ CRM ）：消息中间件等 XA规范定义了交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而XA接口函数由数据库厂商提供 二阶提交协议和三阶提交协议就是基于XA规范提出的其中，二阶段提交就是实现XA分布式事务的关键。 XA规范的流程，大致如图所示： 2PC定义每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是中止操作。 准备阶段准备阶段分为三个步骤： 事务询问协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。 执行事务各参与者节点执行事务操作。如果本地事务成功，将Undo和Redo信息记入事务日志中，但不提交；否则，直接返回失败，退出执行。 各参与者向协调者反馈事务询问响应如果参与者成功执行了事务操作，那么就反馈给协调者 Yes响应，表示事务可以执行提交；如果参与者没有成功执行事务，就返回No给协调者，表示事务不可以执行提交。 提交阶段根据准备阶段的投票结果执行2种操作:提交事务或中断事务 提交事务过程 发送提交请求协调者向所有参与者发出commit请求。 事务提交参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后，释放整个事务执行期间占用的事务资源。 反馈事务提交结果参与者在完成事务提交之后，向协调者发送Ack信息。 事务提交确认协调者接收到所有参与者反馈的Ack信息后，完成事务。 中断事务过程 发送回滚请求协调者向所有参与者发出Rollback请求。 反馈事务回滚结果参与者在完成事务回滚之后，想协调者发送Ack信息。 事务回滚参与者接收到Rollback请求后，会利用其在提交阶段种记录的Undo信息，来执行事务回滚操作。在完成回滚之后，释放在整个事务执行期间占用的资源。 事务中断确认协调者接收到所有参与者反馈的Ack信息后，完成事务中断。 优缺点 优点：原理简单，实现方便。 缺点：同步阻塞，单点问题，数据不一致，容错性不好。 同步阻塞所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。(mapreduce里面是顺序执行) 单点问题协调者是个单点, 如果协调者在提交阶段出现问题，那么整个流程将无法运转 数据不一致协调者向所有的参与者发送commit请求之后，发生了局部网络异常，或者是协调者在尚未发送完所有 commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求。 容错性不好如果在二阶段提交的提交询问阶段中，参与者出现故障，导致协调者始终无法获取到所有参与者的确认信息，这时协调者只能依靠其自身的超时机制，判断是否需要中断事务。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之BASE理论(2)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8BBASE%E7%90%86%E8%AE%BA-2%2F</url>
    <content type="text"><![CDATA[前言BASE理论是由eBay架构师提出的. BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结, 是基于CAP定律逐步演化而来. 其核心思想是即使无法做到强一致性, 但每个应用都可以根据自身业务特点，才用适当的方式来使系统达到最终一致性 BASE理论简介BASE理论是Basically Available(基本可用), Soft State(软状态), Eventually Consistent(最终一致性)三个短语的缩写 其核心思想是： 既是无法做到强一致性, 但每个应用可以根据自身的业务特点, 采用适当的方式来是系统达到最终一致性 BASE理论的内容基本可用当系统出现了不可预知故障, 但还是能用, 就是基本可用。。。 响应时间的止损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。 软状态相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。 软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。 最终一致性在一定期限后，应当保证所有副本数据一致性，从而达到数据的最终一致性。时间期限取决于网络延迟、系统负载、数据复制方案设计等 在实际工程实践中，最终一致性分为5种： 因果一致性（Causal consistency）如果节点A在更新了数据后通知了B，那么B对该数据的访问都是基于A更新修改后的值。与此同时,和节点A无因果关系的节点C的数据访问没有这样的限制 读己之所写（Read your writes）节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性 会话一致性（Session consistency）对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。 单调读一致性（Monotonic read consistency）如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。 单调写一致性（Monotonic write consistency）一个系统要能够保证来自同一个节点的写操作被顺序的执行。 在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。 实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。 小结总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法图解笔记]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 绪论冒泡排序 遍历A[0, n] 依次比较相邻两个数, 若A[i-1]小于A[i], 则交换, 并设置循环遍历标记; 一次循环必然可确定一个最大值, n递减; 1234567891011121314151617void bubble_sort(int A[], n)&#123; bool bSort = false; while(bSort) &#123; bSort = false; for(int i=1; i&lt;n; i++) &#123; if(A[i-1]&gt;A[i]) &#123; swap(A[i-1], A[i]); bSort = true; &#125; &#125; n--; &#125;&#125; 复杂度度量大O记号性质a) 对于任意常数c&gt;0, 有$ O(f(n)) = O(c*f(n)) $b) 对于任意常数a&gt;b&gt;0, $ 有O(n^a + n^b) = O(n^a) $冒泡时间复杂度: $ T(n)=O(2(n-1)^2) = O(2n^2 + 4n + 2) = O(2n^2) = O(n^2) $ $ \Omega $ 标记为最乐观的下限复杂度, $ \Theta $ 上限复杂度 复杂度分析常数：$ T(n) = O(3) + O(2) + O(1) = O(7) = O(1) $对数：$ O(\log_2 n) = O(\log n) $指数：$ O(a^n) $ 1234567891011// 统计整数n二进制展开中数位1的个数int countOnes(unsigned int n)&#123; int num = 0; while(n&gt;0) &#123; num += (1&amp;n); n &gt;&gt; 1; &#125; return num;&#125; 递归(recursive)线性递归二分递归多分支递归ADT第二章 向量从数组到向量前驱(prefix)，后继(suffix)向量(vector)是线性数组的抽象和泛化。各元素的秩(rank)互异, 且均为[0, n) 内的整数。需要考虑扩容(expand不够用成倍扩展)和缩容(shrink小于25%较少1/2空间) 归并排序比较两个待归并的向量的首元素，取小的追加到输出向量末尾时间复杂度$ O(\log n) $12345678910111213141516template &lt;class T&gt;void mergeSort(Rank lo, Rand hi)&#123; if(hi - lo &lt; 2) return; int mi = (lo + hi) &gt;&gt; 1; mergeSort(lo, mi); mergeSort(mi, hi); merge(lo, mi, hi);&#125;template &lt;class T&gt;void merge(Rank lo, Rank mi, Rank hi)&#123; &#125; 第三章 列表插入排序, 选择排序, 归并排序1234567891011template &lt;class T&gt;void list&lt;T&gt;::init()&#123; header = new ListNode&lt;T&gt;; trailer = new listNode&lt;T&gt;; header-&gt;pred = NULL; header-&gt;succ = trailer; trailer-&gt;pred = header; trailer-&gt;succ = NULL; _size = 0 // 记录规模&#125; 第4章 栈与队列典型应用: 逆序输出(进制转换), 递归嵌套(栈混洗复制一个栈,括号匹配), 延迟缓冲, 逆波兰表达式 1234567891011121314151617char digit[] = &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;;void convert(stack&lt;char&gt;&amp; out, __int64 n, int base)&#123; if(n &gt; 0) &#123; convert(out, n/base, base); // 递归得到所有高位 out.push(digit[n%base]); // 输出低位 &#125; /* while(n&gt;0) &#123; int pos = n%base; out.push(digit[pos]); n /= base; &#125; */&#125;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[失败是成功他妈]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A4%B1%E8%B4%A5%E6%98%AF%E6%88%90%E5%8A%9F%E4%BB%96%E5%A6%88%2F</url>
    <content type="text"><![CDATA[必须刷一遍思路清奇小土刀 剑指Offer名企面试官精讲经典型编程大海捞针找到的c++面试技术面试必备的基础知识徐刘根的JAVA面试大杂烩Google的面试Java后端知识体系总结系统设计入门x86-64体系下一个奇怪问题的定位2018/2019/校招/春招/秋招/自然语言处理(NLP)/深度学习(Deep Learning)/机器学习(Machine Learning)/C/C++/Python/面试笔记]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程实践]]></title>
    <url>%2F2018%2F11%2F01%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[头文件简介linux sys/types.h ifaddrs.h net/if.h 参考文章select1234567891011121314#include &lt;sys/select.h&gt;int select(int fd, fd_set* read, fd_set* write, fd_set* excp, struct timeval* tm);// 返回值：就绪描述符的数目，超时返回0，出错返回-1FD_ZERO(fd_set* fds);FD_SET(int fd, fd_set* fds);FD_CLR(int fd, fd_set* fds);FD_ISSET(int fd, fd_set* fds);#include &lt;sys/time.h&gt;struct timeval&#123;__time_t tv_sec; /* Seconds. */__suseconds_t tv_usec; /* Microseconds. */&#125;; 123456789101112131415while(1)&#123; fd_set fds; FD_ZERO(&amp;fds); FD_SET(sock, &amp;fds); int ret = select(fd+1, &amp;fds, 0, 0, NULL); /*NULL一直阻塞*/ if(FD_ISSET(sock, &amp;fds)) &#123; //read &#125;&#125;// 套接字的阻塞非阻塞不影响select ， 只会影响read/write. poll123456789101112131415161718#include &lt;poll.h&gt;int poll(struct pollfd fds[], unsigned int nfds, int timeout);param: fds 数组 nfds 描述符个数，无限制 timeout 阻塞时间，单位msreturn: 返回值 &gt;0 实际发生事件描述符总数 , ==0 超时, -1 失败 设置errno struct pollfd&#123; int fd; // 文件描述符 short events; // 等待事件 short revevents; // 实际发生事件&#125;;POLLIN | POLLPRI 读, POLLOUT | POLLWRBAND 写 123456789101112131415161718192021struct pollfd fds[OPEN_MAX];fds[0].events = POLLIN | POLLPRI;for(;;)&#123; switch(poll(&amp;fds, 1, timeout)) &#123; case 0: printf(&quot;timeout \n&quot;); case -1: printf(&quot;poll error \n&quot;); default: &#123; printf(&quot;some events \n&quot;); if(fds[0].revevents &amp; POLLIN) &#123; // accept and put into fds &#125; &#125; break; &#125;&#125; epoll1234567891011121314151617#include &lt;sys/epoll.h&gt;int epoll_create(int size); // 监听数量int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);struct epoll_event&#123; __uint32_t events; epoll_data_t data;&#125;EPOLLIN/EPOLLOUT/EPOLLPRI/EPOLLERR/EPOLLHUP/EPOLLLET/EPOLLONESHOT工作模式： LT:应用程序可以不处理，下次还会再响应。 ET:需要立即处理，下次不会响应，默认ET，只响应一次。 必须使用非阻塞套接口，避免饿死其他套接口。 1234567891011121314151617181920212223242526272829void do_epool()&#123; int epollfd; struct epoll_event events[10]; epollfd = epoll_create(1024); events[0].events = EPOLLIN; events[0].data.fd = fd; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;(events[0])); for(;;) &#123; struct epoll_event eventArr[100]; // epoll_wait成功之后，储存所有的读写事件 num = epoll_wait(epollfd, eventArr, 1024, -1); for(int = 0; i&lt;num; ++i) &#123; if(eventArr[i].data.fd == lintenfd &amp;&amp;eventArr[i].events &amp; EPOLLIN) // accept else if(eventArr[i].events &amp; EPOLLIN) // 可读，有数据到来 // read else if(eventArr[i].events &amp; EPOLLOUT) // 可写，缓冲区从满==&gt;未满 // write else if(&amp; EPOLLHUP) //RST响应,在epoll上会响应为EPOLLHUP // do something &#125; &#125; close(epollfd); // &#125; 总结select的几大缺点： 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大select支持的文件描述符数量太小了，默认是1024 差异select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。 select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。 这也能节省不少的开销。阻塞/非阻塞设置12345#include &lt;fcntl.h&gt;fcntl(FD, F_SETFL, O_NONBLOCK);iFlag = 0;if( ioctl( nSock, FIONBIO, &amp;iFlag) &lt; 0) read123456789101112131415161718192021222324252627int readN(char* pBuf, int nByte)&#123; int nLeft = nByte; int nRead = 0; while(nLeft &gt; 0) &#123; nRead = read( m_nSock, pBuf, nLeft); if(nRead &lt; 0) // &#123; if(errno == EINTR) // 收到信号并从信号处理函数返回时，慢系统调用会返回并设 continue; if(errno == EAGAIN) // 示当前暂时没有数据可读，应该稍后读取 continue; &#125; else if(nRead == 0) //接收到对端发送的FIN，表示对端的写端关闭。 &#123; break; &#125; else //读取数据的长度 &#123; nLeft -= nRead; pBuf += nRead; &#125; &#125; reutrn nByte - nLeft;&#125; write12345678910111213141516171819202122232425int writeN(char* pBuf, int nByte)&#123; int nLeft = nByte; int nWrite = 0; while(nLeft &gt; 0) &#123; nWrite = write(m_nSock, pBuf, nLeft); if(nWrite &lt;=0) &#123; if(errno == EINTR) continue; if(errno == EAGAIN) // 水平模式下,如果返回EAGAIN，把socket加入epoll， // 在epoll的驱动下写数据，全部数据发送完毕后，再移出epoll //do something return nWrite; &#125; nLeft -= nWrite; pBuf += nWrite;s &#125; reutrn nByte - nLeft;&#125;//如果向已经关闭的对端调用write, 系统会向程序发送SIGPIPE信号 ET模式下，EPOLLOUT触发条件有：1.缓冲区满–&gt;缓冲区非满；2.同时监听EPOLLOUT和EPOLLIN事件 时，当有IN 事件发生，都会顺带一个OUT事件； 3.一个客户端connect过来，accept成功后会触发一次OUT事件。踩过的坑errnoerrno是线程安全的, 在一个线程中设置它, 不会影响别的线程对它的使用如果你的程序对它有依赖, 需要开发人员在接口错误处理中手工设置 粘包客户端没有收完整, 导致收下一个包core 超时时间poll/epoll 超时时间设置太小，如10ms，进程空跑CPU会高]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络模型概念]]></title>
    <url>%2F2018%2F11%2F01%2F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[在Linux中，对于一次读取IO的操作, 包含两个阶段 1 Waiting for the data to be ready(等待数据到达内核缓冲区)2 Copying the data from the kernel to the process(从内核缓冲区拷贝数据到程序缓冲区) 对于同步、异步IO, Stevens给的定义 A synchronous I/O operation causes the requesting process to beblocked until that I/O operation completes; An asynchronous I/O operation does not cause the requesting process to be blocked; 根据IO操作和进程的关系，分为五种模型 阻塞IOIO操作的两个阶段都阻塞, 用户进程一直等待系统调用返回 非阻塞IO前三次调用立即返回, 第四次调用内核数据已经准备好, 但是从内核缓冲区拷贝数据到程序缓冲区时用户进程会等待系统调用返回 IO复用select等待数据到达内核缓冲区(或超时), recvfrom从内核缓冲区拷贝数据到程序缓冲区, 两个过程用户进程分别会阻塞等待调用返回 信号驱动设置socket为一个信号驱动IO, 内核数据准备好后通知用户进程.用户进程调用recform, 等待从内核缓冲区拷贝数据到程序缓冲区, 这个过程用户进程阻塞等待 异步IO用户进程调用aio_read后, 可以继续执行, 等待IO操作两个阶段完成收到信号通知, 读取数据 总结前四种都是同步型IO操作, 只有异步IO才是异步型IO操作。]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一致性hash算法]]></title>
    <url>%2F2018%2F10%2F30%2F%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常规思路： 1.是什么2.解决了什么问题3.是怎么实现的 hash问题数据库中分库分表规则，按照hash取值、取模、按类别、按某一个字段。例如redis集群使用hash的方式，对图片缓存, 对服务器的数量进行取模hash(a.png)%4 = 2 当我们增加或减少一台服务器时，hash(a.png)%5=? hash(a.png)%3=？redis缓存的图片就找不到了，都会想后端数据库直请求，引发缓存雪崩 一致性hash一致性Hash算法是对2^32取模, 整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形）整个哈希环如下: 整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1，0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： 将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！ 例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下： 根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 一致性Hash算法的容错性和可扩展性一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。 Hash环的数据倾斜问题一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： 此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。 同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，使很少的服务节点也能做到相对均匀的数据分布]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[准备好吹牛B]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%87%86%E5%A4%87%E5%A5%BD%E5%90%B9%E7%89%9BB%2F</url>
    <content type="text"><![CDATA[BOSS系统介绍 整体功能架构计费功能架构计费技术架构计费对外接口设计部署方案(接入/应用/数据) (集群、负载均衡、分布式、数据一致性的区别与关系)高可用及容灾设计和测试(mdb) 两个机房, A/B/C/D 4个业务中心,| 流程 | 部署 | 事务数/秒(TPS) | 查询次数/秒(QPS) | 总量/天 ||:-|:-|:-|:-|:-|:-|:-|| 计费查询代理 | A/B/C/D 每个中心多个端口 | | | | || 计费MDB | 主/备(同机房)/容(异地机房), A/B/C/D 每个中心2个 | || GSM长流程 | 按需部署 || GPRS长流程 | 按需部署 || 告警导出 | 按需部署 || 在线计费 | 按需部署 || 资料上发 | 按需部署 | || XC本地容器 | 每个应用主机一个 | | 遇到过的问题 网络粘包, errno交叉死锁, 锁顺序不一致binlog乱序, 索引优化内存泄漏(lua,new/del, 基类不是析构函数, vector内存只增不减,swap释放问题)性能优化, 主机问题(linux时钟源, ssd调度方式cfq/deadline, ck和binglog文件rename, 自旋锁占CPU过高, 存储变为只读)咪咕在线流程超时(kpi数据分析, sock日志, 冲销节点慢，但是在整个批价节点的占比变化不大，因此判断是网络/CPU等原因导致乐观锁优化 介绍 最得意的事]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP协议相关概念]]></title>
    <url>%2F2018%2F10%2F29%2FTCP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[TCP协议头部格式 DNS在应用层, TCP/UDP/PORT在传输层, IP在网络层, ARP在数据链路层去掉没有协议的表示层和会话层，就是TCP/IP五层网络模型OSI是Open System Interconnect的缩写，意为开放式系统互联 为什么需要2MSL？ Maximum Segment Lifetime 报文最大生存时间, 保证最后发送的ACK报文对端可以收到, 不然对端会重发FIN. 所以TIME_WAIT用来重发可能丢失的ACK 三次握手四次分手 为什么需要三次握手？ 全双工, 告诉对方 发送/接受数据 能力OK 为什么需要四次分手？ 为了确保数据能够完成传输(确保对端收完数据) TCP状态转换 TCP如何保证可靠传输三次握手, seq+ack, 超时重传, 流量控制, 拥塞控制 超时重传流量控制拥塞控制TCP粘包TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包, 从接收缓冲区看,后一包数据的头紧接着前一包数据的尾 产生原因 发送方 TCP默认会使用Nagle算法: 只有上一个分组得到确认，才会发送下一个分组; 收集多个小分组，在一个确认到来时一起发送接受方 没有立即处理, TCP将收到的分组保存至接收缓存里, 缓冲区会存在多个包 解决办法 发送发关闭Nagle算法, TCP_NODELAY选项接受方 TCP协议没有处理机制, 通过应用层来处理应用层 定义消息包头(len+type)和包体(data), 收包时循环处理 TCP的四种定时器 重传计时器：Retransmission Timer坚持计时器：Persistent Timer保活计时器：Keeplive Timer时间等待计时器：Timer_Wait Timer TIME_WAIT太多压测工具主动关闭链接，产生TIME_WAIT将近3W，导致后续链接失败 产生原因TIME_WAIT停留2MSL(max segment lifetime)时间 解决办法1234567891011121314151617181920#统计TCP套接字状态netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;#表示开启SYN cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭net.ipv4.tcp_syncookies = 1#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭net.ipv4.tcp_tw_recycle = 1#修改系統默认的 TIMEOUT 时间net.ipv4.tcp_fin_timeout = 30#查看系统本地可用端口极限值cat /proc/sys/net/ipv4/ip_local_port_range51_zjdev[/data01/zjgrp/zjdev]%cat /proc/sys/net/ipv4/ip_local_port_range32768 61000本地能向外连接61000-32768=28232个连接 TCP队列在Linux内核2.2之后，分离为两个backlog来分别限制半连接(SYN_RCVD状态)队列大小和全连接(ESTABLISHED状态)队列大小。 半连接状态为：服务器处于Listen状态时收到客户端SYN报文时放入半连接队列中，即SYN queue(服务器端口状态为：SYN_RCVD) 全连接状态为：TCP的连接状态从服务器（SYN+ACK）响应客户端后，到客户端的ACK报文到达服务器之前，则一直保留在半连接状态中；当服务器接收到客户端的ACK报文后，该条目将从半连接队列搬到全连接队列尾部，即 accept queue (服务器端口状态为：ESTABLISHED) 1234567891011121314151617181920212223242526# SYN queue 队列长度51_zjdev[/data01/zjgrp/zjdev]%cat /proc/sys/net/ipv4/tcp_max_syn_backlog2048# Accept queue 队列长度51_zjdev[/data01/zjgrp/zjdev]%cat /proc/sys/net/core/somaxconn128/*最终取min(128, 使用listen函数时传入的参数)。在Linux内核2.4.25之前，是写死在代码常量 SOMAXCONN ，在Linux内核2.4.25之后，在配置文件 /proc/sys/net/core/somaxconn 中直接修改， 或者在/etc/sysctl.conf 中配置 net.core.somaxconn = 128*/# 查看SYN queue 溢出[root@localhost ~]# netstat -s | grep LISTEN102324 SYNs to LISTEN sockets dropped# 查看Accept queue 溢出[root@localhost ~]# netstat -s | grep TCPBacklogDropTCPBacklogDrop: 2334# 查看Accept queue[root@zhangbb ~]# ss -lntState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 50 *:3306 *:* /*在LISTEN状态，其中 Send-Q 即为Accept queue的最大值，Recv-Q 则表示Accept queue中等待被服务器accept()*/ Nagle与Delayed ACK Nagle具体的做法就是如果发送内容大于等于 1 个 MSS， 立即发送；如果之前没有包未被 ACK， 立即发送；如果之前有包未被 ACK， 缓存发送内容；如果收到 ACK， 立即发送缓存的内容。（MSS 为 TCP 数据包每次能够传输的最大数据分段） Delayed ACK具体的做法是(cat: /proc/sys/net/ipv4/tcp_delack_min: 没有那个文件或目录)当有响应数据要发送时，ACK 会随响应数据立即发送给对方；如果没有响应数据，ACK 将会延迟发送，以等待看是否有响应数据可以一起发送。在 Linux 系统中，默认这个延迟时间是 40ms；如果在等待发送 ACK 期间，对方的第二个数据包又到达了，这时要立即发送 ACK。但是如果对方的三个数据包相继到达，第三个数据段到达时是否立即发送 ACK，则取决于以上两条。 A 和 B 进行数据传输 : A 运行 Nagle 算法，B 运行 Delayed ACK 算法。如果 A 向 B 发一个数据包，B 由于 Delayed ACK 不会立即响应。而 A 使用 Nagle 算法，A 就会一直等 B 的 ACK，ACK 不来一直不发送第二个数据包，如果这两个数据包是应对同一个请求，那这个请求就会被耽误了 40ms。 发送大文件缓冲区满解决办法, POLL_OUT/EPOLL_OUT1234567891011121314151617181920212223while( nLeft &gt; 0 )&#123; nWrite = ::write( m_nSock, pBuf, nLeft); if(nWrite &lt; 0) &#123; if(errno == EINTR) continue; //LOG_ERROR(0, &quot;errno=%d&quot;, errno); if(errno == EAGAIN) &#123; struct pollfd objEvent; objEvent.fd = m_nSock; objEvent.events = (POLLOUT | POLLWRBAND | POLLERR); if(poll(&amp;objEvent, 1, 1) &lt; 0) &#123; return nWrite; &#125; continue; &#125; return nWrite; &#125;&#125; TCP keep-alive定时发送检测包, 检测链接是否可用:主机可达, 对方响应ack, 链接正常主机可达, 但应用程序退出(close了还发送数据), 对发响应RST主机可达, 但应用程序崩溃, 对方发送FIN主机可达, 但没有响应, 超时后就撤销链接123net.ipv4.tcp_keepalive_time=60 net.ipv4.tcp_keepalive_intvl=10 net.ipv4.tcp_keepalive_probes=6 wireshark 问题 TCP Out-Of-Order tcp分片序列号晚送的比早送的先到达。 多半是网络拥塞，导致顺序包抵达时间不同，延时太长，或者包丢失，需要重新组合数据单元，因为他们可能是由不同的路径到达你的电脑上面。一般可以优化传输路径。 12 如何解决： https://osqa-ask.wireshark.org/questions/27662/how-to-understand-out-of-order-tcp-segments https://ask.wireshark.org/question/9070/how-does-wireshark-determine-if-a-tcp-packet-is-out-of-order/ TCP Dup ACK网络拥塞，重发的ACK TCP Fast Retransmission网络拥塞，超时引发的数据重传。 TCP Window Full发送窗口数据分为三类： 发送了已经被确认，发送了还没有被确认，待发送的数据。 在网络中传输的字节数(还没有收到ACK确认)，等于对方接收窗口， Wireshark打上【TCP window Full】标记 TCP ZeroWindow接收窗口满了， 也就是win=0，Wireshark显示【TCP ZeroWindow】 TCP Keep-AliveRST网卡特性GRO 1234567891011121314151617181920212223242526272829303132333451_zjdev[/data01/zjgrp/zjdev]%ethtool -k eth0Features for eth0:rx-checksumming: on [fixed]tx-checksumming: on tx-checksum-ipv4: off [fixed] tx-checksum-ip-generic: on tx-checksum-ipv6: off [fixed] tx-checksum-fcoe-crc: off [fixed] tx-checksum-sctp: off [fixed]scatter-gather: on tx-scatter-gather: on tx-scatter-gather-fraglist: off [fixed]tcp-segmentation-offload: on tx-tcp-segmentation: on tx-tcp-ecn-segmentation: on tx-tcp6-segmentation: onudp-fragmentation-offload: ongeneric-segmentation-offload: ongeneric-receive-offload: onlarge-receive-offload: off [fixed]rx-vlan-offload: off [fixed]tx-vlan-offload: off [fixed]ntuple-filters: off [fixed]receive-hashing: off [fixed]highdma: on [fixed]rx-vlan-filter: on [fixed]vlan-challenged: off [fixed]tx-lockless: off [fixed]netns-local: off [fixed]tx-gso-robust: off [fixed]tx-fcoe-segmentation: off [fixed]tx-gre-segmentation: off [fixed]tx-ipip-segmentation: off [fixed]tx-sit-segmentation: off [fixed]]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++类型转换]]></title>
    <url>%2F2018%2F10%2F28%2Fc-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[四种类型转换 static_cast 一种类型转换成另一种兼容类型, 通常用于转换数值类型, 编译时检查 dynamic_cast 虚基类转换成派生类, 运行时检查 const_cast 修改类型的const或volatile属性 reinterpret_cast 比较底层的转换, 在非相关的类型之间转换; 操作结果只是简单的从一个指针到别的指针的值的二进制拷贝;在类型之间指向的内容不做任何类型的检查和转换 code examplestatic_cast123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;vector&gt;#include &lt;iostream&gt; struct B &#123;&#125;;struct D : B &#123;&#125;; enum class E &#123; ONE, TWO, THREE &#125;;enum EU &#123; ONE, TWO, THREE &#125;; int main()&#123; // 1: initializing conversion int n = static_cast&lt;int&gt;(3.14); std::cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &apos;\n&apos;; std::vector&lt;int&gt; v = static_cast&lt;std::vector&lt;int&gt;&gt;(10); std::cout &lt;&lt; &quot;v.size() = &quot; &lt;&lt; v.size() &lt;&lt; &apos;\n&apos;; // 2: static downcast D d; B&amp; br = d; // upcast via implicit conversion 隐式转换 D&amp; another_d = static_cast&lt;D&amp;&gt;(br); // downcast // 3: lvalue to xvalue std::vector&lt;int&gt; v2 = static_cast&lt;std::vector&lt;int&gt;&amp;&amp;&gt;(v); std::cout &lt;&lt; &quot;after move, v.size() = &quot; &lt;&lt; v.size() &lt;&lt; &apos;\n&apos;; // 4: discarded-value expression static_cast&lt;void&gt;(v2.size()); // 5. inverse of implicit conversion // todo // 6. array-to-pointer followed by upcast D a[10]; B* dp = static_cast&lt;B*&gt;(a); // 7. scoped enum to int or float E e = E::ONE; int one = static_cast&lt;int&gt;(e); // 8. int to enum, enum to another enum E e2 = static_cast&lt;E&gt;(one); EU eu = static_cast&lt;EU&gt;(e2); // 9. pointer to member upcast // todo //std::transform(s.begin(), s.end(), s.begin(), static_cast&lt;int(*)(int)&gt;(std::toupper)); // 10. void* to any type void* voidp = &amp;e; std::vector&lt;int&gt;* p = static_cast&lt;std::vector&lt;int&gt;*&gt;(voidp);&#125;output:n = 3v.size() = 10after move, v.size() = 0 dynamic_cast123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt; struct V &#123; virtual void f() &#123;&#125;; // must be polymorphic to use runtime-checked dynamic_cast&#125;;struct A : virtual V &#123;&#125;;struct B : virtual V &#123; B(V* v, A* a) &#123; // casts during construction dynamic_cast&lt;B*&gt;(v); // well-defined: v of type V*, V base of B, results in B* dynamic_cast&lt;B*&gt;(a); // undefined behavior: a has type A*, A not a base of B &#125;&#125;;struct D : A, B &#123; D() : B((A*)this, this) &#123; &#125;&#125;; struct Base &#123; virtual ~Base() &#123;&#125;&#125;; struct Derived: Base &#123; virtual void name() &#123;&#125;&#125;; struct Some &#123; virtual ~Some() &#123;&#125;&#125;; int main()&#123; D d; // the most derived object A&amp; a = d; // upcast, dynamic_cast may be used, but unnecessary D&amp; new_d = dynamic_cast&lt;D&amp;&gt;(a); // downcast B&amp; new_b = dynamic_cast&lt;B&amp;&gt;(a); // sidecast Base* b1 = new Base; if(Derived* d = dynamic_cast&lt;Derived*&gt;(b1)) &#123; std::cout &lt;&lt; &quot;downcast from b1 to d successful\n&quot;; d-&gt;name(); // safe to call &#125; Base* b2 = new Derived; if(Derived* d = dynamic_cast&lt;Derived*&gt;(b2)) &#123; std::cout &lt;&lt; &quot;downcast from b2 to d successful\n&quot;; d-&gt;name(); // safe to call &#125; if(Some* d = dynamic_cast&lt;Some*&gt;(b1)) &#123; std::cout &lt;&lt; &quot;downcast from b1 to Some successful\n&quot;; d-&gt;name(); // safe to call &#125; delete b1; delete b2;&#125;output:downcast from b2 to d successful const_cast12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; struct type &#123; type() :i(3) &#123;&#125; void m1(int v) const &#123; // this-&gt;i = v; // compile error: this is a pointer to const const_cast&lt;type*&gt;(this)-&gt;i = v; // OK &#125; int i;&#125;; int main() &#123; int i = 3; // i is not declared const const int&amp; cref_i = i; const_cast&lt;int&amp;&gt;(cref_i) = 4; // OK: modifies i std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &apos;\n&apos;; type t; t.m1(4); std::cout &lt;&lt; &quot;type::i = &quot; &lt;&lt; t.i &lt;&lt; &apos;\n&apos;; const int j = 3; // j is declared const int* pj = const_cast&lt;int*&gt;(&amp;j); *pj = 4; // undefined behavior! void (type::*mfp)(int) const = &amp;type::m1; // pointer to member function// const_cast&lt;void(type::*)(int)&gt;(mfp); // compiler error: const_cast does not // work on function pointers&#125;output:i = 4type::i = 4 reinterpret_cast12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdint&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;int f() &#123; return 42; &#125;int main()&#123; int i = 7; // pointer to integer and back uintptr_t v1 = reinterpret_cast&lt;uintptr_t&gt;(&amp;i); // static_cast is an error std::cout &lt;&lt; &quot;The value of &amp;i is 0x&quot; &lt;&lt; std::hex &lt;&lt; v1 &lt;&lt; &apos;\n&apos;; int* p1 = reinterpret_cast&lt;int*&gt;(v1); assert(p1 == &amp;i); // pointer to function to another and back void(*fp1)() = reinterpret_cast&lt;void(*)()&gt;(f); // fp1(); undefined behavior int(*fp2)() = reinterpret_cast&lt;int(*)()&gt;(fp1); std::cout &lt;&lt; std::dec &lt;&lt; fp2() &lt;&lt; &apos;\n&apos;; // safe // type aliasing through pointer char* p2 = reinterpret_cast&lt;char*&gt;(&amp;i); if(p2[0] == &apos;\x7&apos;) std::cout &lt;&lt; &quot;This system is little-endian\n&quot;; else std::cout &lt;&lt; &quot;This system is big-endian\n&quot;; // type aliasing through reference reinterpret_cast&lt;unsigned int&amp;&gt;(i) = 42; std::cout &lt;&lt; i &lt;&lt; &apos;\n&apos;;&#125;output:The value of &amp;i is 0x7fff352c358042This system is little-endian42 lvalue/rvalue/prvalue/glvalue参考 123456789101112131415161718192021An lvalue (so-called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue.]An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references. [Example: The result of calling a function whose return type is an rvalue reference is an xvalue.]A glvalue (“generalized” lvalue) is an lvalue or an xvalue.An rvalue (so-called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a temporary object or subobject thereof, or a value that is not associated with an object.A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. [Example: The result of calling a function whose return type is not a reference is a prvalue]The document in question is a great reference for this question, because it shows the exact changes in the standard that have happened as a result of the introduction of the new nomenclature.]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++智能指针]]></title>
    <url>%2F2018%2F10%2F28%2Fc-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[智能指针 (头文件memory)小结auto_ptr c++11已废弃, 赋值后不安全，原指针变成野指针; 不支持数据和容器一起使用unique_ptr 替代 auto_ptr, 严格控制所有权, 不允许直接赋值, 可移动(move 后原指针为空);shared_ptr 采用引用计数, 安全性提高; 多个 shared_ptr 对象指向同个对象，多次析构core不安全;weak_ptr 不参与引用计数, 通过lock()访问 shared_ptr 实例拥有的对象 模板 shared_ptr 包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr 将接管原来归unique_ptr所有的对象。 auto_ptr废弃原因： 当把一个auto_ptr赋给另外一个auto_ptr时, 原指针变为野指针, 不安全 不支持数组和在容器中使用 1234567891011void Fun(auto_ptr&lt;Test&gt; p1 )&#123; cout&lt;&lt;p1-&gt;m_a&lt;&lt;endl;&#125;void main( )&#123; std::auto_ptr&lt;Test&gt; p( new Test(5) ); Fun(p); cout&lt;&lt;p-&gt;m_a&lt;&lt;endl;&#125; shared_ptr使用方式初始化:智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr p4 = new int(1) 写法是错误的 拷贝和赋值: 引用计数加1, 当计数为0时, 自动释放内存; 方法:get(): 获取原始指针reset(): 释放关联内存块的所有权，计数减一, 如果是最后一个指向该资源的shared_ptr, 就释放这块内存unique(): 判断是否是唯一指向当前内存的shared_ptr 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; &#123; int a = 10; std::shared_ptr&lt;int&gt; ptra = std::make_shared&lt;int&gt;(a); std::shared_ptr&lt;int&gt; ptra2(ptra); //copy std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl; // 2 int b = 20; int *pb = &amp;a; //std::shared_ptr&lt;int&gt; ptrb = pb; //error std::shared_ptr&lt;int&gt; ptrb = std::make_shared&lt;int&gt;(b); ptra2 = ptrb; //assign pb = ptrb.get(); //获取原始指针 std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; ptrb.use_count() &lt;&lt; std::endl; // 2 &#125;&#125;int main()&#123; auto ptr1 = std::make_shared&lt;Resource&gt;(); cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; // output: 1 &#123; auto ptr2 = ptr1; // 通过复制构造函数使两个对象管理同一块内存 std::shared_ptr&lt;Resource&gt; ptr3; // 初始化为空 ptr3 = ptr1; // 通过赋值，共享内存 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; // output: 3 cout &lt;&lt; ptr2.use_count() &lt;&lt; endl; // output: 3 cout &lt;&lt; ptr3.use_count() &lt;&lt; endl; // output: 3 &#125; // 此时ptr2与ptr3对象析构了 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; // output: 1&#125; 存在问题 多个shared_ptr对象用一个普通指针构造, 析构时core; 用make_shared 避免 用指针去创建shared_ptr, 不小心删除指针, 析构时core 循环引用, 资源都不会正常释放; 用weak_ptr 避免 读线程不安全, 写线程不安全 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ---1void main( )&#123; int* p = new int; shared_ptr&lt;int&gt; sptr1( p); shared_ptr&lt;int&gt; sptr2( p );&#125;// ---2class Person&#123;public: Person(const string&amp; name): m_name&#123;name&#125; &#123; cout &lt;&lt; m_name &lt;&lt; &quot; created&quot; &lt;&lt; endl; &#125; virtual ~Person() &#123; cout &lt;&lt; m_name &lt;&lt; &quot; destoryed&quot; &lt;&lt; endl; &#125; friend bool partnerUp(std::shared_ptr&lt;Person&gt;&amp; p1, std::shared_ptr&lt;Person&gt;&amp; p2) &#123; if (!p1 || !p2) &#123; return false; &#125; p1-&gt;m_partner = p2; p2-&gt;m_partner = p1; cout &lt;&lt; p1-&gt;m_name &lt;&lt; &quot; is now partenered with &quot; &lt;&lt; p2-&gt;m_name &lt;&lt; endl; return true; &#125;private: string m_name; std::shared_ptr&lt;Person&gt; m_partner; // std::weak_ptr&lt;Person&gt; m_partner;&#125;;int main()&#123; &#123; auto p1 = std::make_shared&lt;Person&gt;(&quot;Lucy&quot;); auto p2 = std::make_shared&lt;Person&gt;(&quot;Ricky&quot;); partnerUp(p1, p2); // 互相设为伙伴 &#125; cin.ignore(10); return 0;&#125;int main() &#123; &#123; std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10); std::cout &lt;&lt; sh_ptr.use_count() &lt;&lt; std::endl; std::weak_ptr&lt;int&gt; wp(sh_ptr); std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; if(!wp.expired())&#123; std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //get another shared_ptr *sh_ptr = 100; std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; &#125; &#125; //delete memory&#125; 其他 为什么要尽量使用 make_shared为了节省一次内存分配, 原来 shared_ptr x(new Foo); 需要为 Foo 和 ref_count各分配一次内存, 现在用 make_shared()的话, 可以一次分配一块足够大的内存, 供 Foo和 ref_count 对象容身, 数据结构是： explicit构造函数, 不允许隐式转换123456shared_ptr&lt;double&gt; pd; double *p_reg = new double;pd = p_reg; // not allowed (implicit conversion)pd = shared_ptr&lt;double&gt;(p_reg); // allowed (explicit conversion)shared_ptr&lt;double&gt; pshared = p_reg; // not allowed (implicit conversion)shared_ptr&lt;double&gt; pshared(p_reg); // allowed (explicit conversion) weak_ptr使用方式 方法 调用lock()可以得到shared_ptr或者直接将weak_ptr转型为shared_ptr 调用use_count()去获取引用计数，该方法只返回强引用计数，并不返回弱引用计数 调用expired()方法。比调用use_count()方法速度更快 解决循环引用内存不会释放问题 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; &#123; std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10); std::cout &lt;&lt; sh_ptr.use_count() &lt;&lt; std::endl; std::weak_ptr&lt;int&gt; wp(sh_ptr); std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; if(!wp.expired())&#123; std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //get another shared_ptr *sh_ptr = 100; std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; &#125; &#125; //delete memory&#125; unique_ptr不允许直接赋值, 支持数组/容器/lambda 表达式, 可以作为返回值和参数 12345678void useResource(const std::unique_ptr&lt;Resource&gt;&amp; res)auto ptr = std::make_unique&lt;Resource&gt;();useResource(ptr);void takeOwnerShip(std::unique_ptr&lt;Resource&gt;&amp;&amp; res)auto ptr = std::make_unique&lt;Resource&gt;();// takeOwnerShip(ptr); // 非法takeOwnerShip(std::move(ptr)); // 必须传递右值 方法release()：返回该对象所管理的指针，同时释放其所有权reset()：析构其管理的对象内存，同时也可以传递进来一个新的指针对象swap()：交换所管理的对象get()：返回对象所管理的指针get_deleter()：返回析构其管理指针的调用函数 12345678910111213141516171819202122232425262728int main()&#123; std::unique_ptr&lt;Fraction&gt; f1&#123; new Fraction&#123; 3, 5 &#125; &#125;; cout &lt;&lt; *f1 &lt;&lt; endl; // output: 3/5 std::unique_ptr&lt;Fraction&gt; f2; // 初始化为nullptr // f2 = f1 // 非法，不允许左值赋值 f2 = std::move(f1); // 此时f1转移到f2，f1变为nullptr // C++14 可以使用 make_unique函数 auto f3 = std::make_unique&lt;Fraction&gt;(2, 7); cout &lt;&lt; *f3 &lt;&lt; endl; // output: 2/7 // 处理数组，但是尽量不用这样做，因为你可以用std::array或者std::vector auto f4 = std::make_unique&lt;Fraction[]&gt;(4); std::cout &lt;&lt; f4[0] &lt;&lt; endl; // output: 0/1 cin.ignore(10); return 0;&#125;// 注意：无法处理数组template&lt;typename T, typename ... Ts&gt;std::unique_ptr&lt;T&gt; make_unique(Ts ... args)&#123; return std::unique_ptr&lt;T&gt; &#123;new T&#123; std::forward&lt;Ts&gt;(args) ... &#125;&#125;;&#125; 优点 将一个unique_ptr赋值给另一个时, 如果源 unique_ptr是个临时右值, 编译器允许这么做 1234567unique_ptr&lt;string&gt; demo(const char * s)&#123; unique_ptr&lt;string&gt; temp (new string (s))； return temp；&#125;unique_ptr&lt;string&gt; ps;ps = demo(&apos;Uniquely special&quot;)； 无法赋值, 可以移动; 或者release释放后reset转移 12unique_ptr&lt;Foo&gt; ptr = make_unique&lt;Foo&gt;();Foo* p = ptr.release(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;cassert&gt;#include &lt;functional&gt; struct B &#123; virtual void bar() &#123; std::cout &lt;&lt; &quot;B::bar\n&quot;; &#125; virtual ~B() = default;&#125;;struct D : B&#123; D() &#123; std::cout &lt;&lt; &quot;D::D\n&quot;; &#125; ~D() &#123; std::cout &lt;&lt; &quot;D::~D\n&quot;; &#125; void bar() override &#123; std::cout &lt;&lt; &quot;D::bar\n&quot;; &#125;&#125;; // a function consuming a unique_ptr can take it by value or by rvalue referencestd::unique_ptr&lt;D&gt; pass_through(std::unique_ptr&lt;D&gt; p)&#123; p-&gt;bar(); return p;&#125; void close_file(std::FILE* fp) &#123; std::fclose(fp); &#125; int main()&#123; std::cout &lt;&lt; &quot;unique ownership semantics demo\n&quot;; &#123; auto p = std::make_unique&lt;D&gt;(); // p is a unique_ptr that owns a D auto q = pass_through(std::move(p)); assert(!p); // now p owns nothing and holds a null pointer q-&gt;bar(); // and q owns the D object &#125; // ~D called here std::cout &lt;&lt; &quot;Runtime polymorphism demo\n&quot;; &#123; std::unique_ptr&lt;B&gt; p = std::make_unique&lt;D&gt;(); // p is a unique_ptr that owns a D // as a pointer to base p-&gt;bar(); // virtual dispatch std::vector&lt;std::unique_ptr&lt;B&gt;&gt; v; // unique_ptr can be stored in a container v.push_back(std::make_unique&lt;D&gt;()); v.push_back(std::move(p)); v.emplace_back(new D); for(auto&amp; p: v) p-&gt;bar(); // virtual dispatch &#125; // ~D called 3 times std::cout &lt;&lt; &quot;Custom deleter demo\n&quot;; std::ofstream(&quot;demo.txt&quot;) &lt;&lt; &apos;x&apos;; // prepare the file to read &#123; std::unique_ptr&lt;std::FILE, decltype(&amp;close_file)&gt; fp(std::fopen(&quot;demo.txt&quot;, &quot;r&quot;), &amp;close_file); if(fp) // fopen could have failed; in which case fp holds a null pointer std::cout &lt;&lt; (char)std::fgetc(fp.get()) &lt;&lt; &apos;\n&apos;; &#125; // fclose() called here, but only if FILE* is not a null pointer // (that is, if fopen succeeded) std::cout &lt;&lt; &quot;Custom lambda-expression deleter demo\n&quot;; &#123; std::unique_ptr&lt;D, std::function&lt;void(D*)&gt;&gt; p(new D, [](D* ptr) &#123; std::cout &lt;&lt; &quot;destroying from a custom deleter...\n&quot;; delete ptr; &#125;); // p owns D p-&gt;bar(); &#125; // the lambda above is called and D is destroyed std::cout &lt;&lt; &quot;Array form of unique_ptr demo\n&quot;; &#123; std::unique_ptr&lt;D[]&gt; p&#123;new D[3]&#125;; &#125; // calls ~D 3 times&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gstack]]></title>
    <url>%2F2018%2F10%2F25%2Fgstack%2F</url>
    <content type="text"><![CDATA[123456#!bin/shwhile( true )do gstack $1&gt;&gt;gstack_$1.txtsleep 1done]]></content>
      <categories>
        <category>gdb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Posix线程编程指南]]></title>
    <url>%2F2018%2F10%2F24%2FPosix%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[其他经典概括：POSIX Threads Programming 推荐书籍：Programe with POSIX Threads 摘自 IBM developerWorks 图书频道 Posix线程编程指南线程创建与取消 线程私有数据线程同步线程终止杂项 通用线程：POSIX 线程详解一种支持内存共享的简捷工具称作互斥对象的小玩意使用条件变量提高效率 线程池的介绍及简单实现c++ 内存池]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信]]></title>
    <url>%2F2018%2F10%2F24%2FLinux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[摘自 IBM developerworks 郑彦兴 深刻理解Linux进程间通信(IPC) Linux环境进程间通信（一）Linux环境进程间通信（二）信号（上）Linux环境进程间通信（二）信号（下）Linux环境进程间通信（三）消息队列Linux环境进程间通信（四）信号灯Linux环境进程间通信（五）共享内存（上）Linux环境进程间通信（五）共享内存（下）Linux 环境进程间通信（六）套接口小结 管道及有名管道: 具有亲缘关系的进程间通信, 有名管道克服了管道没有名字的限制, 可用于无亲缘关系进程间通信 信号: 通知某进程某个事件发生, 可发送给自身。 报文队列(消息队列): 消息队列是消息的链接, 随内核持续; 克服了信号承载信息少, 管道只能承载无格式字节流以及缓冲区大小受限制缺点 信号量(semaphore): 进程间及同一进程不同线程间的同步手段。 共享内存: 使多个进程可以访问同一块内存, 是最快的可用IPC形式。针对其他通信机制运行效率低设计。可与信号量配合使用,达到进程间的同步和互斥 套接口(socket): 用于不同机器之间的进程间通信。 管道及有名管道123456#include &lt;unistd.h&gt;int pipe(int fd[2])#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char * pathname, mode_t mode) 写端依赖读端, 读端关闭, SIGPIPE信号默认停止 信号信号本质信号是对软中断机制的模拟, 信号是异步的 信号种类可靠信号和不可靠信号, 可靠信号支持排队不会丢失(信号值位于SIGRTMIN及SIGRTMAX之间);实时信号和非实时信号, 实时信号都是可靠信号, 支持排队, 非实时信号都是不可靠信号 信号安装sigaction比signal 多了一个信息传递 进程对信号响应忽略/捕捉/默认缺省操作, 其中SIGSTOP/SIGKILL不能忽略 信号发送发送信号的主要函数有：kill()、raise()、 sigqueue()、alarm()、setitimer()以及abort()。 信号安装123456#include &lt;signal.h&gt; typedef void (*sighandler_t)(int)； sighandler_t signal(int signum, sighandler_t handler)); #include &lt;signal.h&gt; int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact)); 信号阻塞和信号未决1234#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oldset))；int sigpending(sigset_t *set));int sigsuspend(const sigset_t *mask))； 信号生命周期信号的诞生-&gt;信号在进程中注册-&gt;信号在进程中注销-&gt;信号处理函数执行完毕 在进程的task_struct中有信号链表, 注册就是将信号加入到链表中。可靠信号一定会加入, 不可靠信号如有同一信号注册, 只会注册一次。 信号编程注意事项 为增强程序稳定性, 信号处理程序中应当使用可重入函数, 避免信号处理执行函数执行后修改数据导致出现不可预料结果。 满足下列要求的基本是不可再入: 使用静态数据结构, 如getlogin()，gmtime()，getgrgid()，getgrnam()，getpwuid()以及getpwnam()等等 函数实现时，调用了malloc() 或者free()函数 实现使用了标准I/O函数， 如printf是可不再入 read/write/_exit/open 等是可再入函数 消息队列基本概念消息队列是随内核持续的一个消息链表(struct ipc_ids msg_ids) 消息队列操作1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;key_t ftok (char*pathname, char proj)；// 不够直观int ipc(unsigned int call, int first, int second, int third, void * ptr, long fifth);// 获取消息队列描述符int msgget(key_t key, int msgflg)// 读取一个消息, 存储在msgbuf中int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg);// 向队列发送一个消息, 发送消息+队列中消息&gt;=容量时会阻塞int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, int msgflg);// 设置属性或删除消息队列int msgctl(int msqid, int cmd, struct msqid_ds *buf); 信号量概念随内核持续, 进程间的同步手段(struct ipc_ids sem_ids) 操作1234567891011121314#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;// 文件名到键值映射key_t ftok (char*pathname, char proj)// key 键值, nsems 信号量个数, int semget(key_t key, int nsems, int semflg)// sops指向数组的每一个sembuf结构, nsops为sops指向数组的大小int semop(int semid, struct sembuf *sops, unsigned nsops)int semctl(int semid，int semnum，int cmd，union semun arg) 共享内存1234567// 建立和解除映射关系void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset ) int munmap( void * addr, size_t len ) #include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;API：shmget()、shmat()、shmdt()及shmctl() 区别是随进程和随内核 套接口123456789101112131415161718192021222324252627282930313233343536373839404142// 套接口是由socket数据结构代表的struct socket&#123;socket_state state; /* 指明套接口的连接状态，一个套接口的连接状态可以有以下几种套接口是空闲的，还没有进行相应的端口及地址的绑定；还没有连接；正在连接中；已经连接；正在解除连接。 */ unsigned long flags; struct proto_ops ops; /* 指明可对套接口进行的各种操作 */ struct inode inode; /* 指向sockfs文件系统中的相应inode */ struct fasync_struct *fasync_list; /* Asynchronous wake up list */ struct file *file; /* 指向sockfs文件系统中的相应文件 */struct sock sk; /* 任何协议族都有其特定的套接口特性，该域就指向特定协议族的套接口对象。 */ wait_queue_head_t wait; short type; unsigned char passcred;&#125;;// 描述套接口通用地址的数据结构struct sockaddr// 由于历史的缘故，在bind、connect等系统调用中, 地址都需要强转struct sockaddr &#123; sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */&#125;;// 描述因特网地址结构的数据结构struct sockaddr_instruct sockaddr_in &#123; __SOCKADDR_COMMON (sin_); /* 描述协议族 */ in_port_t sin_port; /* 端口号 */ struct in_addr sin_addr; /* 因特网地址 */ /* Pad to size of `struct sockaddr&apos;. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; &#125;;// 接口int socket( int domain, int type, int ptotocol)int bind( int sockfd, const struct sockaddr * my_addr, socklen_t my_addr_len)int connect( int sockfd, const struct sockaddr * servaddr, socklen_t addrlen)int accept( int sockfd, struct sockaddr * cliaddr, socklen_t * addrlen) 补充12345678910111213ipcs用法 ipcs -a 是默认的输出信息 打印出当前系统中所有的进程间通信方式的信息ipcs -m 打印出使用共享内存进行进程间通信的信息ipcs -q 打印出使用消息队列进行进程间通信的信息ipcs -s 打印出使用信号进行进程间通信的信息ipcrm用法 ipcrm -M shmkey 移除用shmkey创建的共享内存段ipcrm -m shmid 移除用shmid标识的共享内存段ipcrm -Q msgkey 移除用msqkey创建的消息队列ipcrm -q msqid 移除用msqid标识的消息队列ipcrm -S semkey 移除用semkey创建的信号ipcrm -s semid 移除用semid标识的信号]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zk原理和实践]]></title>
    <url>%2F2018%2F10%2F24%2Fzk%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[透彻的学习笔记ZooKeeper学习第一期—Zookeeper简单介绍ZooKeeper学习第二期–ZooKeeper安装配置ZooKeeper学习第三期—Zookeeper命令操作ZooKeeper学习第四期—构建ZooKeeper应用ZooKeeper学习第五期–ZooKeeper管理分布式环境中的数据ZooKeeper学习第六期—ZooKeeper机制架构ZooKeeper学习第七期–ZooKeeper一致性原理ZooKeeper学习第八期——ZooKeeper伸缩性实践]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[UML关系图 关系 描述 箭头 补充 依赖 use a 虚线+箭头 工厂模式 关联 has a 实线+箭头 一个类作为参数 聚合 has a 实线+空心菱形 例如指针成员 组合 contains a 实线+实心菱形 一个整体 继承 泛化 实线+空心三角 指向基类 接口实现 虚线+空心三角 指向基类 调用 实线+实心三角 指向接口 聚合和组合生命周期不一样: 聚合对象删除, 部分对象还存在; 组合对象删除, 部分事物对象全部删除创建模式 创建模式 功能 约束 factory 定义创建一个对象接口,封装对象的创建,在子类中创建对象(延迟实例化) 新增一个procudct就要新加接口，factory接口永远不封闭 abstractFactory 将一组对象创建封装到一个类中, abstactFactory是为一组相关或依赖的对象提供创建接口或延迟对象创建到子类中 新增一个product对应新增一个concreteFactory类 singleton static成员变量记录实例, 提供一个static的接口Instance()来获得唯一的实例 对象构造函数为private或proctected builder 将一个复杂对象的构建和表示分离, 同样的构建过程可以创建不同的表示 实际也是定义一个创建对象接口, 使用多个简单的对象一步一步构建成一个复杂的对象 prototype 自我复制自己创建的对象 c++通过拷贝构造实现 结构模式 结构模式 功能 约束 adapter 将一个类的接口变换成客户端期待的, 使原本因接口不匹配无法在一起工作的两个类能够一起工作 复用接口或对象实现 bridge 使用组合方式将抽象和实现分离 调整实现逻辑, 外部调用没有变化 composite 提供对子类的管理策略，重在对象 递归构建树状组织, 组合模式让客户可以一致地使用组合结构和单个对象 decorater 添加职责，重在职责 职责管理, 例如批价process flyweight 享元模式, 为共享对象提供一个仓库 对象池 facade 外观模式 在高层提供统一的接口 隐藏系统的复杂性, 并向客户端提供了一个客户端可以访问系统的接口 proxy 请求实际提交给其他类处理，逻辑和实现彻底解构 创建具有现有对象的对象，以便向外界提供功能接口 通过private, 接口继承, 就是派生类只继承函数的接口，也就是声明通过public, 实现继承, 就是派生类同时继承函数的接口和实现组合和装饰模式在实现上完全不同 行为模式 行为模式 功能 约束 template 算法由子类去实现, 实现和抽象接口解耦 继承实现 strategy 将算法封装到到一个类中 组合实现 state 将状态和动作实现分离 条件分支语句的代替者 observer 对MVC是该模式的一个实例 memento 备忘录模式 不破坏封装, 获取和保存一个类的内部状态, 用来恢复; 通过friend class实现 Mediator 中介者模式 将对象间的交互和通讯封装到一个类中 command 命令模式 将”行为请求者”与”行为实现者”解耦 visitor 访问者模式,将变更封装到一个类中, 由待更改类提供一个接口 符合单一原则,易扩展,但依赖了具体类 chain of responsibility 职责链模式 一个请求指定一组对象处理 Iterator 迭代器 将对象遍历封装到一个类中 Interpreter 解释器 模式 解决问题 优点 缺点 应用场景 参考设计模式菜鸟教程]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[性能之巅 笔记]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 绪论系统性能上对整个系统的研究，包括了所有硬件组件和整个软件栈。所有数据路径上和软硬件上发生的事情都包括在内，因为这些可能都影响性能。 性能领域包括以下事情： 1. 设置性能目标和建立性能模型 2. 基于软件或硬件原型进行性能特征归纳 3. 对开发的代码进行性能测试(软件整合之前) 4. 执行软件的非回归性测试(软件发布前或发布后) 5. 针对软件发布的基准测试 6. 目标环境中的概念验证测试 7. 生产环境的部署的配置优化 8. 监控生产环境中运行的软件 9. 特定问题的性能分析 术语容量规划是指一系列事前行动。在计划阶段，通过研究开发软件的资源占用情况，来得知原有设计在多大程度上能满足目标需求。在部署后，这样的问题在出现之前就能被预测。 性能分析必须量化问题的重要程度， 有一个指标非常合适，延时。 动态跟踪技术把所有的软件变得可以监控，而且能用在真实的生产环境中。这项技术利用内存中的CPU指令并在这些指令上动态构建检测数据。这样能从任何运行的软件中获得定制化的性能统计数据，从而提供了远超系统的自带的统计所能给予的观测性。 DTrace对用户态和内核态的软件都提供了静态跟踪和动态跟踪，并且数据是实时产生的。 第二章 方法术语：IOPS：每秒输入/输出的操作次数，是数据传输的一个度量方法。对于磁盘，就是每秒读和写的次数。吞吐量：数据传输或操作的速度响应时间：一次操作完成的时间延时: 操作里用来等待服务的时间使用率：对于服务所请求的资源，描述在给定的时间区间内资源的繁忙程度饱和度: 某一资源无法满足服务的排队工作量/瓶颈/工作负载/缓存 模型：第三章 操作系统了解操作系统和内核对于系统性能分析是至关重要的。会经常需要针对系统行为的开发和测试，如系统调用是如何执行的、CPU是如何调度线程的、有限大小的内存是如何影响性能的、或者文件系统是如何处理I/O的。 基本概念介绍，最好结合《深入理解计算机系统》： 内核：内核的执行/时钟/内核态栈：用户栈和内核栈; 用函数和寄存器的方式记录了线程的执行历史中断和中断线程进程：进程的创建、进程的生命周期、进程环境系统调用虚拟内存内存管理调度器文件系统：VFS、I/O栈缓存（括号内为例子）：应用程序缓存、服务器缓存(apache缓存)、缓存服务器(redis)、数据库缓存(mysql缓冲区高速缓存)、 目录缓存(DNLC)、文件元数据缓存(inode 缓存)、 操作系统缓存区高速缓存(segvn)、文件系统主缓存(ZFS ARC) 文件系统次缓存(ZFS L2ARC)、设备缓存(ZFS vdev)、 块缓存(缓冲区高速缓存)、磁盘控制器缓存(RAID卡缓存) 存储阵列缓存、磁盘内置缓存网络设备驱动多处理器：CPU交叉调用抢占资源管理观测性 第四章 观测工具工具可以按照系统级别和进程级别来分类，多数工具要么基于计数器要么基于跟踪。 系统级 | vmstat/iostat| mpstat/sar | dtrace/tcpdump |计数器——————-跟踪 pmap | ps | gdb/strace top | 进程级 计数器： 内核维护了各种统计数据，称为计数器，用于对事件的计数。通常计数器实现为无符号整形，发生事件时递增。 系统级别的计数器： vmstat: 虚拟内存和物理内存的统计 mpstat: 每个CPU的使用情况 iostat: 每个磁盘 I/O 的使用情况，由块设备接口报告 netstat: 网络接口统计 sar: 各种各样统计，能归档历史数据 iftop: 用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等 进程级别： ps：进程状态，显示进程的各种统计信息，包括内存和CPU的使用 top：按一个统计数据排序，显示排名高的进程 pmap：将进程的内存和使用统计一起列出 iotop: 进程的I/O速度 pidstat：每个进程/线程CPU使用量 一般来说，上述工具从/proc 文件系统里读取统计信息。 跟踪：系统级别： tcpdump：网络抓包(libpcap) bltrace: 块I/O 跟踪 dtrace: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态跟踪 perf: linux 性能事件，跟踪静态和动态的指针 进程级别： strace: 系统调用跟踪 gdb: 调式源码 网络工具： nethogs: 按进程查看流量占用 iptraf: 按连接/端口查看流量 ifstat: 按设备查看流量 ethtool: 诊断工具 tcpdump: 抓包工具 ss: 连接查看工具, 比netstat更快速更高效 其他: dstat, slurm, nload, bmon 第五章 应用程序性能调整离执行的地方越近越好：最好在应用程序里，包括web服务器、应用服务器、负载均衡、文件服务器等等 设立性能目标能为你的性能分析工作指明方向，并帮助你选择要做的事情。没有目标，性能分析容易沦为随机的[钓鱼探险]。常见目标： 延时 吞吐量 资源使用率 应用程序性能技术：选择I/O尺寸、缓存、缓冲区、轮询、并发和并行、非阻塞I/O、处理器绑定 编程语言相关：编译器优化、解释语言一般不是首选、虚拟机、垃圾回收 第六章 CPU 第七章 内存背景：内存相关术语架构：内存软硬件架构方法：内存分析的方法分析：分析内存性能工具调优：性能调优和可调参数范例 1.背景主存：物理内存，高速数据存储区域，动态随机访问内存(DRAM)虚拟内存: 一个抽象的主存概念，无限和非竞争性，虚拟内存不是真实的内存常驻内存：当前处于主存中的内存匿名内存: 无文件系统位置或者路径名的内存。包括进程地址空间的工作数据，称作堆。地址空间：内存上下文。每个进程和内核都有对应的虚拟内存空间段：标记为特殊用途的一块内存区域，例如用来存储可执行或者可写的页OOM：内存耗尽，内核检测到可用内存低页：操作系统和CPU使用的内存单位。一直以来都是4KB或8KB，现代处理器允许多种页大小。缺页：无效内存。使用按虚拟内存，这是正常事件。交换：将整个进程从主存转移到交换设备。交换(空间)：存放换页的匿名数据和交换进程的磁盘空间。可以是存储设备的一块空间， 也称为物理交换设备，或者是文件系统，称作交换文件。 换页：页面换入和调出主存。包含文件系统换页(mmap), 匿名换页(进程堆和栈) 按需换页：将虚拟内存映射到物理内存。CPU创建映射的开销延迟到实际需要或者访问。 过度换页：支持按需换页操作系统，malloc可以申请大于物理内存和交换设备的总和。 文件系统缓占用：应用进程需要时会释放 2.架构硬件：主存，总线，CPU缓存，MMU(内存管理单元)软件： 3.方法 第八章 文件系统 第九章 磁盘 第十章 网络]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++ 编程思想 笔记]]></title>
    <url>%2F2018%2F10%2F24%2Fc-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPC框架原理和实践]]></title>
    <url>%2F2018%2F10%2F24%2FRPC%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[简单的RPC框架有三部分组成： 1 服务提供者，运行在服务端，负责提供服务接口定义和服务实现类2 服务发布者，运行在RPC服务端，负责将本地服务发布成远程服务，供其他消费者调用3 本地服务代理，运行在RPC客户端，通过代理调用远程服务提供者，然后将结果进行封返回给本地消费者 RPC框架的调用原理如图： 服务治理问题在大规模服务化之前，应用可能只是通过RPC框架，简单的暴露和引用远程服务，通过配置URL地址进行远程服务调用，路由则通过F5负载均衡器等进行简单的负载均衡。 当服务越来越多的时候，服务的URL配置管理变得更加困难。单纯的使用RPC就有点吃不消。所以在大规模分布式集群中，RPC只是作为集群的一个方法调用手段。 RPC框架实现的几个核心技术点： 远程服务提供者 需要以某种形式(url/idl)提供给服务调用者 远程代理对象 服务调用者调用的服务实际是远程服务的本地代理 通信： 与具体协议无关 序列化：远程通信需要将对象转成二进制进行传输，不同序列化框架，支持的数据类型数据包大小，及性能差异很大 PRC框架高性能设计 I/O调度模型：同步阻塞(BIO) 还是非阻塞(NIO) 序列化框架的选择：文本协议、二进制协议、压缩后的二进制协议 线程调度模型： 串行或是并行调度，锁竞争还是无锁化 实践消息定义Header: TaskCreateTime/TaskTimeOut/SessionId/TenantldBody: Session String/SDL stream/ErrorInfo 序列化根据不同的序列化框架做比对测试 框架版本 测试内容 处理次数 耗时(us) 每秒处理次数 每次耗时(us) 1.8.x SJSON序列化 10000 416,225 24,025 41.62 1.8.x SJSON反序列化 10000 581,872 17,185 58.19 2.1.0 SCDR序列化 500000 2,716,170 184,083 5.43 2.1.0 SCDR反序列化 500000 3,409,015 146,670 6.82 2.1.0 SJSON序列化 10000 1,145,281 8,731 115 2.1.0 SJSON反序列化 10000 954,927 10,472 95.5 2.2.0 SJSON序列化 10000 427225 23,407 42.72 2.2.0 SJSON反序列化 10000 505211 19,794 50.52 RPC服务端模型设计1 纯粹单线程模型 所有工作在一个线程里实现采用非阻塞I/O实现单线程处理能力最大化，但没有扩展能力适用于连接数少、负载轻的服务场景 2 独立事件轮询线程 + 工作线程组模型 独立的事件轮询线程工作线程可水平扩展（性能非线性扩展）线程间频繁数据交换需要同步机制影响性能工作线程一次只处理一个连接的任务，对于慢速连接效率不高（可能会被阻塞）适用于任务量不大但业务处理耗时较大、网速快且稳定等场景 3 独立端口监听 + I/O及工作线程组模型 独立端口监听线程，获取的新连接转发给指定的工作线程工作线程负责socket连接的I/O时间轮询，以及后续的消息I/O和业务处理采用非阻塞I/O，处理能力随工作线程的扩展而线性扩展适用于连接数大、任务量大但业务处理耗时较小的场景 4 独立端口监听 + I/O线程 + BIZ线程分组模型 I/O事件轮询和消息收发由独立I/O线程执行业务处理由独立线程执行并可扩展一个I/O线程和若干和BIZ线程组成一个线程组，并可按组横向扩展适用于连接数多，任务量大，任务处理耗时大的场景]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux 常用命令]]></title>
    <url>%2F2018%2F10%2F24%2Flinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[系统级计数器vmstat查看整个机器的CPU,内存,IO的使用情况, 如间隔2秒采集3次1234567891011121314151617181920212223242526272829303132333435363738394041424352_zjdev[/data01/zjgrp/zjdev]%vmstat 2 3procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 2103292 2772856 570784 44911892 0 0 11 314 0 0 22 4 73 1 0 8 0 2103292 2772972 570784 44912092 0 0 0 66 45187 109175 2 3 94 0 0 6 0 2103292 2772476 570784 44912340 0 0 0 500 41664 105258 2 3 94 1 0进程：r 运行队列(CPU正在执行或正在等待CPU的进程数)b 阻塞进程,等待IO的进程数量(不可中断)内存：swpd 虚拟内存已使用大小, 如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能free 空闲物理内存大小buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用500多Mcache cache直接用来记忆我们打开的文件,给文件做缓冲(Linux/Unix的聪明之处，把空闲的物理内存 的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用)Swap：si: 每秒从交换区写到内存的大小，由磁盘调入内存so: 每秒写入交换区的内存大小，由内存调入磁盘注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源 都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点， 还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会 受到影响的IO(现在的Linux版本块的大小为1kb):bi: 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024bytebo: 每秒写入的块数随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大system(系统):in: 每秒中断数，包括时钟中断cs: 每秒上下文切换数上面2个值越大，会看到由内核消耗的CPU时间会越大CPU(以百分比表示):us: 用户进程执行时间百分比(us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用， 那么我们就该考虑优化程序算法或者进行加速)sy: 内核系统进程执行时间百分比(sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因)id: 空闲时间百分比wa: IO等待时间百分比(wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈,块操作)st: iostat查看磁盘I/O使用和CPU情况1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@zhangbb ~]# iostat -d vda 3 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.36 0.07 3.26 1000024 46518530Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 1.01 0.00 4.04 0 12Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.67 0.00 20.20 0 60tps：该设备每秒的传输次数&quot;一次传输&quot;意思是&quot;一次I/O请求&quot;。多个逻辑请求可能会被合并为&quot;一次I/O请求&quot;。&quot;一次传输&quot;请求的大小是未知的。kB_read/s：每秒从设备（drive expressed）读取的数据量kB_wrtn/s：每秒向设备（drive expressed）写入的数据量kB_read：读取的总数据量kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes-x：显示扩展状态[root@zhangbb ~]# iostat -d -x 1 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.44 0.00 0.35 0.07 3.26 18.71 0.00 0.40 1.34 0.39 0.21 0.01Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00&gt; rrqm/s: 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并&gt; wrqm/s: 每秒对该设备的写请求被合并次数&gt; r/s: 每秒完成的读次数&gt; w/s: 每秒完成的写次数&gt; rkB/s: 每秒读数据量(kB为单位)&gt; wkB/s: 每秒写数据量(kB为单位)&gt; avgrq-sz:平均每次IO操作的数据量(扇区数为单位)&gt; avgqu-sz: 平均等待处理的IO请求队列长度&gt; await: 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)&gt; svctm: 平均每次IO请求的处理时间(毫秒为单位)&gt; %util: 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率util = (r/s+w/s) * (svctm/1000) mpstat每个CPU的使用情况123456789101112131415161718192021从/proc/stat获得数据[root@zhangbb ~]# mpstat 3 5Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)03:18:09 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle03:18:12 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.33 0.00 0.00 99.6703:18:15 PM all 0.34 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 99.6603:18:18 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.0003:18:21 PM all 0.33 0.00 0.33 0.00 0.00 0.00 0.33 0.00 0.00 99.0003:18:24 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.34 0.00 0.00 99.66Average: all 0.13 0.00 0.07 0.00 0.00 0.00 0.20 0.00 0.00 99.60CPU 处理器IDuser 在时间段里，用户态的CPU时间(%)，不包含 nice值为负 进程 (usr/total)*100 nice 在时间段里，nice值为负进程的CPU时间(%) (nice/total)*100 system 在时间段里，核心时间(%) (system/total)*100iowait 在时间段里，硬盘IO等待时间(%) (iowait/total)*100irq 在时间段里，硬中断时间(%) (irq/total)*100soft 在时间段里，软中断时间(%) (softirq/total)*100idle 在时间段里，CPU除去等待磁盘IO操作外的因为任何原因而空闲的时间闲置时间(%)(idle/total)*100intr/s 在时间段里，每秒CPU接收的中断的次数intr/total)*100 free12345678952_zjdev[/data01/zjgrp/zjdev]%free -h total used free shared buffers cachedMem: 63G 61G 1.8G 21G 567M 43G-/+ buffers/cache: 17G 45GSwap: 2.0G 2.0G 32K(-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached(+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached可见-buffers/cache反映的是被程序实实在在吃掉的内存，而+buffers/cache反映的是可以挪用的内存总数 sar1234567891011121314151617181920212223sar -u 1 2 //体CPU使用统计sar -P ALL 1 1 //各个CPU使用统计sar -r 1 2 //内存使用情况统计sar -b 1 2 //整体I/O情况sar -d -p 1 1 //各个I/O设备情况sar -n DEV 1 1 //网络统计[root@zhangbb ~]# sar -n DEV 1 1Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)07:59:15 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s07:59:16 PM eth0 6.12 5.10 0.59 0.95 0.00 0.00 0.0007:59:16 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0007:59:16 PM ip_vti0 0.00 0.00 0.00 0.00 0.00 0.00 0.0007:59:16 PM docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00IFACE: 网络接口名称rxpck/s: 每秒收包的数量txpck/s: 每秒发包的数量rxkB/s: 每秒收的数据量(kB为单位)txkB/s: 每秒发的数据量(kB为单位)sar日志保存(-o) 进程级计数器top按一个统计数据排序，显示排名高的进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646552_zjdev[/data01/zjgrp/zjdev]%top -u zjv8cs -d 3top - 14:16:50 up 168 days, 17:39, 34 users, load average: 0.95, 0.74, 0.66Tasks: 418 total, 1 running, 417 sleeping, 0 stopped, 0 zombie%Cpu(s): 22.1 us, 3.3 sy, 0.0 ni, 73.6 id, 0.7 wa, 0.0 hi, 0.3 si, 0.0 stKiB Mem: 66109508 total, 65616660 used, 492848 free, 321260 buffersKiB Swap: 2103292 total, 2103292 used, 0 free. 47138260 cached Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3869 zjv8cs 20 0 26.460g 504060 16484 S 6.250 0.762 124:55.11 sframe 6343 zjv8cs 20 0 19.333g 332120 7328 S 0.000 0.502 20:45.48 java 6369 zjv8cs 20 0 2921872 224360 26232 S 0.000 0.339 77:42.57 odframe 6480 zjv8cs 20 0 23.116g 102460 90296 S 0.000 0.155 1:11.94 sframe 6482 zjv8cs 20 0 23.064g 27784 16352 S 0.000 0.042 1:09.05 sframe 6484 zjv8cs 20 0 23.062g 28872 15584 S 0.000 0.044 1:08.88 sframe 6503 zjv8cs 20 0 23.116g 59680 47540 S 0.000 0.090 1:10.93 sframe 6511 zjv8cs 20 0 23.119g 358908 336920 S 0.000 0.543 1:22.49 sframe 6520 zjv8cs 20 0 23.116g 1.069g 1.056g S 0.000 1.696 1:45.00 sframe 6536 zjv8cs 20 0 23.066g 27624 15596 S 0.000 0.042 1:09.88 sframe 6543 zjv8cs 20 0 23.288g 2.963g 2.820g S 0.000 4.700 3:10.91 sframe 6552 zjv8cs 20 0 23.118g 369656 356788 S 0.000 0.559 1:22.45 sframe 6554 zjv8cs 20 0 23.116g 29924 17728 S 0.000 0.045 1:11.02 sframe 6567 zjv8cs 20 0 23.061g 26992 15396 S 0.000 0.041 1:09.80 sframe 7061 zjv8cs 20 0 31968 1244 736 S 0.000 0.002 0:01.24 systemd 7062 zjv8cs 20 0 63640 40 0 S 0.000 0.000 0:00.00 (sd-pam) 7492 zjv8cs 20 0 24.637g 62640 7180 S 0.000 0.095 38:41.25 sframe 8069 zjv8cs 20 0 23.476g 30552 17872 S 0.000 0.046 9:14.04 odframe 8101 zjv8cs 20 0 23.116g 89672 77504 S 0.000 0.136 1:13.43 sframe 8156 zjv8cs 20 0 24.643g 68264 6964 S 0.000 0.103 34:18.32 sframe 8683 zjv8cs 20 0 23.136g 18508 8916 S 0.000 0.028 1:04.60 sframe 14603 zjv8cs 20 0 23.003g 28440 16644 S 0.000 0.043 0:24.28 sframe 14838 zjv8cs 20 0 25.779g 437940 21188 S 0.000 0.662 124:05.00 sframe 17791 zjv8cs 20 0 87688 1800 904 S 0.000 0.003 0:00.03 sshd 17792 zjv8cs 20 0 16824 3376 1452 S 0.000 0.005 0:00.15 csh上半部分：top一行：从左到右依次为当前系统时间，系统运行的时间，系统在之前1min、5min和15min内cpu的平均负载值Tasks一行：该行给出进程整体的统计信息，包括统计周期内进程总数、运行状态进程数、休眠状态进程数、停止状态进程数和僵死状态进程数Cpu(s)一行：cpu整体统计信息，包括用户态下进程、系统态下进程占用cpu时间比，nice值大于0的进程在用户态下占用cpu时间比，cpu处于idle状态、wait状态的时间比，以及处理硬中断、软中断的时间比Mem一行：该行提供了内存统计信息，包括物理内存总量、已用内存、空闲内存以及用作缓冲区的内存量Swap一行：虚存统计信息，包括交换空间总量、已用交换区大小、空闲交换区大小以及用作缓存的交换空间大小下半部：PID: 进程pidUSER: 拉起进程的用户PR: 该列值加100为进程优先级，若优先级小于100，则该进程为实时(real-time)进程， 否则为普通(normal)进程，实时进程的优先级更高，更容易获得cpu调度，以上输出结果中， java进程优先级为120，是普通进程，had进程优先级为2，为实时进程，migration 进程的优先级RT对应于0，为最高优先级NI: 进程的nice优先级值，该列中，实时进程的nice值为0，普通进程的nice值范围为-20~19VIRT: 进程所占虚拟内存大小（默认单位kB）RES: 进程所占物理内存大小（默认单位kB）SHR: 进程所占共享内存大小（默认单位kB）S: 进程的运行状态%CPU: 采样周期内进程所占cpu百分比(-d 3)%MEM: 采样周期内进程所占内存百分比TIME+: 进程使用的cpu时间总计COMMAND: 拉起进程的命令# 可以按照不同的指标排序显示，按对应键即可# P 按照 CPU 使用率排序# T 按照 MITE+ 排序# M 按内存使用占比排序# 按”d”可以更新top更新频率, 按空格键可以手动更新输出# 按”c”快捷键，将显示命令的全路径以及命令参数# 按”k”快捷键，可向指定进程发送信号，默认信号为SIGTERM，该信号可中止进程# 按”r”快捷键，可以修改指定进程的nice优先级 ps1234567891011121314151617181920212223242526272829303132333435363738[root@zhangbb ~]# ps -o pid,ppid,lwp,comm PID PPID LWP COMMAND 4981 4975 4981 bash 7792 4981 7792 ps 进程状态，显示进程的各种统计信息，包括内存和CPU的使用host-10-19-14-51:/data01/zjgrp/zjv8cs/sqlite&gt; ps -eLo pid,lwp,pcpu | grep 1256712567 12567 0.012567 12568 0.012567 12569 0.012567 12575 0.012567 12576 0.012567 12577 0.012567 12579 0.0linux上进程有5种状态: 1. 运行(正在运行或在运行队列中等待) 2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process [root@zhangbb ~]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.4 54384 4916 ? Ss 2018 85:05 /usr/lib/systemd/systemd --system --deserialize 22root 2 0.0 0.0 0 0 ? S 2018 0:03 [kthreadd]root 3 0.0 0.0 0 0 ? S 2018 3:55 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; 2018 0:00 [kworker/0:0H]TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?， 另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序 pstree查看进程中的线程, 一目了然123456789101151_zjdev[/data01/zjgrp/zjdev]%pstree -p 5414server(5414)-+-&#123;server&#125;(5415) |-&#123;server&#125;(5416) |-&#123;server&#125;(5417) |-&#123;server&#125;(5424) |-&#123;server&#125;(5425) |-&#123;server&#125;(5426) |-&#123;server&#125;(5427) |-&#123;server&#125;(5428) |-&#123;server&#125;(5429) `-&#123;server&#125;(5430) pmap将进程的内存和使用统计一起列出12345678910111213141516171819202122232425262728293031323334353637host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; pmap -d 6480START SIZE RSS PSS DIRTY SWAP PERM OFFSET DEVICE MAPPING0000000000400000 28K 24K 1K 0K 0K r-xp 0000000000000000 fd:00 /data01/zjgrp/zjdev/ob_rel/bin/sframe.2.3.0.8111240000000000606000 4K 4K 4K 4K 0K r--p 0000000000006000 fd:00 /data01/zjgrp/zjdev/ob_rel/bin/sframe.2.3.0.8111240000000000607000 4K 4K 4K 4K 0K rw-p 0000000000007000 fd:00 /data01/zjgrp/zjdev/ob_rel/bin/sframe.2.3.0.8111240000000000fbf000 596K 532K 532K 532K 0K rw-p 0000000000000000 00:00 [heap]0000000001054000 2420K 1980K 1980K 1980K 0K rw-p 0000000000000000 00:00 [heap]00002ac54f4c6000 132K 96K 0K 0K 0K r-xp 0000000000000000 00:23 /lib64/ld-2.19.so...00007f4300ffe000 768064K 72592K 72527K 72592K 0K r--s 0000000000000000 00:05 /SYSV0108cd2600007f432fe0e000 67528K 12K 0K 12K 0K r--s 0000000000000000 00:05 /SYSV0108ccd500007fff0738e000 136K 108K 108K 108K 0K rw-p 0000000000000000 00:00 [stack]00007fff073b6000 8K 4K 0K 0K 0K r-xp 0000000000000000 00:00 [vdso]ffffffffff600000 4K 0K 0K 0K 0K r-xp 0000000000000000 00:00 [vsyscall]Total: 24239152K 102676K 85374K 84936K 0K49996K writable-private, 1075844K readonly-private, 23113312K shared, and 98852K referenced [root@zhangbb ~]# pmap -d 16631663: /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/var/zhangbb.err --open-files-limit=65535 --pid-file=/usr/local/mysql/var/zhangbb.pid --socket=/tmp/mysql.sock --port=3306Address Kbytes Mode Offset Device Mapping0000000000400000 8852 r-x-- 0000000000000000 0fd:00001 mysqld0000000000ea5000 8 r---- 00000000008a5000 0fd:00001 mysqld0000000000ea7000 660 rw--- 00000000008a7000 0fd:00001 mysqld0000000000f4c000 160 rw--- 0000000000000000 000:00000 [ anon ]0000000001f85000 24832 rw--- 0000000000000000 000:00000 [ anon ]......00007f0bd867b000 4 rw--- 0000000000022000 0fd:00001 ld-2.17.so00007f0bd867c000 4 rw--- 0000000000000000 000:00000 [ anon ]00007ffc301f0000 132 rw--- 0000000000000000 000:00000 [ stack ]00007ffc3025b000 8 r-x-- 0000000000000000 000:00000 [ anon ]ffffffffff600000 4 r-x-- 0000000000000000 000:00000 [ anon ]mapped: 434848K writeable/private: 204948K shared: 0Kmapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vszwriteable/private 表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小 shared 表示进程和其他进程共享的内存大小 iotop进程的I/O速度123456789101112[root@zhangbb ~]# iotop -p 29215Total DISK READ : 0.00 B/s | Total DISK WRITE : 0.00 B/sActual DISK READ: 0.00 B/s | Actual DISK WRITE: 0.00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; COMMAND 29215 be/4 root 0.00 B/s 0.00 B/s ?unavailable? docker-containerd -l uni~him --runtime docker左右箭头：改变排序方式，默认是按IO排序。r：改变排序顺序。o：只显示有IO输出的进程。p：进程/线程的显示方式的切换。a：显示累积使用量。q：退出。 pidstat查看进程I/O , 内存, CPU123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# cpu使用情况统计(-u)# 使用-u选项，pidstat将显示各活动进程的cpu使用统计，执行”pidstat -u”与单独执行”pidstat”的效果一样[root@zhangbb ~]# pidstatLinux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/09/2019 _x86_64_ (1 CPU)03:11:40 PM UID PID %usr %system %guest %CPU CPU Command03:11:40 PM 0 1 0.01 0.02 0.00 0.03 0 systemd03:11:40 PM 0 2 0.00 0.00 0.00 0.00 0 kthreadd03:11:40 PM 0 3 0.00 0.00 0.00 0.00 0 ksoftirqd/003:11:40 PM 0 9 0.00 0.01 0.00 0.01 0 rcu_sched03:11:40: pidstat获取信息时间点PID: 进程pid%usr: 进程在用户态运行所占cpu时间比率%system: 进程在内核态运行所占cpu时间比率%CPU: 进程运行所占cpu时间比率CPU: 指示进程在哪个核运行Command: 拉起进程对应的命令# 内存使用情况统计(-r)[root@zhangbb ~]# pidstat -r -p 31846Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/14/2019 _x86_64_ (1 CPU)02:46:04 PM UID PID minflt/s majflt/s VSZ RSS %MEM Command02:46:04 PM 0 31846 0.00 0.00 216704 2924 0.29 osquerydminflt/s: 每秒次缺页错误次数(minor page faults)，次缺页错误次数意即虚拟内存地址映射成物理内存地址产生的page fault次数majflt/s: 每秒主缺页错误次数(major page faults)，当虚拟内存地址映射成物理内存地址时，相应的page在swap中，这样的page fault为major page fault，一般在内存使用紧张时产生VSZ: 该进程使用的虚拟内存(以kB为单位)RSS: 该进程使用的物理内存(以kB为单位)%MEM: 该进程使用内存的百分比Command: 拉起进程对应的命令# IO情况统计(-d)[root@zhangbb ~]# pidstat -d 1 2Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/14/2019 _x86_64_ (1 CPU)02:47:23 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command02:47:24 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s CommandAverage: UID PID kB_rd/s kB_wr/s kB_ccwr/s CommandkB_rd/s: 每秒进程从磁盘读取的数据量(以kB为单位)kB_wr/s: 每秒进程向磁盘写的数据量(以kB为单位)Command: 拉起进程对应的命令# 针对特定进程统计(-p)pidstat -T CHILD -C mysql // 显示所有mysql服务器的子进程pidstat -urd -h // 将所有的统计数据结合到一个便于阅读的单一报告中 fuser常用命令查询给定文件或目录的用户或进程信息123456789101112131415161718192021[root@zhangbb ~]# fuser -v /root USER PID ACCESS COMMAND/root: root 7944 ..c.. bash root 9847 ..c.. bash root 25352 ..c.. bash PID后跟的字符说明了进程以何种方式与该目录/文件关联，有以下关联方式： c 指示进程的工作目录 e 指示该文件为进程的可执行文件(即进程由该文件拉起) f 指示该文件被进程打开，默认情况下f字符不显示 F 指示该文件被进程打开进行写入，默认情况下F字符不显示 r 指示该目录为进程的根目录 m 指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存[root@zhangbb ~]# fuser -v -n tcp 3306 USER PID ACCESS COMMAND3306/tcp: mysql 1663 F.... mysqld查询socket 端口占用进程fuser -v -k mysqld关闭进程 网络工具netstat1234567891011netstat -a #列出所有端口netstat -at #列出所有tcp端口netstat -au #列出所有udp端口 netstat -l #只显示监听端口netstat -lt #只列出所有监听 tcp 端口netstat -lu #只列出所有监听 udp 端口netstat -pt #显示 PID 和进程名称netstat -n #显示IPnetstat -c #每隔一秒输出网络信息 ss1234567891011121314151617181920212223比netstat 效率高, 可以用time来比较-a, --all display all sockets-l, --listening display listening sockets-p, --processes show process using socket-s, --summary show socket usage summary-t, --tcp display only TCP sockets-u, --udp display only UDP sockets#列出来至120.33.31.1,80端口的连接ss src 120.33.31.1:httpss src 120.33.31.1:80host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ss -sTotal: 2701 (kernel 0)TCP: 2018 (estab 785, closed 1049, orphaned 0, synrecv 0, timewait 16/0), ports 0Transport Total IP IPv6* 0 - - RAW 0 0 0 UDP 1 1 0 TCP 969 831 138 INET 970 832 138 FRAG 0 0 0 iftop12345678910111213141516171819202122232425262728293031323334353637383940414243用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等 12.5Kb 25.0Kb 37.5Kb 50.0Kb 62.5Kb+---------------------+---------------------+---------------------+---------------------+---------------------45.32.49.180.vultr.com =&gt; 218.205.54.1 6.88Kb 5.00Kb 5.00Kb &lt;= 528b 424b 424b 45.32.49.180.vultr.com =&gt; 108.61.10.10.choopa.net 472b 2.36Kb 2.36Kb &lt;= 0b 2.80Kb 2.80Kbzhangbb =&gt; 2605:a000:1620:43be:bc3d:cf55:9cc5:c949 1.67Kb 856b 856b &lt;= 608b 304b 304bzhangbb =&gt; 2605:a000:1102:c230:b272:bfff:fe82:223f 0b 856b 856b &lt;= 0b 304b 304bzhangbb =&gt; 2001:b011:200b:1d2c:cdd3:eb53:ee38:be79 1.63Kb 834b 834b &lt;= 584b 292b 292bzhangbb =&gt; 2001:e68:541b:b09:ddb2:79ab:d9f2:a2fb 1.63Kb 834b 834b &lt;= 584b 292b 292b45.32.49.180.vultr.com =&gt; 212.92.105.127 640b 320b 320b &lt;= 528b 264b 264b45.32.49.180.vultr.com =&gt; 188.168.215.41 0b 308b 308b &lt;= 0b 252b 252b45.32.49.180.vultr.com =&gt; m5673.contaboserver.net 0b 306b 306b &lt;= 0b 250b 250b45.32.49.180.vultr.com =&gt; ip-187-44-249-173.static.contabo.net 0b 302b 302b &lt;= 0b 246b 246bzhangbb =&gt; 2a01:c50f:8c01:2700:8cfe:47e7:f6f3:41c 0b 202b 202b &lt;= 0b 238b 238bzhangbb =&gt; 2400:2412:8720:2800:7603:bdff:fe96:676b 424b 212b 212b &lt;= 388b 194b 194bzhangbb =&gt; 2607:5300:60:5e6e::33c:e975 424b 212b 212b &lt;= 388b 194b 194bzhangbb =&gt; 240d:1a:700:e900:211:32ff:fe69:b9be 0b 194b 194b &lt;= 0b 212b 212b--------------------------------------------------------------------------------------------------------------TX: cum: 6.56KB peak: 14.4Kb rates: 14.4Kb 13.1Kb 13.1KbRX: 3.19KB 9.05Kb 3.71Kb 6.38Kb 6.38KbTOTAL: 9.76KB 20.9Kb 18.1Kb 19.5Kb 19.5KbTX：发送流量RX：接收流量TOTAL：总流量Cumm：运行iftop到目前时间的总流量peak：流量峰值rates：分别表示过去 2s 10s 40s 的平均流量 nethogs一个小型的net top工具, 按进程或程序实时统计网络带宽使用率123456789101112131415[root@zhangbb ~]# nethogsEthernet link detected Waiting for first packet to arrive (see sourceforge.net bug 1019381)NetHogs version 0.8.5 PID USER PROGRAM DEV SENT RECEIVED 2790 root sshd: root@pts/0,pts/1 eth0 1.419 0.555 KB/sec ? root unknown TCP 0.000 0.000 KB/sec TOTAL 1.419 0.555 KB/secm : Cycle between display modes (kb/s, kb, b, mb) 切换网速显示单位r : Sort by received. 按接收流量排序s : Sort by sent. 按发送流量排序q : Quit and return to the shell prompt. 退出NetHogs命令工具 tpcdump123456789101112131415161718192021222324252627282930// 监视指定网络接口的数据包tcpdump -i eth1// 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) // 取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包tcpdump ip host 210.27.48.1 and ! 210.27.48.2// 截获主机hostname发送的所有数据tcpdump -i eth0 src host hostname// 监视所有送到主机hostname的数据包tcpdump -i eth0 dst host hostname// 监视指定主机和端口的数据包tcpdump tcp port 23 and host 210.27.48.1tcpdump udp port 123 // 监视指定协议的数据包// 打印TCP会话中的的开始和结束数据包, 并且数据包的源或目的不是本地网络上的主机.tcpdump &apos;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet&apos;......// 保存到文件用wireshark分析tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型(2)-i eth1 : 只抓经过接口eth1的包(3)-t : 不显示时间戳(4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包(5)-c 100 : 只抓取100个数据包(6)dst port ! 22 : 不抓取目标端口是22的数据包(7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24(8)-w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析 Linux tcpdump命令详解 其他命令tar使用 tar 命令只要记得参数是[必选+自选+f]:必选： -c 意为 create，表示创建压缩包 -x 意为 extract，表示解压 -t 表示查看内容 -r 给压缩包追加文件 -u 意为 update，更新压缩包中的文件 自选： -z 使用 gzip 属性 -j 使用 bz2 属性 -Z 使用 compress 属性 -v 意为 verbose，显示详细的操作过程 -O 将文件输出到标准输出 遇到不同类型的文件，请用不同的套路来应对： .tar -&gt; tar -xf .tar.gz -&gt; tar -xzf.tar.bz2 -&gt; tar -xjf .tar.Z -&gt; tar -xZf.gz -&gt; gzip -d .rar -&gt; unrar e*.zip -&gt; unzip find12345678910111213141516171819202122232425262728# 找出七天前的文件# / 表示从根目录中查找# -type f 表示找出系统普通文件，不包含目录# -mtime +n 表示寻找 n 天前的数据# -print 打印文件名称find / -type f -mtime +7 -print# 找出并删除七天前的文件find /temp/ -type f -mtime +7 -print -exec rm -f &#123;&#125; \;# -exec 表示后面执行系统命令# &#123;&#125; 只有该符号能跟在命令你后面# \; 结束符号find /temp/ -type f -mtime +7 -print | xargs rm -f# 使用管道和 xargs = -exec# 查找 /var 下最大的十个文件find /var -type f -ls | sort -k 7 -r -n | head# 查找 /var/log 下大于 5GB 的文件find /var/log/ -type f -size +5120M -exec ls -lh &#123;&#125; \;# 找出今天所有文件并将它们拷贝到另一个目录find . -ctime 0 -print -exec cp &#123;&#125; /mnt/backup/&#123;&#125; \;# 找出2天内的修改文件, 删除前询问find /var/log -type f -mtime -2 -ok rm &#123;&#125; \;#-cmin +10: 在10分钟前被修改过的 du1234#显示当前文件下 Top 10 空间占用的文件/目录，#s 表示不显示每个子目录或文件的大小#h 表示用更加自然的方式显示（比如 K/M/G 这样）du -sh * | sort -nr | head dd测试磁盘读写速度, 备份或恢复磁盘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152参数：b=512, c=1, k=1024, w=2, xm=number m 指定数字的地方若以下列字符结尾乘以相应的数字if=file 输入文件名，缺省为标准输入of=file 输出文件名，缺省为标准输出ibs=bytes 一次读入 bytes 个字节(即一个块大小为 bytes 个字节obs=bytes 一次写 bytes 个字节(即一个块大小为 bytes 个字节bs=bytes 同时设置读写块的大小为 bytes ，可代替 ibs 和 obscbs=bytes 一次转换 bytes 个字节，即转换缓冲区大小skip=blocks 从输入文件开头跳过 blocks 个块后再开始复制seek=blocks 从输出文件开头跳过 blocks 个块后再开始复制count=blocks 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数应用：// 将/dev/hdx全盘数据备份到指定路径的image文件dd if=/dev/hdx of=/path/to/image// 备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径dd if=/dev/hdx | gzip &gt;/path/to/image.gz// 拷贝内存资料到硬盘, 将内存里的数据拷贝到root目录下的mem.bin文件dd if=/dev/mem of=/root/mem.bin bs=1024// 从光盘拷贝iso镜像, 从光盘拷贝iso镜像dd if=/dev/cdrom of=/root/cd.iso// 备份文件恢复到指定盘dd if=/path/to/image of=/dev/hdxgzip -dc /path/to/image.gz | dd of=/dev/hdx// 备份MBRdd if=/dev/hdx of=/path/to/image count=1 bs=512// 将内存里的数据拷贝到root目录下的mem.bin文件dd if=/dev/mem of=/root/mem.bin bs=1024// 拷贝光盘数据到root文件夹下，并保存为cd.iso文件dd if=/dev/cdrom of=/root/cd.iso// 利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据dd if=/dev/urandom of=/dev/hda1// 得到最恰当的block sizedd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.filedd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.filedd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file// 测试硬盘读写速度dd if=/root/1Gb.file bs=64k | dd of=/dev/nulldd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000[root@zhangbb ~]# dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file1000000+0 records in1000000+0 records out1024000000 bytes (1.0 GB) copied, 4.31042 s, 238 MB/s[root@zhangbb ~]# dd if=/root/1Gb.file bs=64k | dd of=/dev/null15625+0 records in15625+0 records out1024000000 bytes (1.0 GB) copied2000000+0 records in2000000+0 records out1024000000 bytes (1.0 GB) copied, 3.08384 s, 332 MB/s, 3.08522 s, 332 MB/s lsof12345678910111213141516171819202122# 查看进程打开文件lsof -p pid[root@zhangbb ~]# lsof -p `pgrep pritunl-web`COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEpritunl-w 28661 root cwd DIR 253,1 4096 2 /pritunl-w 28661 root rtd DIR 253,1 4096 2 /pritunl-w 28661 root txt REG 253,1 13205960 46464 /usr/bin/pritunl-webpritunl-w 28661 root mem REG 253,1 2151672 4698 /usr/lib64/libc-2.17.sopritunl-w 28661 root mem REG 253,1 141968 4724 /usr/lib64/libpthread-2.17.sopritunl-w 28661 root mem REG 253,1 163400 4690 /usr/lib64/ld-2.17.sopritunl-w 28661 root 0r CHR 1,3 0t0 4856 /dev/nullpritunl-w 28661 root 1w FIFO 0,8 0t0 62148038 pipepritunl-w 28661 root 2w FIFO 0,8 0t0 62148039 pipepritunl-w 28661 root 3w REG 253,1 141 46468 /var/log/pritunl.logpritunl-w 28661 root 4u IPv6 62148054 0t0 TCP *:https (LISTEN)pritunl-w 28661 root 5u a_inode 0,9 0 4852 [eventpoll]pritunl-w 28661 root 10r FIFO 0,8 0t0 62147876 pipepritunl-w 28661 root 11r CHR 1,9 0t0 4861 /dev/urandompritunl-w 28661 root 12w CHR 1,3 0t0 4856 /dev/nullpritunl-w 28661 root 13w FIFO 0,8 0t0 62147876 pipepritunl-w 28661 root 14u sock 0,7 0t0 62147877 protocol: NETLINK curliptablesipcs用于显示进程间通信信息的命令，其可列出进程间的共享内存、消息队列、信号信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -a--------- 消息队列 -----------键 msqid 拥有者 权限 已用字节数 消息 0x0000bff0 688128 zjv8cs2 666 0 0 0x000cd141 1605633 zjdev 666 0 0 ------------ 共享内存段 --------------键 shmid 拥有者 权限 字节 连接数 状态 0x0100cd0c 55115778 zjv8cs 666 1761104 44 0x0108ccd5 55148547 zjv8cs 666 69145336 21 0x0108cd26 55181317 zjv8cs 666 786497536 21 0x0108ca0b 55214104 zjv8cs 666 786497536 21 0x0108ca30 55246915 zjv8cs 666 786497536 21 0x0108ca3c 55279684 zjv8cs 666 786497536 21 0x0108cbe2 55312453 zjv8cs 666 786497536 21 0x0108cd4a 55345222 zjv8cs 666 786497536 21 0x0108ce69 55377991 zjv8cs 666 786497536 21 0x0108cf7d 55410760 zjv8cs 666 786497536 21 0x0108d3ea 55443529 zjv8cs 666 786497536 21 0x0108d4f2 55476298 zjv8cs 666 786497536 21 0x0108d4f3 55509067 zjv8cs 666 786497536 21 0x0108d4f4 55541836 zjv8cs 666 786497536 21 0x0108d4f5 55574627 zjv8cs 666 786497536 21 0x0108d4f6 55607396 zjv8cs 666 786497536 21 0x0108d4f7 55640165 zjv8cs 666 786497536 21 0x0108d4f8 55672946 zjv8cs 666 786497536 21 0x0108d4f9 55705715 zjv8cs 666 786497536 21 0x0108d4fa 55738484 zjv8cs 666 786497536 21 0x0108d4fb 55771253 zjv8cs 666 786497536 21 0x0108d4fc 55804022 zjv8cs 666 786497536 21 0x0108d4fd 55836791 zjv8cs 666 786497536 21 0x0108d4fe 55869560 zjv8cs 666 786497536 21 0x0108d4ff 55902329 zjv8cs 666 786497536 21 0x0108d500 55935098 zjv8cs 666 786497536 21 0x0108d501 55967867 zjv8cs 666 786497536 21 0x0108d502 56000636 zjv8cs 666 786497536 21 0x0108d503 56033405 zjv8cs 666 786497536 21 0x0108d504 56066174 zjv8cs 666 786497536 21 0x0108d505 56098943 zjv8cs 666 786497536 21 0x0108d506 56131712 zjv8cs 666 786497536 21 --------- 信号量数组 -----------键 semid 拥有者 权限 nsems 0x0108cd24 3571715 zjv8cs 666 100 # 查看ipc限制# -m选项单独列出共享内存信息，-s选项单独列出信号信息，-q选项单独列出消息队列信息host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -m -l---------- 同享内存限制 ------------最大段数 = 4096最大段大小 (千字节) = 18014398509481983最大总共享内存 (千字节) = 18014398509480960最小段大小 (字节) = 1# 显示ipc信息详情host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -m -i 55115778共享内存段 shmid=55115778uid=1002 gid=1002 cuid=1002 cgid=100模式=0666 访问权限=0666字节数=1761104 lpid=7279 cpid=6369 nattch=48附加时间=Wed Jan 16 11:38:29 2019 脱离时间=Wed Jan 16 11:38:29 2019 更改时间=Wed Jan 2 10:09:05 2019 # 显示ipc创建者与拥有者详情# 显示最近访问ipc的进程pidhost-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -m -p -------- 共享内存 创建者/上次修改者 PID ----------shmid 拥有者 cpid lpid 0 zjdev 3140 3783 6979585 zjcccs 20087 3047 55115778 zjv8cs 6369 8573 55148547 zjv8cs 6367 9191 # 显示最近访问时间点host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -s -t------------ 信号量 操作/更改 时间 -------------semid 拥有者 上一操作 上次更改 3538944 zjv8cs2 Wed Jan 16 14:00:16 2019 Wed Jan 16 13:15:46 2019 524289 zjcccs Mon Nov 19 14:29:06 2018 Thu Jul 26 17:01:22 2018 393218 zjdev Tue Jan 8 16:21:57 2019 Thu Nov 15 18:00:31 2018 3571715 zjv8cs Wed Jan 16 14:00:15 2019 Wed Jan 2 10:25:00 2019 589828 zjv5cs Wed Jan 9 10:57:59 2019 Thu Jul 26 20:42:16 2018 950277 zjcccs2 Sun Jan 13 17:08:26 2019 Tue Aug 7 15:35:27 2018 2228230 zjdev Thu Oct 25 11:40:30 2018 Thu Oct 25 11:39:07 2018 2031623 zjcccs3 Wed Jan 16 12:49:44 2019 Thu Sep 27 11:25:15 2018 # 显示当前使用状态host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -u---------- 消息状态 -----------已分配队列数 = 2已用消息头(header)数 = 0已用空间 = 0 字节---------- 共享内存状态 ------------段已分配 135页已分配 31145111页驻留 5595656页交换 108302交换性能：0 次尝试 0 次成功--------- 信号量状态 -----------已使用数组 = 8已分配信号量数 = 561# 删除ipcrm用法 ipcrm -M shmkey 移除用shmkey创建的共享内存段ipcrm -m shmid 移除用shmid标识的共享内存段ipcrm -Q msgkey 移除用msqkey创建的消息队列ipcrm -q msqid 移除用msqid标识的消息队列ipcrm -S semkey 移除用semkey创建的信号ipcrm -s semid 移除用semid标识的信号 teetee命令用于将数据重定向到文件 12345678910111213141516sudo tee /etc/yum.repos.d/mongodb-org-4.0.repo &lt;&lt; EOF[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.ascEOF[root@zhangbb ~]# cat /etc/yum.repos.d/mongodb-org-4.0.repo[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc 常用技巧：123456789101112131415161718cat file1 file2 &gt;file3 #合并文件tac file #以行为单位，倒序显示head -n 100 file #显示file的前100行head -n -100 file #显示file的除最后100行以外的内容。 tail -100 file #显示file最后100行内容tail -n +100 file #从第100行开始显示file内容 sed -n &apos;1,100p&apos; file &gt; file2 #截取file中1到100行到file2sed -n &quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&quot; file #显示包含&quot;&amp;&amp;&amp;&amp;&amp;&quot;行sort/uniq #文本排序date +%s #将当前时间转成Unix时间戳date -d &apos;2013-2-22 22:14&apos; +%s #指定日期转成Unix时间戳date -d @1361542596 +&quot;%Y-%m-%d %H:%M:%S&quot; #指定格式输出date +&quot;%s&quot; # 显示当前时间的Unix时间戳grep &apos;aaa\|bbb&apos; file #查询&amp;&amp;&amp;或$$$grep -v &apos;root&apos; file #查询不包含root的行ps -ef | grep gmake | grep –v root | awk &apos;&#123;print $2&#125;&apos; | xargs kill -9 # 杀进程echo &quot;password&quot; | passwd testuser --stdin # linux用shell修改密码cut -d &quot; &quot; -f 2,3 1.txt # 用空格分隔, 显示第二、三个字段列 其他awkps/pmap/top等工具源码]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker实践]]></title>
    <url>%2F2018%2F10%2F24%2FDocker%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Docker 简介Docker 是什么 Docker 最初是dotCloud公司的一个内部项目 Docker 使用go语言开发实现 Docker 是操作系统层面的虚拟化技术 Docker 是在操作系统层面进行虚拟化, 直接复用本地主机操作系统; 而传统方式是在硬件层面实现。 为什么用 Docker优势 1更高效的利用系统资源(额外系统消耗忽略不计) 2更快速的启动时间(秒级启动, 比传统虚拟机快) 3一致的运行环境(开发、测试、生产环境一样) 4持续交付和部署(Docker构建镜像, 快速部署) 5更轻松的迁移(平台迁移方便) 6更轻松的维护和扩展(分层存储以及镜像技术, 复用和维护简单) 容器基本不消化额外的系统资源, 秒级启动, 性能很高. 启动十个进程, 需要启动10台虚拟机, 但Docker只需要启动十个隔离的应用即可。 基本概念 镜像(Image) 一个特殊的文件系统, 包含程序,库,配置文件 利用Union FS技术分层存储, 由多层文件系统联合组成, Dockerfile会一层层的构建 容器(Container) 容器是从镜像运行时的实例, 会在镜像基础上创建一个存储层用于读写, 生命周期和容器一样 可以启、停止、删除、暂停等。容器内的进程是隔离的, 容器有自己的网络,文件系统, 进程空间, 用户空间 仓库(Registy) 存放镜像的场所, 可以是公有仓库或者私有仓库 官方Docker Hub , 用阿里云加速, DaoCloud 等加速器下载更快 安装将Docker的用户加入到Docker用户组 $ groupadd docker$ usermod -aG docker $USER 使用镜像1 获取镜像 docker pull 2 列出镜像123456789101112131415161718192021222324252627billing-csv-jfzx08%docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE20.26.38.47:5000/redo_java v27 90afb9850803 2 hours ago 2.85GB20.26.38.47:5000/suse12.2-jf 1.8.6 3c7f01d195d9 3 hours ago 9.14GB20.26.38.47:5000/suse12.2-zc 1.7.6 b9afcd1d062b 4 hours ago 12.3GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 18a1b4e851ba 6 hours ago 9.14GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; c9ff12f7c392 6 hours ago 9.13GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 86973ecd7035 7 hours ago 9.13GB20.26.38.47:5000/suse12.2-zc &lt;none&gt; a6a565cc7cd5 2 days ago 12.3GB20.26.38.47:5000/redo_java v26 71f5c0a56a15 3 days ago 2.85GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 87bed11aa735 3 days ago 9.11GB20.26.38.47:5000/dse-suse-12.2 latest 9930a53d9861 3 days ago 4.9GB20.26.38.47:5000/suse12.2-inputxdr test5 17c4f034235b 4 days ago 3.45GB20.26.38.47:5000/inputxdr v69.17 3ea2e49542c6 4 days ago 1.65GB20.26.38.47:5000/suse12.2-decode 1.7.6 791cb433e4d0 5 days ago 5.5GB20.26.38.47:5000/suse12.2-xc 1.3.6 5e0f0814a1b4 5 days ago 5.29GB20.26.38.47:5000/suse12.2-csf 2.1 2542b7237ccb 6 days ago 3.57GB20.26.38.47:5000/suse12.2-zc 1.7.4 1ab625d2ea97 7 days ago 10.7GB20.26.38.47:5000/dse-suse-12.2 &lt;none&gt; b293ed18bbef 11 days ago 4.74GB20.26.38.47:5000/suse12.2-decode 1.7.4 b867b33eca4e 13 days ago 5.36GB20.26.38.47:5000/suse12.2-xc 1.3.4 5f7c56b09631 13 days ago 5.15GB20.26.38.47:5000/suse12.2-jf 1.8.4 c60a266497d9 13 days ago 7.66GB20.26.38.47:5000/dse-suse-12.2 &lt;none&gt; 67e18d4bf990 2 weeks ago 4.89GB20.26.28.55/acam/tomcat 8.5.29-jre8-alpine d6c75482e065 8 months ago 106MB20.26.28.55/acam/tomcat v1 d6c75482e065 8 months ago 106MB20.26.28.55/platformv8/tomcat 8.5.29-jre8-alpine d6c75482e065 8 months ago 106MBregistry.yw.zj.chinamobile.com/dcos/df-client 1.9 8f7837553678 10 months ago 276MB 包含了仓库, 标签, 镜像ID, 创建时间, 占用空间 镜像体积：上面命令显示的是展开后各层总和, 实际硬盘占用会小很多 123456billing-csv-jfzx08%docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 23 16 30.06GB 25.58GB (85%)Containers 132 25 10.66MB 1.174MB (11%)Local Volumes 0 0 0B 0BBuild Cache 0B 0B 虚悬镜像： 旧版本被覆盖， docker image prune 删除 中间层镜像：docker image ls -a 列出部分或指定镜像:1234567891011121314151617billing-csv-jfzx08%docker image ls 20.26.38.47:5000/suse12.2-jf:1.8.4REPOSITORY TAG IMAGE ID CREATED SIZE20.26.38.47:5000/suse12.2-jf 1.8.4 c60a266497d9 13 days ago 7.66GBbilling-csv-jfzx08%docker image ls -f since=20.26.38.47:5000/redo_java:v26REPOSITORY TAG IMAGE ID CREATED SIZE20.26.38.47:5000/redo_java v27 90afb9850803 4 hours ago 2.85GB20.26.38.47:5000/suse12.2-jf 1.8.6 3c7f01d195d9 5 hours ago 9.14GB20.26.38.47:5000/suse12.2-zc 1.7.6 b9afcd1d062b 6 hours ago 12.3GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 18a1b4e851ba 7 hours ago 9.14GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; c9ff12f7c392 8 hours ago 9.13GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 86973ecd7035 9 hours ago 9.13GB20.26.38.47:5000/suse12.2-zc &lt;none&gt; a6a565cc7cd5 2 days ago 12.3GB// 某个镜像之前的镜像, since 改成beforedocker imgae ls -qdocker image ls --format &quot;&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Respository&#125;&#125;&quot; 3 删除本地镜像docker image rm $(docker image ls -q -f since=20.26.38.47:5000/redo_java:v26)docker ls –digests Dockerfile 实现原理 操作容器访问仓库数据管理网络]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式服务框架原理和实践]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库事务及锁]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81%2F</url>
    <content type="text"><![CDATA[事务的四个特性 原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability) 原子性一个事务中的全部操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会回滚到事务开始前的状态，不会对数据库有任何影响。 一致性在事务开始之前和事务结束以后，数据库的完整性没有被破坏。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性数据库允许多个并发事务对数据进行读写和修改，防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交(Read uncommitted)、读提交(read committed)、可重复读(repeatable read)和串行化（Serializable）。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务隔离级别如果不考虑事务的隔离性，会发生的几种问题: 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。(读未提交) 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 虚读(幻读)幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户, 如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体(比如数据的个数)。 串行化(Serializable)在串行化隔离模式下，消除了脏读，幻象，但事务并发度急剧下降，事务的隔离级别与事务的并发度成反比，隔离级别越高，事务的并发度越低。实际生产环境下，dba会在并发和满足业务需求之间作权衡，选择合适的隔离级别 MySQL数据库为我们提供的四种隔离级别： 1）Read uncommitted (读未提交)：最低级别，任何情况都无法保证 2）Read committed (读已提交)：可避免脏读的发生 3）Repeatable read (可重复读)：可避免脏读、不可重复读的发生 4）Serializable (串行化)：可避免脏读、不可重复读、幻读的发生 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别 事务隔离的实现——锁 共享锁(S锁) [] 用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。 更新锁(U锁) [] 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。 独占锁(X锁，也叫排他锁) [] 一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。 Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。 Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。 Serializable 读加共享锁，写加排他锁，读写互斥。 三级封锁协议mvcc多版本并发控制协议间隙锁]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>ACID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux知识体系]]></title>
    <url>%2F2018%2F10%2F19%2Flinux%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++知识体系]]></title>
    <url>%2F2018%2F10%2F19%2Fc-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gdb多线程调试]]></title>
    <url>%2F2018%2F10%2F15%2Fgdb%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95-1%2F</url>
    <content type="text"><![CDATA[all-stop mode: 默认模式, 有一个线程在断点处停止，其他所有线程也会停止 non-stop mode: 某一个线程停止时，其他线程会继续运行 Background Execution：异步运行程序 Thread-Specific Breakpoints: 控制断点 Interrupted System Calls: gdb会干扰系统调用 Observer Mode：gdb不影响程序执行 all-stop mode当进程在gdb下停止时，所有的线程都停止运行。当用单步调试命令“step或next”，所有的线程开始执行。由于执行线程调度的是操作系统不是gdb，单步调试命令不能让所有的线程都单步。当前线程执行了一步，其他线程可能执行了N步。当执行next/step/continue时，当前线程完成单步运行前，其他线程运行遇到断点/信号/异常，gdb会选择一个遇到短信或信号中断的线程，切换线程时会提示“[Switching to Thread n]” set scheduler-locking设置调度锁定模式，在一些系统中，gdb可以通过锁定操作系统线程调度，只允许一个线程运行。如果是on,单步调试命令会阻止其他线程抢占, 其他线程不会运行。如果是off，所有线程线程都会运行。当执行continue/util/finish 时，其他进程会恢复运行. show scheduler-locking显示当前线程调度锁定状态 set schedule-multiple当执行continue/next/step时，gdb只允许当前进程下的线程恢复运行(fork出过个进程)。on: 所有进程下的线程恢复运行off: 当前进程下的线程恢复运行 show schedule-multiple显示多进程恢复模式 non-stop mode在一些多线程的应用中，gdb支持只停止需要调试的线程，其他线程可运行不受影响。例如某些线程具有实时约束或必须继续响应外部事件，这是最小化的实时调试。称为不间断模式。在non-stop mode中，当一个线程因为断点停止时，其他线程正常运行，continue/step 只适用于当前线程。一般情况下在gdb启动或attach 一个进程时设置non-stop mode, 顺序执行如下命令，进入non-stop mode: Enable the async interface. set target-async 1 If using the CLI, pagination breaks non-stop. set pagination off Finally, turn it on! set non-stop on continue -a, 让所有线程都继续执行, continue 只能让当前线程继续执行interrupt -a, 停止整个程序, interrupt/Ctrl-c 只能让当前线程挂起, 其他命令不支持-a. Background Execution基本上用不到 Thread-Specific Breakpointsbreak linespec thread threadnobreak linespec thread threadno if ..threadno 从 info threads 中得到.比如(gdb) break frik.c:13 thread 28 if bartab &gt; lim [ ] Interrupted System Calls在使用gdb调试多线程程序时，有一个副作用。如果一个线程因断点或其他原因而停止，而另一个线程在系统调用中被阻塞，那么系统调用可能会提前返回。这是多线程和gdb用来实现断点和其他停止执行的事件的信号之间交互的结果。例如： sleep (10); 如果不同的线程在断点处或出于其他原因停止，则调用sleep将提前返回。 int unslept = 10; while (unslept &gt; 0) unslept = sleep (unslept); 允许系统调用提前返回，因此系统仍然符合其规范。但是gdb确实会导致多线程程序的行为与没有gdb时不同。另外，gdb在线程库中使用内部断点来监视某些事件，例如线程创建和线程销毁。当这样的事件发生时，另一个线程中的系统调用可能会提前返回，即使您的程序似乎没有停止. Observer Mode略 gdb sframe // 设置non-stop 模式 set target-async 1 set pagination off set non-stop on // 设置断点 b ratms_base_rating.cpp:909 //insert b ratms_base_sync.cpp:169 //truncate // 启动 r -i xxxxx.xml // 发送请求 ctrl+c info threads thread apply n continue thread apply n continue]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
</search>
