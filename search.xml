<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高性能Linux服务器构建实战 笔记]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%AB%98%E6%80%A7%E8%83%BDLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CPU profiler]]></title>
    <url>%2F2019%2F03%2F21%2FCPU-profiler%2F</url>
    <content type="text"><![CDATA[ʹ��CPU profiler��������: ������, ���д���, ���������CPU profiler�������ļ��е�����˵���ĵ�… ������ ����ʱ���� -lprofiler ����ȫ�ֻ�������, setenv LD_PRELOAD /usr/lib/libprofiler.so(���Ƽ�, �û�����û������) �������ַ�ʽ��û�д�CPU profiler,����ֻ���ڴ����в������ӷ���. 1g++ test.cpp -o test -lprofiler ���д��������ַ�ʽ���Դ�CPU profiler: ����CPUPROFILE��������, ����setenv CPUPROFILE ~/data/prof/decode.prof ����CPUPROFILESIGNAL, ����δʹ�õ��źſ������ 123456setenv CPUPROFILE ~/data/prof/test.profsetenv CPUPROFILESIGNAL 60// ��ʼkill -60 pid// ֹͣkill -60 pid include ͷ�ļ�&lt;gperftools/profiler.h&gt;, ʹ��ProfilerStart(char* filename) �� ProfilerStop()����ProfilerFlush() and ProfilerStartWithOptions() ���ڰ�ȫ����, CPU��������д���ļ���, ����Ӧ����setuid���� �������� name desc CPUPROFILE_FREQUENCY Ĭ��100samples/second, �൱��һ������10ms CPUPROFILE_REALTIME Ĭ�ϲ�����, ֻҪ������(��ʹ��0���), ��ITIMER_REAL���� ITIMER_PROF, һ�㲻���� �������pprof�����ڷ���profile�Ľű����ж������ģʽ, ������gcc -pg �����(gprof)��pprof����dot/gv�� 123456789101112131415161718192021pprof &lt;format&gt; [options] [binary] &lt;source&gt;% pprof /bin/ls ls.prof Enters &quot;interactive&quot; mode% pprof --text /bin/ls ls.prof Outputs one line per procedure% pprof --gv /bin/ls ls.prof Displays annotated call-graph via &apos;gv&apos;% pprof --gv --focus=Mutex /bin/ls ls.prof Restricts to code paths including a .*Mutex.* entry% pprof --gv --focus=Mutex --ignore=string /bin/ls ls.prof Code paths including Mutex but not string% pprof --list=getdir /bin/ls ls.prof (Per-line) annotated source listing for getdir()% pprof --disasm=getdir /bin/ls ls.prof (Per-PC) annotated disassembly for getdir()% pprof --text localhost:1234 Outputs one line per procedure for localhost:1234% pprof --callgrind /bin/ls ls.prof Outputs the call information in callgrind format ����text���12eg. 14 2.1% 17.2% 58 8.7% std::_Rb_tree::find value desc 14 samples 2.1% ����samples�ı��� 17.2% ���ú���Ϊֹ, �Ѿ����еĺ���ռ��samples�ı��� 58 �������Ϻ����ﱻ�����ߵ���samples 8.7% �������Ϻ����ﱻ�����ߵ���samples ����samples���� std::_Rb_tree::find ������ ����Callgrind���12% pprof --callgrind /bin/ls ls.prof &gt; ls.callgrind% kcachegrind ls.callgrind ##]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7 gv 安装]]></title>
    <url>%2F2019%2F03%2F21%2Fcentos7-gv-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[gv下载123456789101112131415161718192021222324252627282930313233[root@localhost download]# rpm -ivh gv-3.7.4-8.sdl7.x86_64.rpmwarning: gv-3.7.4-8.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYerror: Failed dependencies: /usr/bin/update-desktop-database is needed by gv-3.7.4-8.sdl7.x86_64 libXaw3d.so.8()(64bit) is needed by gv-3.7.4-8.sdl7.x86_64[root@localhost download]# yum install desktop-file-utils......[root@localhost download]# rpm -ivh gv-3.7.4-8.sdl7.x86_64.rpmwarning: gv-3.7.4-8.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYerror: Failed dependencies: libXaw3d.so.8()(64bit) is needed by gv-3.7.4-8.sdl7.x86_64 [root@localhost download]# rpm -ivh Xaw3d-1.6.2-4.sdl7.x86_64.rpmwarning: Xaw3d-1.6.2-4.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYPreparing... ################################# [100%]Updating / installing... 1:Xaw3d-1.6.2-4.sdl7 ################################# [100%][root@localhost download]# rpm -ivh gv-3.7.4-8.sdl7.x86_64.rpmwarning: gv-3.7.4-8.sdl7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 41a40948: NOKEYPreparing... ################################# [100%]Updating / installing... 1:gv-3.7.4-8.sdl7 ################################# [100%][root@localhost download]# gvgv: Unable to open the display.[root@localhost download]# gv -hUsage: gv [OPTION]... [FILE]PostScript and PDF viewer....]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高性能MySQL 读书笔记]]></title>
    <url>%2F2019%2F03%2F18%2F%E9%AB%98%E6%80%A7%E8%83%BDMySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TODO]]></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解http 读书笔记]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%9B%BE%E8%A7%A3http-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TODO]]></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bloom Filter概念和原理]]></title>
    <url>%2F2019%2F03%2F18%2FBloom-Filter%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概念和原理布隆过滤器应用场景–查重]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法之美之线性表 笔记]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数组数组Array是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 数组支持随机访问, 通过下标访问的时间复杂度为0(1)。一般用vector容器来替代 为什么下标从0开始, 地址偏移计算 链表单链表 , 双向链表 , 循环链表 字符串回文判断思路: 找到中间节点 后半部分逆序 比较 后半部分恢复 如何轻松正确写出链表 重点留意边界处理 利用哨兵简化实现难度 举例画图, 辅助思考 多写多练, 没有捷径 单链表反转链表中环的检测两个有序的链表合并删除链表倒数第 n 个结点求链表的中间结点 栈用数组实现的栈, 顺序栈; 用链表实现的栈, 链式栈; 操作受限的线性表数据结构 支持动态扩容顺序栈入栈时间复杂度O(1), 有扩容时为O(n) 栈在函数调用中的应用 栈在表达式求值中的应用 栈在括号匹配中的应用 队列先进者先出，这就是典型的“队列”(排队); 操作受限的线性表数据结构用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列 基于链表的队列实现方法 循环队列确定好队空和队满的判定条件, 队空(head == tail), 队满(tail+1)%n=head 阻塞队列和并发队列队列空取数据 或 队列满插入数据 会阻塞; 并发时需要加锁控制轻松实现生产者-消费者模型]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法之美 笔记]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为什么学数据结构和算法 面试大厂, 不让数据结构和算法拖后腿 提高看待问题的深度, 解决问题的角度, 对编程还有追求 如何抓住重点, 系统高效的学习数据结构是为算法服务的，算法要作用在特定的数据结构之上。 首先要掌握复杂度分析 学习套路 来历 -&gt; 原理 -&gt; 解决问题 -&gt; 应用场景 20个最常用的数据结构和算法 建议 边学边练, 适度刷题多问, 多思考反复迭代, 不断沉淀 复杂度分析为什么需要复杂度分析, 而不是通过跑一遍程序统计、监控得到运行时间,内存消耗结果？ 测试结果非常依赖环境(不同环境下结果不同) 测试结果受数据规模影响大 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势, 叫渐近时间复杂度, 简称时间复杂度 分析方法 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 常见案例分析常量阶O(1)123int i = 8;int j = 6;int sum = i + j; 对数阶O(logn) , 线性对数阶O(nlogn)123456 i=1; while (i &lt;= n) &#123; i = i * 2; &#125; // 再执行n遍, 就是O(nlogn) 线性阶O(n) , 平方阶O(n^2), 指数阶O(2^n) 最好情况时间复杂度, 最坏情况时间复杂度, 平均情况时间复杂度, 均摊时间复杂度 均摊时间复杂度就是一种特殊的平均时间复杂度，我们没必要花太多精力去区分它们]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化之网络 笔记]]></title>
    <url>%2F2019%2F03%2F05%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux网络网络模型 OSI七层 功能 协议 应用层 负责为程序提供统一的接口 ftp telnet http dns 表示层 负责把数据转换成兼容接收系统的格式 NULL 会话层 负责维护计算机之间的通信连接 NULL 传输层 负责为数据加上传输表头, 形成数据包 TCP UDP 网路层 负责数据的路由和转发 IP ICMP IGMP RIP 数据链路层 负责MAC寻址, 错误侦测和改错 ARP RARP MTU PPP 物理层 负责在物理网络中传输数据帧 IEEE802 TCP/IP四层 功能 应用层 负责向用户提供一组应用程序, 比如HTTP/DNS/FTP 传输层 负责端到端的通信, 比如TCP/UDP 网络层 负责网络包的封装、寻址和路哟, 比如IP/ICMP 网络接口层 负责在物理网络中传输数据帧, 比如MAC寻址, 错误侦测和改错 tcp/udp/ip头协议格式, 一个tcp数据包协议头最长60个字节 OSI和TCP/IP关系 linux网络栈 Linux 通用 IP 网络栈的示意图 性能指标 带宽 表示链路的最大传输,单位为b/s(比特/秒) 吞吐量 单位时间内成功传输的数据量b/s(比特/秒)或B/s(字节/秒), 网络使用率=吞吐量/带宽 延时 网络请求发出后, 收到远端回复包的延迟 PPS packet per second(包/秒), 以网络包为单位的传输速率, 通常用来评估网络转发能力如硬件交换机 另外还有网络的可用性, 并发连接数, 丢包率, 重传率等指标 网络配置123456789101112131415161718192021[root@localhost ~]# ifconfig enp0s3enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.137.20 netmask 255.0.0.0 broadcast 192.255.255.255 inet6 fe80::a00:27ff:fe41:f483 prefixlen 64 scopeid 0x20&lt;link&gt; ether 08:00:27:41:f4:83 txqueuelen 1000 (Ethernet) RX packets 1190 bytes 124844 (121.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1004 bytes 123892 (120.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [root@localhost ~]# ip -s addr show dev enp0s32: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 08:00:27:41:f4:83 brd ff:ff:ff:ff:ff:ff inet 192.168.137.20/8 brd 192.255.255.255 scope global enp0s3 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:fe41:f483/64 scope link valid_lft forever preferred_lft forever RX: bytes packets errors dropped overrun mcast 137456 1311 0 0 0 0 TX: bytes packets errors dropped carrier collsns 134854 1070 0 0 0 0 ifconfig中的RUNNING 和 ip中的LOWER_UP 表示网络物理层是连通的, 即网线插好了 MTU 的大小 网络收发字节数、包数、错误数及丢包情况。详细指标如下 errors 发生错误的数据包数, 比如校验错误, 帧同步错误等 dropped 丢弃的数据包, 数据包已经收到了Ring Buffer, 但内存资源不足原因丢包 overrun 超限数据包数, 网络I/O速度过快, 导致Ring Buffer来不及处理(队列满) carrier 发送carrier错误的数据包数, 比如双工模式不匹配, 物理电缆线出问题等 collsns 碰撞数据包数 套接字信息1234567891011121314151617# head -n 3 表示只显示前面 3 行# -l 表示只显示监听套接字# -n 表示显示数字地址和端口 (而不是名字)# -p 表示显示进程信息$ netstat -nlp | head -n 3Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN 840/systemd-resolve# -l 表示只显示监听套接字# -t 表示只显示 TCP 套接字# -n 表示显示数字地址和端口 (而不是名字)# -p 表示显示进程信息$ ss -ltnp | head -n 3State Recv-Q Send-Q Local Address:Port Peer Address:PortLISTEN 0 128 127.0.0.53%lo:53 0.0.0.0:* users:((&quot;systemd-resolve&quot;,pid=840,fd=13))LISTEN 0 128 0.0.0.0:22 0.0.0.0:* users:((&quot;sshd&quot;,pid=1459,fd=3)) QUEUE LISTEN ESTABLISHED Recv-Q (sync backlog当前值, 当前使用了多少)表示Accept queue中等待被服务器accept() 套接字缓冲区中没有被应用收取的字节数(接受队列长度) Send-Q (sync backlog最大值, 全连接队列长度)即为Accept queue的最大值 还没有被远端主机确认的字节数(发送队列长度) 全连接的大小取决于min(backlog, somaxconn), backlog在创建socket时传入, somaxconn是系统参数半连接的大小取决于max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog), 不同版本会有差异 协议栈信息1234567891011121314151617181920212223242526[root@localhost ~]# netstat -s...Tcp: 0 active connections openings 1 passive connection openings 0 failed connection attempts 0 connection resets received 1 connections established 430 segments received 266 segments send out 0 segments retransmited 0 bad segments received. 0 resets sent... [root@localhost ~]# ss -sTotal: 187 (kernel 204)TCP: 6 (estab 1, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 0Transport Total IP IPv6* 204 - - RAW 0 0 0 UDP 5 3 2 TCP 6 4 2 INET 11 7 4 FRAG 0 0 0 网络吞吐和PPS1234567891011121314151617// 1 表示每隔1秒输出一组数据[root@localhost ~]# sar -n DEV 1Linux 3.10.0-693.el7.x86_64 (localhost.localdomain) 03/05/2019 _x86_64_ (1 CPU)10:06:56 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s10:06:57 PM enp0s3 1.00 1.00 0.06 0.22 0.00 0.00 0.0010:06:57 PM enp0s8 0.00 0.00 0.00 0.00 0.00 0.00 0.0010:06:57 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0010:06:57 PM docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00// rxpck/s 和 txpck/s 分别是接收和发送PPS, 单位为包/秒// rxkB/s 和 txkB/s 分别是接收和发送吞吐量, 单位是KB/秒// rxcmp/s 和 txcmp/s 分别是接收和发送的压缩包数据, 单位是包/秒// %ifutil 网络接口使用率, max(rxkB/s, txkB/s)/Bandwidth// 查看带宽, 如下为千兆网卡[root@localhost ~]# ethtool enp0s8 |grep Speed Speed: 1000Mb/s 连通性和延时1234567891011121314[root@localhost ~]# ping www.baidu.comPING www.a.shifen.com (183.232.231.172) 56(84) bytes of data.64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=1 ttl=49 time=27.1 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=2 ttl=49 time=28.2 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=3 ttl=49 time=28.3 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=4 ttl=49 time=27.6 ms64 bytes from 183.232.231.172 (183.232.231.172): icmp_seq=5 ttl=49 time=27.6 ms^C--- www.a.shifen.com ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 22064msrtt min/avg/max/mdev = 27.184/27.833/28.343/0.440 ms// 第一部分是每个ICMP请求信息, 序列号, TTL(生存时间), 以及往返延时// 第二部分是总的统计 C10K 和 C1000K单机处理1W个并发连接请求 I/O模型优化I/O多路复用时, 两种事件通知方式 水平触发 只要文件描述符可以非阻塞的执行I/O, 就会触发通知。应用程序可以随时检查fd的状态,然后根据状态进行I/O操作。 边缘触发 只有在文件描述符状态发生改变时(I/O请求到达), 才会发生一次通知。此时需要应用尽可能多的执行I/O读写, 不及时处理通知就丢失了。 使用非阻塞I/O和水平触发通知(select/poll)都需要对fds进行轮询; 在32位系统中, select描述符最多1024个; 并且, 在select内部检查套接字状态是用轮询, 再加上应用的轮询, 时间复杂度O(n^2). poll对select改进, 使用固定长度的数组, 没有了最大描述符数量的限制; 应用程序还是需要轮询, 处理耗时跟描述符的数量就是O(n)关系. 另外应用程序调用select/poll, 需要把文件描述符集合从用户空间传入内核空间, 由内核空间修改后, 再传出到用户空间, 来回切换处理成本高. 使用非阻塞I/O和边缘触发通知(epoll) epoll使用红黑树在内核管理描述符集合, 应用程序在每次操作时不需要传入传出这个集合 epoll使用时间驱动机制, 只关注事件发生的描述符(就绪链表), 不需要轮询整个集合 使用异步I/O没有经验 工作模型优化 主进程 + 多个worker子进程 监听到相同端口多进程方式(开启SO_REUSEPORT), 只会有1个进程被唤醒 C10M跳过冗长的协议栈处理, 直接把网络包送到应用程序.有如下两种机制 DPDK 用户态网络标准, 跳过内核协议栈, 直接由用户态程序通过轮询来处理网络接收 XDP 允许网络包在进入内核前就进行处理(丢弃,转发,给上层应用) 评估系统网络性能各个协议层的基本测试 转发性能pktgen TCP/UDP性能1234567891011121314151617[root@localhost ~]# yum install -y iperf3# -s 表示启动服务端，-i 表示汇报间隔，-p 表示监听端口[root@localhost ~]# iperf3 -s -i 1 -p 10000# -c 表示启动客户端，192.168.0.30 为目标服务器的 IP# -b 表示目标带宽 (单位是 bits/s)# -t 表示测试时间# -P 表示并发数，-p 表示目标服务器监听端口[root@localhost ~]# iperf3 -c 127.0.0.1 -b 1G -t 15 -P 2 -p 10000[ ID] Interval Transfer Bandwidth Retr[ 4] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec 0 sender[ 4] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec receiver[ 6] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec 0 sender[ 6] 0.00-15.00 sec 1.74 GBytes 995 Mbits/sec receiver[SUM] 0.00-15.00 sec 3.48 GBytes 1.99 Gbits/sec 0 sender[SUM] 0.00-15.00 sec 3.48 GBytes 1.99 Gbits/sec receiver 从测试结果看带宽(吞吐量)超出预期1Gb/s HTTP性能ab 应用负载性能wk 总结 应用层 用wrk,Jmeter 传输层 iperf/netperf 再向下 pktgen DNS解析时快时慢域名与DNS解析DNS服务通过资源记录的方式, 管理数据 A记录 用来把域名转换成IP地址 CNAME记录 用来创建别名 NS记录 表示该域名对应的域名服务器地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@localhost ~]# cat /etc/resolv.conf; generated by /usr/sbin/dhclient-scriptnameserver 10.70.75.253[root@localhost ~]# yum install -y bind-utils[root@localhost ~]# nslookup time.geekbang.orgServer: 10.70.75.253Address: 10.70.75.253#53Non-authoritative answer:Name: time.geekbang.orgAddress: 39.106.233.176[root@localhost ~]# dig +trace +nodnssec time.geekbang.org; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-73.el7_6 &lt;&lt;&gt;&gt; +trace +nodnssec time.geekbang.org;; global options: +cmd. 518400 IN NS m.root-servers.net.. 518400 IN NS c.root-servers.net.. 518400 IN NS i.root-servers.net.. 518400 IN NS d.root-servers.net.. 518400 IN NS j.root-servers.net.. 518400 IN NS e.root-servers.net.. 518400 IN NS l.root-servers.net.. 518400 IN NS g.root-servers.net.. 518400 IN NS h.root-servers.net.. 518400 IN NS f.root-servers.net.. 518400 IN NS k.root-servers.net.. 518400 IN NS b.root-servers.net.. 518400 IN NS a.root-servers.net.;; Received 239 bytes from 10.70.75.253#53(10.70.75.253) in 46 msorg. 172800 IN NS a0.org.afilias-nst.info.org. 172800 IN NS a2.org.afilias-nst.info.org. 172800 IN NS b0.org.afilias-nst.org.org. 172800 IN NS b2.org.afilias-nst.org.org. 172800 IN NS c0.org.afilias-nst.info.org. 172800 IN NS d0.org.afilias-nst.org.;; Received 448 bytes from 199.7.91.13#53(d.root-servers.net) in 426 msgeekbang.org. 86400 IN NS dns10.hichina.com.geekbang.org. 86400 IN NS dns9.hichina.com.;; Received 96 bytes from 199.19.56.1#53(a0.org.afilias-nst.info) in 106 mstime.geekbang.org. 600 IN A 39.106.233.176;; Received 62 bytes from 106.11.211.56#53(dns10.hichina.com) in 40 ms 可以把主机名和IP地址对应关系, 写入到本机/ect/hosts中, 指定的主机名可以直接找到IP123456789101112[root@localhost ~]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6[root@localhost ~]# ping localhost4PING localhost (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.041 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.066 ms^C--- localhost ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 999msrtt min/avg/max/mdev = 0.041/0.053/0.066/0.014 ms 案例 DNS 未配置在/etc/resolve.conf 导致找到域名服务器 1234可以ping通IP, ping域名失败# nslookup -debug time.geekbang.org;; Connection to 127.0.0.1#53(127.0.0.1) for time.geekbang.org failed: connection refused.;; Connection to ::1#53(::1) for time.geekbang.org failed: address not available. DNS不稳定 12345678910111213# time nslookup time.geekbang.org;; connection timed out; no servers could be reached real 0m15.011suser 0m0.006ssys 0m0.006s$ ping -c3 8.8.8.8PING 8.8.8.8 (8.8.8.8): 56 data bytes64 bytes from 8.8.8.8: icmp_seq=0 ttl=30 time=134.032 ms64 bytes from 8.8.8.8: icmp_seq=1 ttl=30 time=431.458 ms延时太大导致 小结DNS优化方法 对DNS结果进行缓存 对DNS解析的结果进行预取 使用HTTPDNS代替常规的DNS解析, 避免域名劫持 基于DNS的全局负载均衡(GSLB), 根据用户位置返回距离最近的IP tcpdump和wireshark 分析网络流量略过 如何缓解DDos攻击带来的性能下降DDoS 的前身是 DoS（Denail of Service），即拒绝服务攻击，指利用大量的合理请求，来占用过多的目标资源，从而使目标服务无法响应正常请求。DDoS（Distributed Denial of Service） 则是在 DoS 的基础上，采用了分布式架构，利用多台主机同时攻击目标主机。 攻击原理 耗尽带宽 耗尽操作系统的资源 消耗应用程序的运行资源 案例模拟 优化 iptables 限制 修改半连接数量限制 开启 TCP SYN Cookies, 基于连接信息（包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie 小结在 Linux 服务器中，你可以通过内核调优、DPDK、XDP 等多种方法，来增大服务器的抗攻击能力，降低 DDoS 对正常服务的影响。而在应用程序中，你可以利用各级缓存、 WAF、CDN 等方式，缓解 DDoS 对应用程序的影响。 网络延迟变大]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统 笔记]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化之磁盘文件 笔记]]></title>
    <url>%2F2019%2F02%2F28%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文件系统 磁盘为系统提供了最基本的持久化存储文件系统则在磁盘的基础上, 提供了一个用来管理文件的树状结构 索引节点和目录 索引节点(inode), 用来记录文件的元数据, 比如inode编号, 文件大小, 访问权限修改日期, 数据位置等。它和文件一一对应, 跟文件内容一样, 会被持久化到磁盘, 也会占磁盘空间 目录项(dentry), 用来记录文件名字, 索引节点指针以及和其他目录项的关系。多个关联目录项构成文件系统的目录结构, 由内存维护的内存数据结构, 也叫目录缓存 磁盘格式化时被分为三个区 超级块, 存储整个文件系统的状态 索引节点区, 存储inode 数据存储区, 存储文件数据 虚拟文件系统linux系统文件系统四大基本要素, 目录项/索引节点/超级块/数据块区为支持不同文件系统, linux内核在用户进程和文件系统之间, 抽象出了一层虚拟文件系统(VFS)。VFS定义了一组所有文件系统都支持的数据结构和标准接口。 文件系统I/OVFS提供了一组文件访问接口。文件读写I/O的四种方式分类, 缓冲/非缓冲, 直接/非直接, 阻塞/非阻塞, 同步/异步 缓冲IO, 利用标准库缓存来加速文件访问, 标准库内部通过系统调度来访问文件(printf遇到换行符输出)非缓冲IO, 直接通过系统调用来访问文件, 不再经过标准库缓存 直接IO, 跳过操作系统页缓存, 直接和文件系统交互访问文件(数据库写)非直接IO, 文件读写时, 先要经过系统的页缓存, 再由内核或系统写入磁盘 阻塞IO, 执行操作后没有获得响应, 阻塞当前线程, 不会执行其他任务(管道或网络套接字O_NONBLOCK)非阻塞IO, 执行操作后不会阻塞当前线程, 可以执行其他程序, 通过轮询获取响应结果(select/poll) 同步IO, 执行IO操作后, 一直等到整个IO完成后, 才获得结果响应(O_SYNC文件数据和元数据写入磁盘)异步IO, 执行IO操作后, 不用等待完成和完成后响应, 可以继续执行。IO完成后通过事件方式通知应用程序 阻塞和非阻塞/同步和异步 是从两个不同角度划分, 描述的对象也不同, 分别是应用程序和系统。 查看工具12345678910111213141516171819202122232425[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 17G 7.5G 9.5G 44% /devtmpfs 486M 0 486M 0% /devtmpfs 497M 0 497M 0% /dev/shmtmpfs 497M 6.6M 490M 2% /runtmpfs 497M 0 497M 0% /sys/fs/cgroup/dev/sda1 1014M 142M 873M 14% /boottmpfs 100M 0 100M 0% /run/user/0[root@localhost ~]# df -ihFilesystem Inodes IUsed IFree IUse% Mounted on/dev/mapper/centos-root 8.5M 101K 8.4M 2% /devtmpfs 122K 361 122K 1% /devtmpfs 125K 1 125K 1% /dev/shmtmpfs 125K 422 124K 1% /runtmpfs 125K 16 125K 1% /sys/fs/cgroup/dev/sda1 512K 328 512K 1% /boottmpfs 125K 1 125K 1% /run/user/0// 索引节点占磁盘容量, 在磁盘格式化时生成好的。磁盘空间充足, 索引节点空间不足 // 可能是小文件过多导致// 内核使用 Slab 机制，管理目录项和索引节点的缓存 cat /proc/slabinfo | grep -E &apos;^#|dentry|inode&apos; 总结为了降低慢速磁盘对性能的影响, 文件系统通过页缓存, 目录项缓存以及所有节点缓存,缓和磁盘延迟对应用的影响 磁盘I/O磁盘磁盘是持久化存储设备, 根据存储介质不同, 分为机械磁盘和固态磁盘.机械磁盘的最小读写扇区, 一般大小为512字节; 固态磁盘的最小读写单位是页, 通常大小是4K/8K 磁盘按接口分类, IDE/SCSI/SAS/SATA/FC. 不同接口分配不同设备名称, IDE-&gt;hd, SCSI/SATA-&gt;sd有多块同类型的磁盘时, 会按a,b,c等字母数序来编号 磁盘根据需要, 分为不同的区, 如/dev/sda1, /dev/sda2 另一种比较常用的架构, 磁盘阵列(RAID); 或者网络存储集群, 通过NFS, SMB, ISCSI等网络存储协议暴露给服务器使用。 通用块层在linux中, 磁盘作为一个块设备来管理. 为了减少不同块设备差异带来的影响, linux通过一个统一的通用块层来管理, 处于磁盘驱动和文件系统之间的一个块设备抽象层. 主要功能： 向上, 为文件系统和应用提供标准接口; 向下, 把各种异构块设备抽象, 提供统一框架管理对I/O请求排序合并, 提高磁盘读写效率 I/O栈 文件系统层, 包括VFS和其他文件系统的具体体现,提供标准接口访问文件 通用块层, 包括块设备I/O队列和I/O调度器, 对I/O请求排序合并, 然后发送给下一层设备 设备层, 包括存储设备和相应驱动程序, 负责最终物理设备的I/O操作 磁盘性能指标 使用率, 磁盘处理I/O的时间百分比饱和度, 磁盘I/O的繁忙程度, 100%时无法再接受新的请求IOPS, 每秒I/O请求数吞吐量, 每秒的I/O请求大小响应时间, I/O请求从发出到收到响应的时间间隔 查看工具iostat-&gt;iotop-&gt;pidstat1234567891011[root@localhost ~]# iostat -d -x 1Linux 3.10.0-693.el7.x86_64 (localhost) 03/04/2019 _x86_64_ (1 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilsda 0.00 0.01 0.28 0.11 15.38 1.14 83.63 0.00 11.81 8.90 19.28 2.47 0.10dm-0 0.00 0.00 0.26 0.11 14.69 1.04 84.72 0.00 11.39 7.51 20.90 1.93 0.07dm-1 0.00 0.00 0.01 0.00 0.19 0.00 55.94 0.00 36.47 36.47 0.00 34.90 0.02// await 平均每次设备 I/O 操作的等待时间(毫秒)// avgqu-sz 平均 I/O 队列长度// avgrq-sz 平均每次设备 I/O 操作的数据大小(扇区) util% 磁盘I/O使用率 r/s+w/s IOPS rkB/s+wkB/s 是吞吐量 r_await+w_await 12345678[root@localhost ~]# pidstat -d 1Linux 3.10.0-693.el7.x86_64 (localhost) 03/04/2019 _x86_64_ (1 CPU)07:45:24 AM UID PID kB_rd/s kB_wr/s kB_ccwr/s CommandkB_rd/s: 每秒进程从磁盘读取的数据量(以kB为单位)kB_wr/s: 每秒进程向磁盘写的数据量(以kB为单位)Command: 拉起进程对应的命令 案例分析：找出不停打印进程top：cpu的wa很高iostat: util% IO使用率高, 请求队列长pidstat -d : 找出进程, 理解应该用iotopstrace -pf pid :f 跟踪由fork调用所产生的子进程 , 确认具体调用系统函数lsof -p : 查看打开的文件 进程I/O高, 直接top+lsof解决 案例分析：sql执行慢12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758top+ iostat+ pidstat 确定mysql慢$ lsof -p 28014// 上一条命令退出时的返回值, 0表示成功, 1表示失败$ echo $?1// -t 表示显示线程，-a 表示显示命令行参数$ pstree -t -a -p 27458mysqld,27458 --log_bin=on --sync_binlog=1... ├─&#123;mysqld&#125;,27922 ├─&#123;mysqld&#125;,27923 └─&#123;mysqld&#125;,28014// lsof 需要进程号$ lsof -p 27458COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME...​mysqld 27458 999 38u REG 8,1 512440000 2601895 /var/lib/mysql/test/products.MYD// strace 确定在做什么$ strace -f -p 27458[pid 28014] read(38, &quot;934EiwT363aak7VtqF1mHGa4LL4Dhbks&quot;..., 131072) = 131072[pid 28014] read(38, &quot;hSs7KBDepBqA6m4ce6i6iUfFTeG9Ot9z&quot;..., 20480) = 20480[pid 28014] read(38, &quot;NRhRjCSsLLBjTfdqiBRLvN9K6FRfqqLm&quot;..., 131072) = 131072[pid 28014] read(38, &quot;AKgsik4BilLb7y6OkwQUjjqGeCTQTaRl&quot;..., 24576) = 24576[pid 28014] read(38, &quot;hFMHx7FzUSqfFI22fQxWCpSnDmRjamaW&quot;..., 131072) = 131072[pid 28014] read(38, &quot;ajUzLmKqivcDJSkiw7QWf2ETLgvQIpfC&quot;..., 20480) = 20480// 显示mysql使用目录, 只是为了进一步确认$ docker exec -i -t mysql mysql -e &apos;show global variables like &quot;%datadir%&quot;;&apos;+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| datadir | /var/lib/mysql/ |+---------------+-----------------+mysql&gt; show full processlist;+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+| Id | User | Host | db | Command | Time | State | Info |+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+| 27 | root | localhost | test | Query | 0 | init | show full processlist || 28 | root | 127.0.0.1:42262 | test | Query | 1 | Sending data | select * from products where productName=&apos;geektime&apos; |+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+2 rows in set (0.00 sec)# 切换到 test 库mysql&gt; use test;# 执行 explain 命令mysql&gt; explain select * from products where productName=&apos;geektime&apos;;+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+| 1 | SIMPLE | products | ALL | NULL | NULL | NULL | NULL | 10000 | Using where |+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+1 row in set (0.00 sec) /var/lib/mysql/test的4个文件： MYD 存储表的数据 MYI 存储表的索引 frm 存储表的元信息(表结构) opt 存储数据库的元信息(字符集) 没用索引….(top+strace) 另外, opensnoop监控打开文件 案例分析: redis慢写文件慢(top+strace) 系统I/O瓶颈分析套路linux系统I/O栈 iostat 发现磁盘IO瓶颈-&gt;pidstat确认进程, 分析读写-&gt;strace/lsof分析应用程序 I/O性能优化应用程序优化 1.用追加写代替随机写, 减少寻址开销, 加快I/O写的速度 2.借助缓存I/O, 充分利用系统缓存, 降低实际I/O的次数(mysql的MyISAM,查询依赖缓存) 3.在应用程序内部构建自己的缓存, 控制缓存数据和生命周期(批价mdb_cache) 4.频繁读写同一块磁盘, mmap代替, 减少读写次数(直接I/O) 5.在需要同步写的场景中, 尽量将写请求合并, fsync()代替O_SYNC(mdb一次提交N条数据) 6.在多个应用程序共享磁盘时, 为保证I/O不被一个进程独占, 可以使用cgroups的I/O子系统来限制进程/进程组的IOPS和吞吐量 7.在使用CFQ调度器时, ionice调整进程I/O优先级, 提高核心应用的优先级 1234567ionice -p 25089 -c 2 -n 7使用 ionice 之前查一下帮助文件，-c 是指定调度类型，这里选择的是 2，best-effort； -n 指定调度优先级，0 最高，7最低；-p 是指定进程号OPTIONS-c The scheduling class. 1 for real time, 2 for best-effort, 3 foridle.... 文件系统优化 1.选择合适的文件系统, 如xfs比ext4支持更大的磁盘分区和文件数, 支持大于16T的磁盘 2.优化文件系统的配置, 文件系统特性/日志模式/挂载选项(tune2fs 查看文件系统超级块) 3.优化文件系统缓存, /proc/sys/vm/vfs_cache_pressure 优化内核回收目录项缓存和索引节点缓存 4.利用tmpfs内存文件系统, 获得更好的I/O性能 磁盘优化 1.SSD替代HDD 2.利用RAID磁盘阵列 3.选择合适的I/O调度算法, SSD和虚拟机的磁盘一般用noop算法, 数据库一般使用deadline算法 4.磁盘隔离, 为I/O压力重的应用配置单独磁盘, 如数据库,日志 5.在顺序读较多的场景中, 增大磁盘的预读数据配置 6.优化内核设备I/O选项, 例如增加队列长度, 提高吞吐(I/O延迟可能增大) 123查看当前系统的I/O调度方法:cat /sys/block/sda/queue/schedulernoop anticipatory deadline [cfq]]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化之内存 笔记]]></title>
    <url>%2F2019%2F02%2F27%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux内存工作原理linux内核给每个进程提供了一个独立的虚拟地址空间, 并且这个地址空间是连续的。 内存映射虚拟地址空间分为内核空间和用户空间, 常见的32位和64位虚拟地址空间如下： 内存映射, 就是将虚拟内存地址映射到物理内存地址。内核为每个进程都维护一张页表, 记录映射关系： 页表实际存储在内存管理单元MMU中, 这样处理器直接通过硬件找出访问的内存。当进程访问虚拟地址在页表中查不到时, 会产生缺页异常, 进入内核空间分配物理内存, 更新进程页表, 最后返回用户空间, 恢复进程。 MMU最小单位4KB, 每次内存映射4KB或4KB的整数倍。 linux通过多级页表和大页两种机制来管理页表。 虚拟内存空间分布 C程序内存分布：1.程序段:程序段为程序代码在内存中的映射.一个程序可以在内存中多有个副本.2.初始化过的数据:在程序运行值初已经对变量进行初始化的3.未初始化过的数据:在程序运行初未对变量进行初始化的数据4.堆(stack):存储局部,临时变量,在程序块开始时自动分配内存,结束时自动释放内存.存储函数的返回指针.5.栈(heap):存储动态内存分配,需要程序员手工分配,手工释放. 虚拟内存参考 内存分配和回收小于128K用brk()分配, 否则用mmap()在文件映射段找一块内存分配。brk在释放时不会还给系统,缓存起来重复利用, 会产生内存碎片。mmap频繁会产生大量缺页异常, 内核管理负担增大。 系统在内存紧张时回收机制, LRU/SWAP/OOM 12$ dmesg | grep -i &quot;Out of memory&quot;Out of memory: Kill process 9329 (java) score 321 or sacrifice child 查看内存free/top/ps SHR 并不一定是共享的, 包括程序代码段, 非共享链接库 内存中的Buffer和cache定义Buffer-&gt;磁盘数据缓冲区, cache-&gt;文件数据缓存 用以下案例, vmstat 观察1234567891011121314151617// 首先清理缓存$ echo 3 &gt; /proc/sys/vm/drop_caches// 写文件$ dd if=/dev/urandom of=/tmp/file bs=1M count=500// 写磁盘, 相当于清磁盘// 然后运行 dd 命令向磁盘分区 /dev/sdb1 写入 2G 数据$ dd if=/dev/urandom of=/dev/sdb1 bs=1M count=2048// 读文件// 运行 dd 命令读取文件数据$ dd if=/tmp/file of=/dev/null// 读磁盘// 运行 dd 命令读取文件$ dd if=/dev/sda1 of=/dev/null bs=1M count=1024 123456789101112131415手动释放缓存区内存的方法1）清理pagecache（页面缓存）[root@backup ~]# echo 1 &gt; /proc/sys/vm/drop_caches 或者 sysctl -w vm.drop_caches=1 2）清理dentries（目录缓存）和inodes[root@backup ~]# echo 2 &gt; /proc/sys/vm/drop_caches 或者 sysctl -w vm.drop_caches=2 3）清理pagecache、dentries和inodes[root@backup ~]# echo 3 &gt; /proc/sys/vm/drop_caches 或者 sysctl -w vm.drop_caches=3 上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置： vm.drop_caches=1/2/3，然后sysctl -p生效即可！ 另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存[root@backup ~]# sync 查看工具BCC cachestat: 系统缓存命中情况cacheop: 进程缓存命中情况 centos上安装相当不方便 内存泄漏排查和优化valgrind/memleak/ 存在需要大量内存场景, 考虑栈内存或者内存池, 大页来优化内存分配管理 Swap交换分区原理说明内存紧张时, linux通过直接回收和定期扫描方式, 来释放文件页和内存页, 把内存分配给更需要的进程： 文件页直接清空, 或写回磁盘后释放缓存 匿名页需要通过swap换入换出 内核有个专门的线程来定期回收内存, kswapd0 阀值通过 /proc/zeroinfo 来查看, 通过/proc/sys/vm/min_free_kbytes 设置回收阀值 系统内存有剩余, 还是使用了swap。NUMA架构下, CPU分到不同的node上, 每个node有自己的本地空间。 查看工具12345678910111213141516171819202122232425262728293031[root@localhost ~]# numactl --hardwareavailable: 1 nodes (0)node 0 cpus: 0node 0 size: 1023 MBnode 0 free: 174 MBnode distances:node 0 0: 10 // 系统只有一个node, 内存大小1023M, 剩余174M[root@localhost ~]# cat /proc/zoneinfoNode 0, zone DMA pages free 1209 min 176 low 220 high 264 scanned 0 spanned 4095 present 3998 managed 3977 nr_free_pages 1209 nr_alloc_batch 44 nr_inactive_anon 462 nr_active_anon 332 nr_inactive_file 1476// free 剩余内存页, 同nr_free_pages// nr_active_anon/nr_inactive_anon 活跃和匿名内存页// nr_inactive_file 非活跃文件页// 当node内存不足, 从其他node寻找空闲内存, 或从本地内存回收。// 调整 /proc/sys/vm/zone_reclaim_mode 设置内存回收策略 /proc/sys/vm/swappiness 调整使用Swap的积极程度(范围0～100), 设置成0,当剩余内存 + 文件页小于页高阀值, 还是会发生swap 案例分析1234567891011121314151617// 写入空设备，实际上只有磁盘的读请求$ dd if=/dev/sda1 of=/dev/null bs=1G count=2048// S 显示swap使用情况[root@localhost ~]# sar -r -S 1Linux 3.10.0-693.el7.x86_64 (localhost.localdomain) 02/28/2019 _x86_64_ (1 CPU)03:56:49 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty03:56:50 AM 170920 845312 83.18 0 629936 364252 11.71 197604 523108 003:56:49 AM kbswpfree kbswpused %swpused kbswpcad %swpcad03:56:50 AM 2092556 496 0.02 40 8.06// 关闭swapswapoff -a// 清空swapswapoff -a &amp;&amp; swapon -a 内存分析套路]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[virtualbox网络设置]]></title>
    <url>%2F2019%2F02%2F25%2Fvirtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[环境vbox: 版本 5.2.linux: Centos7 需求虚拟机可以访问网络, 和宿主机可以相互访问 vbox配置 管理-&gt;主机网络管理-&gt;不启用dhcp, 设置虚拟网关 管理-&gt;全局设置-&gt;网络 设置-&gt;网络-&gt;网卡1-&gt;网卡2 宿主机网络共享 centos配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s3TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static#BOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s3UUID=cf96977f-80a6-4fb6-a68d-0a8836ee8287DEVICE=enp0s3ONBOOT=yesPREFIXO0=24IPADDR=192.168.137.20NETMASK=255.255.255.0PREFIX=8GATEWAY=192.168.137.1DNS1=10.70.75.253#DNS2=10.70.180.80DNS2=8.8.8.8[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s8TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=no#BOOTPROTO=staticBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s8UUID=f0095258-92b9-3ea4-bcb7-5f9eee4eda2b // nmcli con show 找到UUID(NetworkManager)DEVICE=enp0s8ONBOOT=yesPREFIXO0=24#IPADDR=192.168.137.20#NETMASK=255.255.255.0PREFIX=8#GATEWAY=192.168.137.1#DNS1=10.70.75.253#DNS2=10.70.180.80#DNS2=8.8.8.8DWADDR=08:00:27:09:ac:45 // ip add 找到MAC地址// 默认使用enp0s8[root@localhost ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.0.3.2 0.0.0.0 UG 0 0 0 enp0s810.0.3.0 0.0.0.0 255.255.255.0 U 0 0 0 enp0s8169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 enp0s3169.254.0.0 0.0.0.0 255.255.0.0 U 1003 0 0 enp0s8192.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 enp0s3[root@localhost ~]# cat /etc/resolv.conf; generated by /usr/sbin/dhclient-scriptnameserver 10.70.75.253nameserver 10.70.180.80nameserver 10.70.75.253nameserver 10.70.180.80search localdomain[root@localhost ~]# ifconfigenp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.137.20 netmask 255.0.0.0 broadcast 192.255.255.255 inet6 fe80::a00:27ff:fe41:f483 prefixlen 64 scopeid 0x20&lt;link&gt; ether 08:00:27:41:f4:83 txqueuelen 1000 (Ethernet) RX packets 316 bytes 33319 (32.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 212 bytes 41130 (40.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0enp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.0.3.15 netmask 255.255.255.0 broadcast 10.0.3.255 inet6 fe80::a00:27ff:fe09:ac45 prefixlen 64 scopeid 0x20&lt;link&gt; ether 08:00:27:09:ac:45 txqueuelen 1000 (Ethernet) RX packets 70 bytes 8437 (8.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 89 bytes 8116 (7.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 问题enp0s8 如果没有自动生成配置文件, 手工添加;更换网络后, 注意DNS也对应更改下;]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux性能优化 笔记]]></title>
    <url>%2F2019%2F02%2F20%2Flinux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 序Linux 资源可能会碰到的性能问题，包括CPU性能、磁盘IO、内存以及网络性能 鸡汤提神：”想要得到你就要学会付出，要付出还要坚持；如果你真的觉得很难，那你就放弃，如果你放弃了就不要抱怨。人生就是这样，世界是平衡的，每个人都是通过自己的努力，去决定自己生活的样子” 总结鸡汤可以调整心态续命; 学习要会抓重点 第二章 目录性能分析，其实就是找出应用或系统的瓶颈，并设法去避免或者缓解，更高效的利用资源处理更多的请求。 性能分析套路: 选择指标评估应用程序和系统性能 为应用程序和系统设置性能目标 进行性能基准测试 性能分析定位瓶颈 优化系统和应用程序 性能监控和告警 建立整体系统性能的全局观是最核心, 工具图谱和学习思维导图, 以及几个学习小技巧 总结要学会思维导图整理思路 第三章 平均负载什么是平均负载平均负载, 是指在单位时间内, 系统处于可运行和不可中断状态的平均进程数, 也就是平均活跃进程。与CPU的使用率并没有直接的关系。 在 sched/loadavg.c 中计算平均值的算法为EMA，这种算法的目的主要是“距离目标预测窗口越近，则数据的价值越高，对未来影响越大” linux下进程有五种状态, 可运行状态是指在使用CPU或在等待CPU队列中的进程, 用PS可以看到R状态。不可中断状态进程是指正处于内核关键流程中的进程, 并且这些流程是不可打断的, 比如等待I/O响应（Uninterruptible Sleep，也称为Disk sleep)PS看到的D状态。 不可中断状态是系统对进程和硬件的一种保护机制。比如在写磁盘数据时，为了保证一致性, 必须等待磁盘响应。 可以用man查看uptime的说明, uptime看到的是活跃进程数的衰减平均值 平均负载为多少时合理 查看CPU个数 lscpu 或者 grep ‘model name’ /proc/cpuinfo | wc -linux下进程有五种状态 uptime 分析系统负载趋势, 1分钟的值&gt; 5分钟的值&gt; 15分钟的值 说明负载在增加, 如果是4个CPU,平均负载是1, 说明CPU有75%的空闲 案例一个单CPU的平均负载1.73, 0.60, 7.98, 整体趋势看, 负载在降低 平均负载与 CPU 使用率CPU使用率, 是单位时间内CPU的繁忙情况。平均负载统计是包括了等待CPU和等待I/O的进程。所以平均负载高, cpu使用率不一定高。 stress CPU压测工具mpstat 多核CPU性能分析工具, 实时查看CPU指标pidstat 进程性能分析工具, 实时查看进程CPU、内存、IO情况、上下问切换等指标 平均负载案例分析 场景一：CPU密集型进程 12345678910111213141516171819202122[root@zhangbb ~]# stress --cpu 1 --timeout 600stress: info: [2089] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd[root@zhangbb ~]# uptime 16:09:48 up 209 days, 5:29, 8 users, load average: 1.03, 0.41, 0.40[root@zhangbb ~]# mpstat 1 60Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:09:32 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle04:09:33 PM all 99.01 0.00 0.00 0.00 0.00 0.00 0.99 0.00 0.00 0.0004:09:34 PM all 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0004:09:35 PM all 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00[root@zhangbb ~]# pidstat -u 1 1Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:16:35 PM UID PID %usr %system %guest %CPU CPU Command04:16:36 PM 0 455 0.99 0.00 0.00 0.99 0 rsyslogd04:16:36 PM 0 2090 97.03 0.00 0.00 97.03 0 stress04:16:36 PM 0 28600 0.99 0.99 0.00 1.98 0 pritunl04:16:36 PM 992 28606 0.99 0.00 0.00 0.99 0 mongod 场景二：I/O密集型进程 123456789101112131415161718192021222324252627// 一个进程不停的sync[root@zhangbb ~]# stress -i 1 --timeout 600stress: info: [3110] dispatching hogs: 0 cpu, 1 io, 0 vm, 0 hdd[root@zhangbb ~]# uptime 16:19:34 up 209 days, 5:39, 8 users, load average: 5.41, 6.15, 3.59//虚拟机，缓冲区可能比较小，无法产生大的IO压力，这样大部分就都是系统调用的消耗了//使用下一代stress-ng，它支持更丰富的选项，比如 stress-ng -i 1 --hdd 1 --timeout 600（--hdd表示读写临时文件）[root@zhangbb ~]# mpstat 1 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:20:15 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle04:20:16 PM all 2.33 0.00 77.91 19.77 0.00 0.00 0.00 0.00 0.00 0.0004:20:17 PM all 2.27 0.00 77.27 19.32 0.00 0.00 1.14 0.00 0.00 0.0004:20:18 PM all 3.33 0.00 76.67 20.00 0.00 0.00 0.00 0.00 0.00 0.00Average: all 2.65 0.00 77.27 19.70 0.00 0.00 0.38 0.00 0.00 0.00[root@zhangbb ~]# pidstat -u 1 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/20/2019 _x86_64_ (1 CPU)04:19:50 PM UID PID %usr %system %guest %CPU CPU Command04:19:51 PM 0 253 0.00 5.56 0.00 5.56 0 kworker/0:1H04:19:51 PM 0 3111 1.11 76.67 0.00 77.78 0 stress04:19:51 PM 0 20180 0.00 1.11 0.00 1.11 0 kworker/u2:004:19:51 PM 0 28600 2.22 0.00 0.00 2.22 0 pritunl04:19:51 PM 992 28606 1.11 0.00 0.00 1.11 0 mongod 场景三：大量进程场景 12stress -c 8 --timeout进程数超过CPU， uptime + mpstat + pidstat看平均负载 ==&gt; 分析CPU使用场景 ==&gt; 确定具体进程 总结要会分析CPU使用典型场景, 这章只是为了说明平均负载 第四章 CPU上下文切换CPU寄存器是CPU内置的容量小、但速度极快的内存。程序计数器用来存储CPU正在执行的指令位置、或者即将执行下一条指令的位置。以上两个是CPU运行任务前依赖的环境, 也被称为CPU上下文。切换就是保存和加载新的任务上下文到CPU寄存器和计数器。 根据任务的不同, CPU上下文切换分为几个场景, 进程、线程、中断上下文切换。系统调用通常称为特权模式的切换，而不是上下文切换。实际上，系统调用过程中,CPU上下文切换是无法避免的。 进程上下文切换一个进程切换到另一个进程, 在进程调度的时候发生。linux为每个CPU维护一个就绪队列将活跃进程按照优先级和CPU排序时间排序, 选择优先级高或等待CPU时间最长的进程运行。 进程调度场景： 为保证所有进程公平调度, CPU时间被划分为一段段的时间片，被轮流分配给各个进程。时间片耗尽,进程被挂起, 切换到其他正在等待CPU的进程。 进程资源不足, 挂起, 运行其他进程 sleep挂起 有优先级高的进程 发生硬件中断, 挂起, 执行内核中中断服务程序 线程上下文切换线程和进程最大的区别在于, 线程是调度的基本单位, 进程则是资源拥有的基本单位。内核调度对象实际是线程, 进程给线程提供了虚拟内存、全局变量等资源。 同个进程的线程上下文切换，因为虚拟内存共享, 只需要切换线程私有数据, 寄存器等不共享数据。 硬件中断上下文切换有限级最高 总结明白原理, 要能说得上来 第五章 上下文切换分析实践系统上下文切换123456789[root@zhangbb ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st29 0 0 72276 11420 436708 0 0 1 7 1 1 0 0 99 0 0// cs(context switch) 每秒上下文切换// in(interrupt) 每秒中断次数// r(Running or Runnable) 就绪队列的长度, 正在运行和等待的CPU进程数// b(Block) 处于不可中断状态睡眠的进程数 进程上下文切换12345678910111213141516171819[root@zhangbb ~]# pidstat -w 1Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/21/2019 _x86_64_ (1 CPU)02:14:40 PM UID PID cswch/s nvcswch/s Command02:14:42 PM 0 3 3.92 0.00 ksoftirqd/002:14:42 PM 0 9 13.73 0.00 rcu_sched02:14:42 PM 0 10 0.98 0.00 watchdog/002:14:42 PM 0 253 0.98 0.00 kworker/0:1H02:14:42 PM 0 336 1.96 0.00 systemd-journal02:14:42 PM 0 846 0.98 0.00 php-fpm02:14:42 PM 0 1028 0.98 0.00 kworker/0:002:14:42 PM 0 1494 8.82 0.00 kworker/0:102:14:42 PM 0 1778 0.98 0.98 pidstat02:14:42 PM 0 16712 0.98 0.00 kworker/u2:002:14:42 PM 0 28600 0.98 0.00 pritunl02:14:42 PM 0 29204 1.96 0.00 dockerd// cswch 每秒自愿上下文切换(进程无发获取资源导致切换, 例如I/O、内存不足)// nvcswch 每秒非自愿上下文切换(进程由于时间片已到导致切换, 例如大量进程争抢CPU) 实验1234567891011121314151617181920212223242526// 10个线程运行, 5分钟基准测试, 模拟线程切换[root@zhangbb ~]# sysbench --threads=10 --max-time=300 --max-requests=10000000 threads run[root@zhangbb ~]# vmstat 1 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st10 1 0 70764 24052 423232 0 0 1 7 1 0 0 0 99 0 0[root@zhangbb ~]# pidstat -wt -p 3355Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/21/2019 _x86_64_ (1 CPU)02:31:56 PM UID TGID TID cswch/s nvcswch/s Command02:31:56 PM 0 3355 - 0.00 0.00 sysbench02:31:56 PM 0 - 3355 0.00 0.00 |__sysbench02:31:56 PM 0 - 3356 0.07 0.43 |__sysbench02:31:56 PM 0 - 3357 0.07 0.44 |__sysbench02:31:56 PM 0 - 3358 0.06 0.45 |__sysbench02:31:56 PM 0 - 3359 0.07 0.44 |__sysbench02:31:56 PM 0 - 3360 0.07 0.43 |__sysbench02:31:56 PM 0 - 3361 0.07 0.43 |__sysbench02:31:56 PM 0 - 3362 0.07 0.43 |__sysbench02:31:56 PM 0 - 3363 0.07 0.43 |__sysbench02:31:56 PM 0 - 3364 0.07 0.43 |__sysbench02:31:56 PM 0 - 3365 0.07 0.43 |__sysbench// cs和in数据都不大，神奇的 总结单看上下切换意义不大，在CPU高的时候观察分析切换趋势 第六章 CPU使用率linux定义节拍率(内核表示HZ)，触发时间中断，并使用全局变量jiffies记录节拍数。 1234567[root@zhangbb ~]# grep &apos;CONFIG_HZ=&apos; /boot/config-$(uname -r)CONFIG_HZ=1000[root@zhangbb ~]# cat /proc/stat |grep cpucpu 7069586 162259 3931778 1794587448 203158 0 55664 3714828 0 0cpu0 7069586 162259 3931778 1794587448 203158 0 55664 3714828 0 0// CPU使用率指标user(us): 用户态CPU时间, 不包括nice, 包括guestnice(ni): 低优先级用户态时间system(sys): 内核态CPU时间idle(id): 空闲时间, 不包括等待I/O时间iowait(wa): 等待I/O的CPU时间irq(hi): 硬中断的CPU时间softirq(si): 软中断的CPU时间steal(st): 被其他虚拟机占用的CPU时间guest(): 运行虚拟机的CPU时间guest_nice(gnice): 以低优先级运行虚拟机的时间 CPU使用率计算公式CPU使用率 = 1 - $\dfrac{空闲时间}{总CPU时间}$ CPU平均使用率 = 1 - $\dfrac{空闲时间new - 空闲时间old}{总CPU时间new - 总CPU时间old}$ 性能工具输出的是一段时间内的CPU平均使用率, 注意时间间隔的设置。top默认3秒时间间隔, ps用的是整个进程的生命周期。 工具12345678910111213141516171819202122232425262728293031323334353637// top, 按1可以显示每个CPUtop - 14:48:43 up 24 days, 19:08, 11 users, load average: 3.16, 3.09, 3.06Tasks: 329 total, 1 running, 328 sleeping, 0 stopped, 0 zombie%Cpu0 : 3.1 us, 3.4 sy, 0.0 ni, 93.5 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu1 : 2.0 us, 4.7 sy, 0.0 ni, 92.9 id, 0.0 wa, 0.0 hi, 0.3 si, 0.0 st%Cpu2 : 90.7 us, 0.3 sy, 0.0 ni, 8.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu3 : 8.1 us, 1.0 sy, 0.0 ni, 90.2 id, 0.0 wa, 0.0 hi, 0.7 si, 0.0 st%Cpu4 : 97.0 us, 0.0 sy, 0.0 ni, 3.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu5 : 13.3 us, 3.0 sy, 0.0 ni, 82.7 id, 0.0 wa, 0.0 hi, 1.0 si, 0.0 st%Cpu6 : 3.1 us, 5.2 sy, 0.0 ni, 91.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st%Cpu7 : 1.4 us, 1.7 sy, 0.0 ni, 96.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem: 66109508 total, 65666692 used, 442816 free, 223228 buffersKiB Swap: 2103292 total, 2103284 used, 8 free. 33262276 cached Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 23553 zjv8cs 20 0 23.118g 88184 75864 S 198.7 0.133 68458:16 sframe 28988 zjv8cs 20 0 24.418g 37268 19044 S 6.312 0.056 265:23.24 sframe 10138 zjv8cs 20 0 25.083g 54204 24276 S 5.980 0.082 171:07.74 sframe 1253 zjv8cs2 20 0 19.784g 19176 8492 S 4.651 0.029 71:39.65 sframe 1260 zjv8cs2 20 0 19.846g 19288 8596 S 4.319 0.029 71:15.20 sframe 26254 zjv8cs 20 0 23.542g 18972 8452 S 4.319 0.029 220:11.03 sframe 12796 zjv8cs2 20 0 20.365g 20172 8612 S 3.987 0.031 161:11.72 sframe [root@zhangbb ~]# pidstat 1 1 Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 02/22/2019 _x86_64_ (1 CPU)02:50:39 PM UID PID %usr %system %guest %CPU CPU Command02:50:40 PM 0 18909 0.00 1.98 0.00 1.98 0 pidstat02:50:40 PM 0 28600 1.98 1.98 0.00 3.96 0 pritunlAverage: UID PID %usr %system %guest %CPU CPU CommandAverage: 0 18909 0.00 1.98 0.00 1.98 - pidstatAverage: 0 28600 1.98 1.98 0.00 3.96 - pritunl// -g 选项是告诉perf record额外记录函数的调用关系, 相当与gstackperf record -g -p 1663perf report -i perf.data 找CPU使用率高的进程123456781. top 看整体CPU，但找不到对应进程2. pstree |grep stress 查看进程关系也找不到//这个时候perf出场了3. perf record -g 跑一段时间就可以找到4. execsnoop 一段bin/bash脚本监控短时进程 execsnoop 总结看懂CPU使用率, 短时进程占用CPU需要仔细找 第七章 大量不可中断和僵尸进程进程状态 R(Running/Runnable) 进程在CPU的就绪队列中, 正在运行或正在等待运行 D(Disk Sleep) 不可中断状态睡眠, 一般表示与硬件进行交互不允许中断 Z(Zombile) 进程已经结束, 父进程没有回收它的资源 S(Interruptible Sleep) 可中断状态睡眠, 因等待某个事件而被挂起 I(Idle) 空闲状态, 内核上没有任何负载 T/t 暂停(向进程发送SIGSTOP, SIGCONT恢复运行)或跟踪状态(gdb触发断点后变为跟踪状态) X(Dead) 消亡 僵尸进程产生(最后init进程回收)：当一个进程没有用你waitpid() 或 wait() 来等待子进程结束, 回收子进程资源。子进程结束时会向父进程发送SIGCHLD信号, 父进程可以注册信号函数, 异步回收资源。 查看进程状态12345678910111213Tasks: 84 total, 1 running, 83 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 6.2 sy, 0.0 ni, 93.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1016232 total, 598872 free, 123164 used, 294196 buff/cacheKiB Swap: 2093052 total, 2093052 free, 0 used. 738928 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 43304 3652 2472 S 0.0 0.4 0:00.92 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd $ ps aux | grep /approot 4009 0.0 0.0 4376 1008 pts/0 Ss+ 05:51 0:00 /approot 4287 0.6 0.4 37280 33660 pts/0 D+ 05:54 0:00 /approot 4288 0.6 0.4 37280 33668 pts/0 D+ 05:54 0:00 /app Tasks 统计了所有进程的状态;s表示会话的领导进程, +表示前台进程组。 会话是指共享同一个控制终端的一个或多个进程组进程组表示一组相关联的进程, 比如子进程是父进程的组成员 僵尸进程, top+mpstat+strace 都分析不出具体进程哪里导致, 用perf record -g 12345678910# -a 表示输出命令行选项# p 表 PID# s 表示指定进程的父进程$ pstree -aps 3084systemd,1 └─dockerd,15006 -H fd:// └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml └─docker-containe,3991 -namespace moby -workdir... └─app,4009 └─(app,3084) 第八章 Linux中断中断是一种异步事件处理机制, 可以提高系统并发处理能力。linux中断分为两个部分： 上半部分用来快速处理中断, 在中断禁止模式下运行, 主要处理跟硬件相关的或时间敏感的工作(硬中断) 下半部分用来处理上半部分未完成的工作, 通常以内核线程的方式运行(软中断) 例如网卡收到数据, 通过硬中断的方式通知内核有数据到了。上半部分就是把数据存到内存中, 更新硬件寄存器状态标记读完了, 再发送一个软中断信号; 下半部分从内存中找到数据, 按照协议逐层解析和处理, 直到把数据送给应用程序。下半部分为软中断, 网络收发, 内核调度, 定时和 RCU(Read-Copy Update) 锁等也是软中断 123456789101112131415161718192021222324252627282930// 软中断有10种类型, NET_TX 发送, NET_RX 收到52_zjdev[/data01/zjgrp/zjdev]%cat /proc/softirqs CPU0 CPU1 CPU2 CPU3 CPU4 CPU5 CPU6 CPU7 HI: 0 0 0 1 0 1 0 0 TIMER: 624542203 618314692 623983342 624076875 624124123 624035463 623433144 624038509 NET_TX: 1354 10585 1286 2616 1214 1197 1352 1312 NET_RX: 27576207 417105033 31251647 28771418 27476757 28494061 29043344 27354831 BLOCK: 0 0 0 0 0 0 0 0BLOCK_IOPOLL: 0 0 0 0 0 0 0 0 TASKLET: 96 536 87 129 78 92 76 81 SCHED: 187960212 193268976 186768826 186464769 186313710 186328311 185646819 185912615 HRTIMER: 31725 48363 32398 31972 32393 31312 33647 31754 RCU: 312851620 621342389 314557141 626218602 314804587 626018159 625412616 626075625 // 硬中断.......cat /proc/interrupts// 软中断内核线程, ksoftirqd/CPU 编号52_zjdev[/data01/zjgrp/zjdev]%ps aux | grep softirqroot 3 0.0 0.0 0 0 ? S 1月28 0:14 [ksoftirqd/0]root 13 0.0 0.0 0 0 ? S 1月28 0:48 [ksoftirqd/1]root 18 0.0 0.0 0 0 ? S 1月28 0:25 [ksoftirqd/2]root 23 0.0 0.0 0 0 ? S 1月28 0:16 [ksoftirqd/3]root 28 0.0 0.0 0 0 ? S 1月28 0:14 [ksoftirqd/4]root 33 0.0 0.0 0 0 ? S 1月28 0:14 [ksoftirqd/5]root 38 0.0 0.0 0 0 ? S 1月28 0:13 [ksoftirqd/6]root 43 0.0 0.0 0 0 ? S 1月28 0:12 [ksoftirqd/7]zjdev 23982 0.0 0.0 12964 932 pts/9 S+ 10:34 0:00 grep softirq 第九章 软中断CPU使用率升高工具：sar: 系统活动报告工具, 实时查看系统当前活动hpping3：tcp/id 协议数据包工具, sync flood 1234567891011121314151617181920212223242526272829303132# top 运行后按数字 1 切换到显示所有 CPU$ toptop - 10:50:58 up 1 days, 22:10, 1 user, load average: 0.00, 0.00, 0.00Tasks: 122 total, 1 running, 71 sleeping, 0 stopped, 0 zombie%Cpu0 : 0.0 us, 0.0 sy, 0.0 ni, 96.7 id, 0.0 wa, 0.0 hi, 3.3 si, 0.0 st%Cpu1 : 0.0 us, 0.0 sy, 0.0 ni, 95.6 id, 0.0 wa, 0.0 hi, 4.4 si, 0.0 st... PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 7 root 20 0 0 0 0 S 0.3 0.0 0:01.64 ksoftirqd/0 16 root 20 0 0 0 0 S 0.3 0.0 0:01.97 ksoftirqd/1 2663 root 20 0 923480 28292 13996 S 0.3 0.3 4:58.66 docker-containe 3699 root 20 0 0 0 0 I 0.3 0.0 0:00.13 kworker/u4:0 3708 root 20 0 44572 4176 3512 R 0.3 0.1 0:00.07 top 1 root 20 0 225384 9136 6724 S 0.0 0.1 0:23.25 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.03 kthreadd...[root@localhost ~]# watch -d cat /proc/softirqsEvery 2.0s: cat /proc/softirqs Tue Feb 26 21:54:03 2019 CPU0 HI: 6 TIMER: 67166 NET_TX: 1817 NET_RX: 6051 BLOCK: 9899BLOCK_IOPOLL: 0 TASKLET: 45 SCHED: 0 HRTIMER: 0 RCU: 16504 总结软中断CPU使用率升高是个常见的性能问题, 实际生产一般是网络收发导致, 尤其是网络接收软中断 第十章 系统CPU瓶颈分析套路]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vector容器]]></title>
    <url>%2F2019%2F02%2F18%2Fvector%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[内存分配 reservesizecapacity 内存释放 cleareraseswapshrink_to_fit 其他 dataemplace_back]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++比java快吗]]></title>
    <url>%2F2019%2F02%2F07%2Fc-%E6%AF%94java%E5%BF%AB%E5%90%97%2F</url>
    <content type="text"><![CDATA[参考文章地址 The test suite Loading Program Executable(加载程序可执行文件) Running Program Instructions(运行程序指令) Allocating Memory(内存分配) Accessing System Resources(访问系统资源) EnvironmentPlatform: linux/windowsHardware configuration: cpu,memorySoftware: c++/jdk version Loading Program Executable(LPE)There are two main contributors to this size difference: executable size and selective loading. executable sizec++一般比java大, jvm包含运行需要的库？ selective loadingc++在执行前加载全部可执行文件。链接库加载分为静态和动态加载, 静态加载是指在执行前加载，动态加载是指在运行时调用对应函数。动态加载时没有类型校验, 库变更会导致不可预知的错误。 java在需要时动态加载 Running Program Instructions(RPI)There are two possible methods a JVM uses to do so: a bytecode interpreter or a just-in-time(JIT) compiler.没有JIT(即时编译技术)的JVM在执行每一条指令时都会看到它，因此它不能动态地执行这些类型的优化。但是，JIT可以对整个类文件执行代码优化。因此，与JIT和本地C++应用程序运行的Java程序之间唯一的显著性能差异将是执行类文件的初始翻译所需的时间和执行的优化类型。实际应用中程序多次使用相同的类, JIT智能编译用到次数多的类, 因此翻译过程的开销通常是微不足道的。 编译器的优化参数也是很关键的, 例如对无效代码(Dead Code)是执行还是直接删除c++ RTTI: Run-Time Type Identification, 主要是typeid操作符和4个类型转换关键字 Test Description C++(sec) Java(JIT) Java(Bytecode interpreter) Integer division This test loops 10 million times on an integer division. 1.8 1.8 4.8 Dead code This test loops 10 million times and performs an operation that is never used. 3.7 3.7 9.5 Dead code with Integer division This test loops 10 million times and performs an operation that is never used and one that is. 5.7 5.7 20 Floating-point division This test loops 10 million times on a floating-point division. 1.6 1.6 8.7 Static method This test loops 10 million times calling a static method which contains an Integer division. 1.8 1.8 6.0 Member method This test loops 10 million times calling a member method which contains an Integer division. 1.8 1.8 10 Virtual member method The Member method test performed above is not really valid. In Java all Member methods are virtual. This test loops 10 million times calling a Virtual member method which contains an Integer division. 1.8 1.8 10 Virtual member method with down cast and Run-Time Type Identification (RTTI) This test loops 10 million times calling a Virtual method on a class that has been down cast using RTTI. 11 4.3 12 Virtual member method with invalid down cast and Run-Time Type Identification (RTTI) This test loops 10 million times calling a Virtual method on a class that has been down cast using RTTI. crash crash crash Allocating Memory(AM)JAVA的GC机制避免内存泄漏人工检查时间, 内存碎片问题。c++ 直接通过glibc来分配。Allocating and freeing 10 million 32-bit integers took 0.812 seconds in C++ and 1.592 seconds in Java. Accessing System Resources (ASR)文件/网络操作方面, java跨平台移植方便(jdk封装)，c++无法比拟的优势]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux内核设计与实现]]></title>
    <url>%2F2019%2F01%2F31%2FLinux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[linux内核简介应用程序、内核、硬件关系 linux版本号说明2.6.26.1 = 主板版号.从版本号.修改定版本号.开发版本号(奇数开发，偶数稳定) linxu内核开发者社区 获取内核源码 编译和开发 进程管理进程是处于执行期的程序, 包含打开文件/挂起信号/处理器状态/ 线程]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis设计原理]]></title>
    <url>%2F2019%2F01%2F31%2Fredis%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络字节序]]></title>
    <url>%2F2019%2F01%2F24%2F%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[理解字节序 大端字节序：高位字节在前, 低位字节在后, 这是人类读取字节的方法。小端字节序：低位字节在前, 高位字节在后 0x1234567的大端字节序和小端字节序的写法如下 地址 0x100 0x101 0x102 0x103 大端 0x01 0x23 0x45 0x67 小端 0x67 0x45 0x23 0x01 网络字节序网络字节顺序是TCP/IP中规定好的一种数据表示格式, 采用大端字节序; 与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。 主机字节序 处理器 操作系统 字节排序 Alpha 全部 Little endian HP-PA NT Little endian HP-PA UNIX Big endian Intelx86 全部 Little endian Motorola680x 全部 Big endian MIPS NT Little endian MIPS UNIX Big endian PowerPC NT Little endian PowerPC 非NT Big endian RS/6000 UNIX Big endian SPARC UNIX Big endian IXP1200 ARM核心 Little endian 32位整数转换为网络字节序12345/* 大端字节序 */i = (data[0]&lt;&lt;24) | (data[1]&lt;&lt;16) | (data[2]&lt;&lt;8) | (data[3]&lt;&lt;0);/* 小端字节序 */i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24);]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[零拷贝]]></title>
    <url>%2F2019%2F01%2F23%2F%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[为什么需要零拷贝 零拷贝技术概述简单一点来说，零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术避免数据拷贝 零拷贝技术分类直接IO对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输：这类零拷贝技术针对的是操作系统内核并不需要对数据进行直接处理的情况，数据可以在应用程序地址空间的缓冲区和磁盘之间直接进行传输，完全不需要 Linux 操作系统内核提供的页缓存的支持。 123int open(const char *pathname, int oflag, … /*, mode_t mode * / ) ;O_DIRECT 该描述符提供对直接 I/O 的支持 打开文件指定O_DIRECT 属性时, read/write是直接I/O操作 优点 直接 I/O 最主要的优点就是通过减少操作系统内核缓冲区和应用程序地址空间的数据拷贝次数，降低了对文件读取和写入时所带来的 CPU 的使用以及内存带宽的占用缺点 直接 I/O 的开销非常大, 造成磁盘的同步读, 也会导致应用程序关闭缓慢, 通常会和使用异步 I/O 结合使用 mmap/sendfile/splice避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝 mmap通过使用 mmap() 来代替 read(), 应用程序调用了 write() 之后，操作系统内核将数据从原来的内核缓冲区中拷贝到与 socket 相关的内核缓冲区中 sendfilesendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，所以 sendfile()只是适用于应用程序地址空间不需要对所访问数据进行处理的情况 splicesplice() 可以被看成是类似于基于流的管道的实现，管道可以使得两个文件描述符相互连接，splice 的调用者则可以控制两个设备（或者协议栈）在操作系统内核中的相互连接。在 Linux 2.6.23中，sendfile() 利用了 splice() 这种机制来实现的 1long splice(int fdin, int fdout, size_t len, unsigned int flags); 写时复制拷贝复制的一种策略, 例如fork/string都有使用, 缓冲区共享 快速缓冲区(Fast Buffers)原理介绍应用程序将 fbuf 传递给操作系统内核，这样就能减少传统的 write 系统调用所产生的数据拷贝开销]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[excel数据处理]]></title>
    <url>%2F2019%2F01%2F21%2Fexcel%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Sqlite 简介使用菜鸟教程网站 桌面工具下载安装SQLite Database Browser, 免费开源，支持简单的创建/打开/修改/删除 SQL 数据库。不懂SQL小白也支持操作. 下载地址 右键解压到当前文件夹，解压后如下(可以剪切或复制到其他目录): 进入”DB Browser for SQLite”, 找到如下*.exe，右键创建桌面快捷方式(方便使用) Python脚本python for windows download 第三放库安装：1234win + rcmdpip install openpyxlpip install lxml openpyxl官方手册 1#!/usr/bin/python3]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[malloc死锁]]></title>
    <url>%2F2019%2F01%2F18%2Fmalloc%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[进程bt信息&lt;! – more –&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(gdb) bt#0 0x00007ff5083f65cb in __lll_lock_wait_private () from /lib64/libc.so.6#1 0x00007ff508382bca in _L_lock_10550 () from /lib64/libc.so.6#2 0x00007ff508380705 in malloc () from /lib64/libc.so.6#3 0x00007ff5086bdc47 in start_fde_sort (count=33, accu=0x7ff4cab0b1a0) at ../../../libgcc/unwind-dw2-fde.c:409#4 init_object (ob=0x7ff4babf1be0 &lt;current_sl&gt;) at ../../../libgcc/unwind-dw2-fde.c:771#5 search_object (ob=ob@entry=0x7ff4babf1be0 &lt;current_sl&gt;, pc=pc@entry=0x7ff5086bca07 &lt;_Unwind_Backtrace+55&gt;) at ../../../libgcc/unwind-dw2-fde.c:961#6 0x00007ff5086be492 in _Unwind_Find_registered_FDE (bases=0x7ff4cab0b528, pc=0x7ff5086bca07 &lt;_Unwind_Backtrace+55&gt;) at ../../../libgcc/unwind-dw2-fde.c:1025#7 _Unwind_Find_FDE (pc=0x7ff5086bca07 &lt;_Unwind_Backtrace+55&gt;, bases=bases@entry=0x7ff4cab0b528) at ../../../libgcc/unwind-dw2-fde-dip.c:448#8 0x00007ff5086baee6 in uw_frame_state_for (context=context@entry=0x7ff4cab0b480, fs=fs@entry=0x7ff4cab0b2d0) at ../../../libgcc/unwind-dw2.c:1241#9 0x00007ff5086bc130 in uw_init_context_1 (context=context@entry=0x7ff4cab0b480, outer_cfa=outer_cfa@entry=0x7ff4cab0b730, outer_ra=0x7ff5083f6f46 &lt;backtrace+86&gt;) at ../../../libgcc/unwind-dw2.c:1562#10 0x00007ff5086bca08 in _Unwind_Backtrace (trace=0x7ff5083f6dd0 &lt;backtrace_helper&gt;, trace_argument=0x7ff4cab0b730) at ../../../libgcc/unwind.inc:283#11 0x00007ff5083f6f46 in backtrace () from /lib64/libc.so.6#12 0x00007ff508324d52 in backtrace_and_maps () from /lib64/libc.so.6#13 0x00007ff5083777ff in __libc_message () from /lib64/libc.so.6#14 0x00007ff50837d06e in malloc_printerr () from /lib64/libc.so.6#15 0x00007ff50837d32c in malloc_consolidate () from /lib64/libc.so.6#16 0x00007ff50837e588 in _int_malloc () from /lib64/libc.so.6#17 0x00007ff508380710 in malloc () from /lib64/libc.so.6#18 0x00007ff508c59258 in operator new (sz=sz@entry=1024) at ../../../../libstdc++-v3/libsupc++/new_op.cc:50#19 0x00007ff50a0ccc0d in allocate (this=0x7ff4b085a878, __n=&lt;optimized out&gt;) at /usr/local/gcc-5.5.0/include/c++/5.5.0/ext/new_allocator.h:104#20 allocate (__a=..., __n=&lt;optimized out&gt;) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/alloc_traits.h:491#21 _M_allocate (this=0x7ff4b085a878, __n=&lt;optimized out&gt;) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/stl_vector.h:170#22 std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;::_M_emplace_back_aux&lt;std::__cxx11::b---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---asic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;&amp;) (this=0x7ff4b085a878) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/vector.tcc:412#23 0x00007ff4fdaab81d in push_back ( __x=&lt;unknown type in /data01/zjgrp/zjv8cs2/lib/libjsoncppD.so, CU 0x2217a, DIE 0x35d11&gt;, this=0x7ff4b085a878) at /usr/local/gcc-5.5.0/include/c++/5.5.0/bits/stl_vector.h:932#24 Json::Value::resolveReference (this=0x7ff4b085a870, key=0x7ff4c428ca30 &quot;list_12_BONUS_INFO_LIST&quot;, isStatic=isStatic@entry=false) at src/lib_json/json_value.cpp:1052#25 0x00007ff4fdaab947 in Json::Value::operator[] (this=&lt;optimized out&gt;, key=&lt;optimized out&gt;) at src/lib_json/json_value.cpp:1034#26 0x00007ff4fe2f820f in sdl::JsonEncoder::PutListBegin (this=0x7ff4af3479d0, szListName=0x7ff4d0880501 &quot;BONUS_INFO_LIST&quot;, iSize=&lt;optimized out&gt;) at src/codec_json.cpp:1054#27 0x00007ff5012cd013 in sdl::visitor::encode_list_vector (pEncoder=0x7ff4af3479d0, sdltype=&lt;optimized out&gt;, pVal=0x7ff4cab0c830, name=0x7ff4d0880501 &quot;BONUS_INFO_LIST&quot;) at src/sdl_stream.cpp:897#28 0x00007ff5012ccdf5 in sdl::visitor::encode_struct (pEncoder=0x7ff4af3479d0, sdltype=&lt;optimized out&gt;, pVal=0x7ff4cab0c710, name=&lt;optimized out&gt;) at src/sdl_stream.cpp:874#29 0x00007ff4d0fcd31d in visit (p=0x7ff4cab0c710, sdltype=11, this=0x7ff4cab0c530) at /data01/zjgrp/zjv8bm/ob_rel/include/public/sdl/sdl_stream.h:311#30 operator&lt;&lt; (v=..., this=0x7ff4cab0c530) at /data01/zjgrp/zjv8bm/ob_rel/include/public/sdl/sdl_stream.h:365#31 charging::dump_xdr&lt;MRatmsInterfaceRatingDef::SRatingUpdate&gt; (data=..., level=1) at ../base/dump_xdr.h:16#32 0x00007ff4d0fdf43d in charging::CMdbOperatorChain::Update (this=0x7ff4c429f130, xdr=..., subXdr=..., baseData=...) at mdb_operate_chain.cpp:99#33 0x00007ff4d274325a in charging::CRevRatingAlgo::risk_addup_charge (this=this@entry=0x7ff4c41feef0, xdr=..., subXdr=..., pData=pData@entry=0x7ff4cab0cef0) at RiskRatingAlgo.cpp:336#34 0x00007ff4d2743b4d in charging::RiskRatingAddupAlgo::DoIt (this=0x7ff4c41feef0, xdr=..., subXdr=..., pData=0x7ff4cab0cef0) at RiskRatingAlgo.cpp:443#35 0x00007ff4d274afca in charging::CRatingInterface::rating_algo (this=this@entry=0x7ff4cab0d787, listXdr=..., algoType=algoType@entry=7, pSession=pSession@entry=0x7ff4c4019b90) at ratingInterface.cpp:57#36 0x00007ff4d27561c7 in MRatingApp::CIRatingAppImp::risk_addup (this=this@entry=0x7ff4cab0d7f0, pSession=pSession@entry=0x7ff4c4019b90, listXdr=..., cErrorMsg=...) at rating_sdl_i.cpp:78#37 0x00007ff4d2752fcf in MRATINGAPP_IRATINGAPP_RISK_ADDUP (pSession=pSession@entry=0x7ff4c4019b90, in=..., out=..., pErrorMsg=pErrorMsg@entry=0x1d79c18) at rating_imp.cpp:184#38 0x00007ff4db5d145f in tp::AppLib::ExecIntf (---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- funcHandle=funcHandle@entry=0x7ff4d2752d60 &lt;MRATINGAPP_IRATINGAPP_RISK_ADDUP(sdl::SdlSession*, sdl::CSdlBasicParamObject&amp;, sdl::CSdlBasicParamObject&amp;, sdl::CSdlErrorMsg*)&gt;, pIntfName=pIntfName@entry=0x1a40270 &quot;MRATINGAPP_IRATINGAPP_RISK_ADDUP&quot;, pSession=pSession@entry=0x7ff4c4019b90, paramIn=..., paramOut=..., cErrorMsg=...) at tp_interface.cpp:38#39 0x00007ff4db5d7fad in tp::Service::ExecService (this=this@entry=0x1a38b40, pRet=pRet@entry=0x1d7aec8, pAttr=pAttr@entry=0x1d7aef0) at tp_service.cpp:74#40 0x00007ff4f81a5d1f in tp::RpcReqProcess::ProcessRpcTask (this=this@entry=0x1d79970, pReqMsg=pReqMsg@entry=0x7ff4cab0e250, pResMsg=pResMsg@entry=0x7ff4cab0e260, pService=0x1a38b40) at rpc_proc.cpp:121#41 0x00007ff4f81a625f in tp::RpcReqProcess::ProcessRpcReq (this=this@entry=0x1d79970, pRpcReq=pRpcReq@entry=0x7ff4cab0e250, pRpcResp=pRpcResp@entry=0x7ff4cab0e260) at rpc_proc.cpp:208#42 0x00007ff4f81a6aa4 in tp::RpcReqProcess::Run (this=0x1d79970, inMsg=..., outMsg=...) at rpc_proc.cpp:62#43 0x00007ff4f81a2553 in tp::SCB4DirectProc::OnReadable (this=0x1d8aa10, pChannel=0x7ff4b40020b0) at event_proc.cpp:39#44 0x00007ff506dc1394 in OnChannelEvent (ops=1, pChannel=0x7ff4b40020b0, this=0x1d841e0) at src/cdk_rpc_socket_server.cpp:109#45 cdk::rpc::SocketServer::SocketServerImpl::OnEvent (this=0x1d841e0, hSock=&lt;optimized out&gt;, ops=1, pArg=&lt;optimized out&gt;) at src/cdk_rpc_socket_server.cpp:87#46 0x00007ff507636cc4 in cdk::io::EventLoop2::EventCallback (fd=29, events=&lt;optimized out&gt;, arg=0x1d8a490) at src/linux/../cdk_os_io_eventloop2.h:93#47 0x00007ff50232ecbb in event_persist_closure () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#48 0x00007ff50232ee31 in event_process_active_single_queue () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#49 0x00007ff50232f100 in event_process_active () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#50 0x00007ff50232f79b in event_base_loop () from /data01/zjgrp/zjv8cs2/lib/libevent-2.0.so.5#51 0x00007ff507635f7a in cdk::io::EventLoop2::Run (this=0x1d8a490, timeout=&lt;optimized out&gt;) at src/linux/../cdk_os_io_eventloop2.h:184#52 0x00007ff506dc044c in cdk::rpc::SocketServer::Run (this=0x1d841c0, iTimeout=iTimeout@entry=5000) at src/cdk_rpc_socket_server.cpp:362#53 0x00007ff4f81a8c0e in tp::RpcServerRunnable::Run (this=0x1d84140) at rpc_server_imp.cpp:357#54 0x00007ff50a0dbde6 in cdk::Thread::Run (this=0x1d8caa0) at src/cdk_thread.cpp:118#55 0x00007ff50a0dc719 in cdk::ExecFunc (pData=0x1d8caa0) at src/cdk_thread.cpp:35#56 0x00007ff509a6f0a4 in start_thread () from /lib64/libpthread.so.0#57 0x00007ff5083ea04d in clone () from /lib64/libc.so.6 malloc原理分析libc库版本和源码1252_zjdev[/data01/zjgrp/zjdev]%ls -ltr /lib64/libc.so.6lrwxrwxrwx 1 root root 12 1月 23 2018 /lib64/libc.so.6 -&gt; libc-2.19.so glibc源码下载 API手册 malloc MT-Safe Multi Thread 多线程安全AS-Safe Async Singal 异步信号不安全AC-Safe Async Cancel 异步取消不安全 内存管理源码分析]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[limit限制]]></title>
    <url>%2F2019%2F01%2F17%2Flimit%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[系统调用ulimit1234567891011121314151617[root@zhangbb ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 3893max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 65535pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 65535virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 库函数 #include &lt;sys/time.h&gt; #include &lt;sys/resource.h&gt;int getrlimit(int resource, struct rlimit rlim);int setrlimit(int resource, const struct rlimit rlim); 12345678910111213141516171819202122232425262728293031323334#include &lt;sys/resource.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;int main()&#123; struct rlimit r; if(getrlimit(RLIMIT_AS, &amp;r) &lt; 0) &#123; perror(&quot;getrlimit error&quot;); return 0; &#125; printf(&quot;RLIMIT_AS cur %d, max %d\n&quot;, r.rlim_cur, r.rlim_max); if(getrlimit(RLIMIT_STACK, &amp;r) &lt; 0) &#123; perror(&quot;getrlimit error&quot;); return 0; &#125; printf(&quot;RLIMIT_STACK cur %d, max %d\n&quot;, r.rlim_cur, r.rlim_max); if(getrlimit(RLIMIT_MEMLOCK , &amp;r) &lt; 0) &#123; perror(&quot;getrlimit error&quot;); return 0; &#125; printf(&quot;RLIMIT_MEMLOCK cur %d, max %d\n&quot;, r.rlim_cur, r.rlim_max); return 0;&#125;52_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%./testRLIMIT_AS cur -1, max -1RLIMIT_STACK cur -1, max -1RLIMIT_MEMLOCK cur 65536, max 65536 参考 getrusage获取运行进程使用资源]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[strace命令]]></title>
    <url>%2F2019%2F01%2F14%2Fstrace%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一个简单的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd; int i = 0; fd = open(&quot;./test.cpp&quot;, O_RDONLY); if(fd &lt; 5) i = 5; else i = 2; return i;&#125;g++ test.cpp -o teststrace -o test.strace ./testvim test.strace 1 execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 32 vars */]) = 0 2 brk(NULL) = 0x149b000 3 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d939000 4 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory) 5 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3 6 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=54597, ...&#125;) = 0 7 mmap(NULL, 54597, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb83d92b000 8 close(3) = 0 9 open(&quot;/usr/lib64/libstdc++.so.6&quot;, O_RDONLY|O_CLOEXEC) = 310 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 \262\5\0\0\0\0\0&quot;..., 832) = 83211 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=991616, ...&#125;) = 012 mmap(NULL, 3171168, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83d41200013 mprotect(0x7fb83d4fb000, 2093056, PROT_NONE) = 014 mmap(0x7fb83d6fa000, 40960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xe8000) = 0x7fb83d 6fa00015 mmap(0x7fb83d704000, 82784, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb83d70400 016 close(3) = 017 open(&quot;/usr/lib64/libm.so.6&quot;, O_RDONLY|O_CLOEXEC) = 318 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\20S\0\0\0\0\0\0&quot;..., 832) = 83219 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1137016, ...&#125;) = 020 mmap(NULL, 3150120, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83d110000 21 mprotect(0x7fb83d211000, 2093056, PROT_NONE) = 022 mmap(0x7fb83d410000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x100000) = 0x7fb83d 41000023 close(3) = 024 open(&quot;/usr/lib64/libgcc_s.so.1&quot;, O_RDONLY|O_CLOEXEC) = 325 read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\220*\0\0\0\0\0\0&quot;..., 832) = 83226 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=88776, ...&#125;) = 027 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92a000 28 mmap(NULL, 2184192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83cefa00029 mprotect(0x7fb83cf0f000, 2093056, PROT_NONE) = 030 mmap(0x7fb83d10e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14000) = 0x7fb83d1 0e00031 close(3) = 032 open(&quot;/usr/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 333 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\340$\2\0\0\0\0\0&quot;..., 832) = 83234 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2151672, ...&#125;) = 035 mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb83cb2d00036 mprotect(0x7fb83ccef000, 2097152, PROT_NONE) = 037 mmap(0x7fb83ceef000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x7fb83 ceef00038 mmap(0x7fb83cef5000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb83cef500 039 close(3) = 040 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92900041 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92700042 arch_prctl(ARCH_SET_FS, 0x7fb83d927740) = 043 mprotect(0x7fb83ceef000, 16384, PROT_READ) = 044 mprotect(0x7fb83d10e000, 4096, PROT_READ) = 045 mprotect(0x7fb83d410000, 4096, PROT_READ) = 046 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb83d92600047 mprotect(0x7fb83d6fa000, 32768, PROT_READ) = 048 mprotect(0x600000, 4096, PROT_READ) = 049 mprotect(0x7fb83d93a000, 4096, PROT_READ) = 050 munmap(0x7fb83d92b000, 54597) = 051 open(&quot;./test.cpp&quot;, O_RDONLY) = 352 exit_group(5) = ?53 +++ exited with 5 +++#格式为：系统调用的名称( 参数... ) = 返回值 错误标志和描述#line1: 对于命令行下执行的程序，execve(或exec系列调用中的某一个)均为strace输出系统调用中的第一个。strace首先调用fork 或clone函数新建一个子进程，然后在子进程中调用exec载入需要执行的程序(这里为./test)#line2: 以NULL作为参数调用brk，返回值为内存管理的起始地址(若在子进程中调用malloc，则从 0x149b000 地址开始分配空间)#line4: 使用mmap函数进行匿名内存映射，以此来获取4096bytes内存空间，该空间起始地址为 0x7fb83d939000#line3: 调用access函数检验/etc/ld.so.preload是否存在#line5: 打开/etc/ld.so.cache, 返回文件描述符3#line6: fstat函数获取/etc/ld.so.cache文件信息#line7: 调用mmap函数将/etc/ld.so.cache文件映射至内存#line8: close关闭文件描述符为3指向的/etc/ld.so.cache文件#line10: 调用read，从/usr/lib64/libstdc++.so.6该libc库文件中读取832bytes，即读取ELF头信息#line13: 使用 mprotect 函数对 0x7fb83d4fb000 起始的2093056 进行保护(PROT_NONE表示不能访问，PROT_READ表示可以读取)#line50: 调用 munmap 函数，将/etc/ld.so.cache文件从内存中去映射，与Line 4的mmap对应#line51: 对应源码中使用到的唯一的系统调用 open 函数，使用其打开./test.cpp文件#line532: 返回5，退出 几乎都用于进行进程初始化工作：装载被执行程序、载入libc函数库、设置内存映射等。源码中的if语句或其他代码在相应strace输出中并没有体现，因为它们并没有唤起系统调用。strace只关心程序与系统之间产生的交互，因而strace不适用于程序逻辑代码的排错和分析。 命令选项 -T: 记录各个系统调用花费的时间，精确到微秒-r: 以第一个系统调用(通常为execve)计时，精确到微秒-t: 时：分：秒-tt: 时：分：秒 . 微秒-ttt: 计算机纪元以来的秒数 . 微秒-p: 跟踪正在运行的进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@zhangbb test]# strace -Tr ./test 0.000000 execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 32 vars */]) = 0 &lt;0.000442&gt; 0.000687 brk(NULL) = 0xd49000 &lt;0.000009&gt; 0.000059 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5783000 &lt;0.000012&gt; 0.000067 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory) &lt;0.000024&gt; 0.000098 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000015&gt; 0.000071 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=54597, ...&#125;) = 0 &lt;0.000010&gt; 0.000072 mmap(NULL, 54597, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f57a5775000 &lt;0.000060&gt; 0.000079 close(3) = 0 &lt;0.000009&gt; 0.000044 open(&quot;/usr/lib64/libstdc++.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000036&gt; 0.000057 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 \262\5\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000014&gt; 0.000043 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=991616, ...&#125;) = 0 &lt;0.000010&gt; 0.000032 mmap(NULL, 3171168, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a525c000 &lt;0.000017&gt; 0.000043 mprotect(0x7f57a5345000, 2093056, PROT_NONE) = 0 &lt;0.000015&gt; 0.000043 mmap(0x7f57a5544000, 40960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xe8000) = 0x7f57a5544000 &lt;0.000014&gt; 0.000042 mmap(0x7f57a554e000, 82784, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f57a554e000 &lt;0.000012&gt; 0.000041 close(3) = 0 &lt;0.000009&gt; 0.000041 open(&quot;/usr/lib64/libm.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000015&gt; 0.000040 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\20S\0\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000011&gt; 0.000029 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1137016, ...&#125;) = 0 &lt;0.000010&gt; 0.000029 mmap(NULL, 3150120, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a4f5a000 &lt;0.000012&gt; 0.000029 mprotect(0x7f57a505b000, 2093056, PROT_NONE) = 0 &lt;0.000013&gt; 0.000028 mmap(0x7f57a525a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x100000) = 0x7f57a525a000 &lt;0.000012&gt; 0.000041 close(3) = 0 &lt;0.000009&gt; 0.000036 open(&quot;/usr/lib64/libgcc_s.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000014&gt; 0.000037 read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\220*\0\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000010&gt; 0.000028 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=88776, ...&#125;) = 0 &lt;0.000009&gt; 0.000037 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5774000 &lt;0.000011&gt; 0.000032 mmap(NULL, 2184192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a4d44000 &lt;0.000022&gt; 0.000040 mprotect(0x7f57a4d59000, 2093056, PROT_NONE) = 0 &lt;0.000014&gt; 0.000030 mmap(0x7f57a4f58000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14000) = 0x7f57a4f58000 &lt;0.000015&gt; 0.000049 close(3) = 0 &lt;0.000009&gt; 0.000033 open(&quot;/usr/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000015&gt; 0.000033 read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\340$\2\0\0\0\0\0&quot;..., 832) = 832 &lt;0.000010&gt; 0.000028 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2151672, ...&#125;) = 0 &lt;0.000009&gt; 0.000029 mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f57a4977000 &lt;0.000012&gt; 0.000028 mprotect(0x7f57a4b39000, 2097152, PROT_NONE) = 0 &lt;0.000014&gt; 0.000028 mmap(0x7f57a4d39000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x7f57a4d39000 &lt;0.000015&gt; 0.000045 mmap(0x7f57a4d3f000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f57a4d3f000 &lt;0.000012&gt; 0.000037 close(3) = 0 &lt;0.000009&gt; 0.000050 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5773000 &lt;0.000010&gt; 0.000039 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5771000 &lt;0.000014&gt; 0.000050 arch_prctl(ARCH_SET_FS, 0x7f57a5771740) = 0 &lt;0.000010&gt; 0.000169 mprotect(0x7f57a4d39000, 16384, PROT_READ) = 0 &lt;0.000014&gt; 0.000040 mprotect(0x7f57a4f58000, 4096, PROT_READ) = 0 &lt;0.000012&gt; 0.000054 mprotect(0x7f57a525a000, 4096, PROT_READ) = 0 &lt;0.000013&gt; 0.000877 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f57a5770000 &lt;0.000013&gt; 0.000090 mprotect(0x7f57a5544000, 32768, PROT_READ) = 0 &lt;0.000014&gt; 0.000033 mprotect(0x600000, 4096, PROT_READ) = 0 &lt;0.000013&gt; 0.000032 mprotect(0x7f57a5784000, 4096, PROT_READ) = 0 &lt;0.000014&gt; 0.000029 munmap(0x7f57a5775000, 54597) = 0 &lt;0.000024&gt; 0.000156 open(&quot;./test.cpp&quot;, O_RDONLY) = 3 &lt;0.000030&gt; 0.000097 exit_group(5) = ? 0.000147 +++ exited with 5 +++]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gdb打印容器]]></title>
    <url>%2F2019%2F01%2F14%2Fgdb%E6%89%93%E5%8D%B0%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[打印STL容器GDB在一些环境上不能直接打印容器, 需要指定容器参数如vector._M_impl._M_start，一个个打印 gdbinit将以下内容追加到~/.gdbinit文件的尾部，然后再启动gdb，如果gdb已经启动，则可以source ~/.gdbinit来立即生效123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683# # STL GDB evaluators/views/utilities - 1.03## The new GDB commands: # are entirely non instrumental # do not depend on any &quot;inline&quot;(s) - e.g. size(), [], etc# are extremely tolerant to debugger settings# # This file should be &quot;included&quot; in .gdbinit as following:# source stl-views.gdb or just paste it into your .gdbinit file## The following STL containers are currently supported:## std::vector&lt;T&gt; -- via pvector command# std::list&lt;T&gt; -- via plist or plist_member command# std::map&lt;T,T&gt; -- via pmap or pmap_member command# std::multimap&lt;T,T&gt; -- via pmap or pmap_member command# std::set&lt;T&gt; -- via pset command# std::multiset&lt;T&gt; -- via pset command# std::deque&lt;T&gt; -- via pdequeue command# std::stack&lt;T&gt; -- via pstack command# std::queue&lt;T&gt; -- via pqueue command# std::priority_queue&lt;T&gt; -- via ppqueue command# std::bitset&lt;n&gt; -- via pbitset command# std::string -- via pstring command# std::widestring -- via pwstring command# void * array[] -- via parray command this command for print content infomantion of point array## The end of this file contains (optional) C++ beautifiers# Make sure your debugger supports $argc## Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL# Inspired by intial work of Tom Malnar,# Tony Novac (PhD) / Cornell / Stanford,# Gilad Mishne (PhD) and Many Many Others.# Contact: dan_c_marinescu@yahoo.com (Subject: STL)## Modified to work with g++ 4.3 by Anders Elton# Also added _member functions, that instead of printing the entire class in map, prints a member.## std::vector&lt;&gt;#define pvector if $argc == 0 help pvector else set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start set $size_max = $size - 1 end if $argc == 1 set $i = 0 while $i &lt; $size printf &quot;elem[%u]: &quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end if $argc == 2 set $idx = $arg1 if $idx &lt; 0 || $idx &gt; $size_max printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max else printf &quot;elem[%u]: &quot;, $idx p *($arg0._M_impl._M_start + $idx) end end if $argc == 3 set $start_idx = $arg1 set $stop_idx = $arg2 if $start_idx &gt; $stop_idx set $tmp_idx = $start_idx set $start_idx = $stop_idx set $stop_idx = $tmp_idx end if $start_idx &lt; 0 || $stop_idx &lt; 0 || $start_idx &gt; $size_max || $stop_idx &gt; $size_max printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max else set $i = $start_idx while $i &lt;= $stop_idx printf &quot;elem[%u]: &quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end end if $argc &gt; 0 printf &quot;Vector size = %u\n&quot;, $size printf &quot;Vector capacity = %u\n&quot;, $capacity printf &quot;Element &quot; whatis $arg0._M_impl._M_start endenddocument pvector Prints std::vector&lt;T&gt; information. Syntax: pvector &lt;vector&gt; &lt;idx1&gt; &lt;idx2&gt; Note: idx, idx1 and idx2 must be in acceptable range [0..&lt;vector&gt;.size()-1]. Examples: pvector v - Prints vector content, size, capacity and T typedef pvector v 0 - Prints element[idx] from vector pvector v 1 2 - Prints elements in range [idx1..idx2] from vectorend## std::list&lt;&gt;#define plist if $argc == 0 help plist else set $head = &amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 2 printf &quot;elem[%u]: &quot;, $size p *($arg1*)($current + 1) end if $argc == 3 if $size == $arg2 printf &quot;elem[%u]: &quot;, $size p *($arg1*)($current + 1) end end set $current = $current._M_next set $size++ end printf &quot;List size = %u \n&quot;, $size if $argc == 1 printf &quot;List &quot; whatis $arg0 printf &quot;Use plist &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the list.\n&quot; end endenddocument plist Prints std::list&lt;T&gt; information. Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx Examples: plist l - prints list size and definition plist l int - prints all elements and list size plist l int 2 - prints the third element in the list (if exists) and list sizeenddefine plist_member if $argc == 0 help plist_member else set $head = &amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 3 printf &quot;elem[%u]: &quot;, $size p (*($arg1*)($current + 1)).$arg2 end if $argc == 4 if $size == $arg3 printf &quot;elem[%u]: &quot;, $size p (*($arg1*)($current + 1)).$arg2 end end set $current = $current._M_next set $size++ end printf &quot;List size = %u \n&quot;, $size if $argc == 1 printf &quot;List &quot; whatis $arg0 printf &quot;Use plist_member &lt;variable_name&gt; &lt;element_type&gt; &lt;member&gt; to see the elements in the list.\n&quot; end endenddocument plist_member Prints std::list&lt;T&gt; information. Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx Examples: plist_member l int member - prints all elements and list size plist_member l int member 2 - prints the third element in the list (if exists) and list sizeend## std::map and std::multimap#define pmap if $argc == 0 help pmap else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Map &quot; whatis $tree printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot; end if $argc == 3 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u].left: &quot;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p *($arg2*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 4 set $idx = $arg3 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u].left: &quot;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p *($arg2*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end if $argc == 5 set $idx1 = $arg3 set $idx2 = $arg4 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) set $valueLeft = *($arg1*)$value set $valueRight = *($arg2*)($value + sizeof($arg1)) if $valueLeft == $idx1 &amp;&amp; $valueRight == $idx2 printf &quot;elem[%u].left: &quot;, $i p $valueLeft printf &quot;elem[%u].right: &quot;, $i p $valueRight set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end printf &quot;Map size = %u\n&quot;, $tree_size endenddocument pmap Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well. Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap m - prints map size and definition pmap m int int - prints all elements and map size pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map sizeenddefine pmap_member if $argc == 0 help pmap_member else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Map &quot; whatis $tree printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot; end if $argc == 5 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u].left: &quot;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p (*($arg3*)$value).$arg4 if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 6 set $idx = $arg5 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u].left: &quot;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p (*($arg3*)$value).$arg4 set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end printf &quot;Map size = %u\n&quot;, $tree_size endenddocument pmap_member Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well. Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2 pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalueend## std::set and std::multiset#define pset if $argc == 0 help pset else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Set &quot; whatis $tree printf &quot;Use pset &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the set.\n&quot; end if $argc == 2 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u]: &quot;, $i p *($arg1*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 3 set $idx = $arg2 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u]: &quot;, $i p *($arg1*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\n&quot;, $ElementsFound end printf &quot;Set size = %u\n&quot;, $tree_size endenddocument pset Prints std::set&lt;T&gt; or std::multiset&lt;T&gt; information. Works for std::multiset as well. Syntax: pset &lt;set&gt; &lt;T&gt; &lt;val&gt;: Prints set size, if T defined all elements or just element(s) having val Examples: pset s - prints set size and definition pset s int - prints all elements and the size of s pset s int 20 - prints the element(s) with value = 20 (if any) and the size of send## std::dequeue#define pdequeue if $argc == 0 help pdequeue else set $size = 0 set $start_cur = $arg0._M_impl._M_start._M_cur set $start_last = $arg0._M_impl._M_start._M_last set $start_stop = $start_last while $start_cur != $start_stop p *$start_cur set $start_cur++ set $size++ end set $finish_first = $arg0._M_impl._M_finish._M_first set $finish_cur = $arg0._M_impl._M_finish._M_cur set $finish_last = $arg0._M_impl._M_finish._M_last if $finish_cur &lt; $finish_last set $finish_stop = $finish_cur else set $finish_stop = $finish_last end while $finish_first != $finish_stop p *$finish_first set $finish_first++ set $size++ end printf &quot;Dequeue size = %u\n&quot;, $size endenddocument pdequeue Prints std::dequeue&lt;T&gt; information. Syntax: pdequeue &lt;dequeue&gt;: Prints dequeue size, if T defined all elements Deque elements are listed &quot;left to right&quot; (left-most stands for front and right-most stands for back) Example: pdequeue d - prints all elements and size of dend## std::stack#define pstack if $argc == 0 help pstack else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = $size - 1 while $i &gt;= 0 p *($start_cur + $i) set $i-- end printf &quot;Stack size = %u\n&quot;, $size endenddocument pstack Prints std::stack&lt;T&gt; information. Syntax: pstack &lt;stack&gt;: Prints all elements and size of the stack Stack elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop) Example: pstack s - prints all elements and the size of send## std::queue#define pqueue if $argc == 0 help pqueue else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = 0 while $i &lt; $size p *($start_cur + $i) set $i++ end printf &quot;Queue size = %u\n&quot;, $size endenddocument pqueue Prints std::queue&lt;T&gt; information. Syntax: pqueue &lt;queue&gt;: Prints all elements and the size of the queue Queue elements are listed &quot;top to bottom&quot; (top-most element is the first to come on pop) Example: pqueue q - prints all elements and the size of qend## std::priority_queue#define ppqueue if $argc == 0 help ppqueue else set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start set $i = $size - 1 while $i &gt;= 0 p *($arg0.c._M_impl._M_start + $i) set $i-- end printf &quot;Priority queue size = %u\n&quot;, $size printf &quot;Priority queue capacity = %u\n&quot;, $capacity endenddocument ppqueue Prints std::priority_queue&lt;T&gt; information. Syntax: ppqueue &lt;priority_queue&gt;: Prints all elements, size and capacity of the priority_queue Priority_queue elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop) Example: ppqueue pq - prints all elements, size and capacity of pqend## std::bitset#define pbitset if $argc == 0 help pbitset else p /t $arg0._M_w endenddocument pbitset Prints std::bitset&lt;n&gt; information. Syntax: pbitset &lt;bitset&gt;: Prints all bits in bitset Example: pbitset b - prints all bits in bend## std::string#define pstring if $argc == 0 help pstring else printf &quot;String \t\t\t= \&quot;%s\&quot;\n&quot;, $arg0._M_data() printf &quot;String size/length \t= %u\n&quot;, $arg0._M_rep()._M_length printf &quot;String capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity printf &quot;String ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount endenddocument pstring Prints std::string information. Syntax: pstring &lt;string&gt; Example: pstring s - Prints content, size/length, capacity and ref-count of string send## std::wstring#define pwstring if $argc == 0 help pwstring else call printf(&quot;WString \t\t= \&quot;%ls\&quot;\n&quot;, $arg0._M_data()) printf &quot;WString size/length \t= %u\n&quot;, $arg0._M_rep()._M_length printf &quot;WString capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity printf &quot;WString ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount endenddocument pwstring Prints std::wstring information. Syntax: pwstring &lt;wstring&gt; Example: pwstring s - Prints content, size/length, capacity and ref-count of wstring send## C++ related beautifiers (optional)#set print pretty onset print object onset print static-members onset print vtbl onset print demangle onset demangle-style gnu-v3set print sevenbit-strings off## pointer array#define parray if $argc &lt; 1 help parray else if $argc == 1 set $i = 0 set $current = *($arg0 + $i) while $current != 0 printf &quot;[array element number: %u] \n&quot;, $i p *$current set $i++ set $current = *($arg0 + $i) end printf &quot;array size = %u\n&quot;, $i end if $argc == 2 printf &quot;arg1 is %u\n&quot;, $arg1 printf &quot;[array element number: %u] \n&quot;, $arg1 p *(*($arg0 + $arg1)) end if $argc == 3 set $i = $arg1 printf &quot; idx1 = %u, idx2 = %u \n&quot; , $i, $arg2 while $i &lt; $arg2 printf &quot;[array element number: %u] \n&quot;, $i p *(*($arg0 + $i)) set $i++ end printf &quot;array size = %u\n&quot;, $i end endenddocument parray Prints array infomation. Syntax: parray &lt;array&gt; [elemnum | [idx1, idx2]] Example: parray array parray array elenum parray array idx1 idx2end]]></content>
      <categories>
        <category>gdb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux自旋锁]]></title>
    <url>%2F2019%2F01%2F10%2Flinux%E8%87%AA%E6%97%8B%E9%94%81%2F</url>
    <content type="text"><![CDATA[自旋锁 读写自旋锁]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[thinking in c++ reflection]]></title>
    <url>%2F2019%2F01%2F08%2Fthinking-in-c-reflection%2F</url>
    <content type="text"><![CDATA[什么是反射Java是原生支持反射机制的，通过Class类可以通过名称获得类对象，进一步操作。Python也支持反射机制，可以通过globals()获取对象map，也可以通过inspect模块，提供了自省的方法。但是C++呢？C++原生不支持反射机制，RTTI（运行时类型识别）也仅仅提供了类型的判断。 开闭原则是设计模式的原则之一，对修改是封闭，对扩展开放。一般来说，需要我们对类进行抽象，针对抽象的类进行编程。许多的设计模式中，为了能够满足这一点，我们常常使用一个配置文件，映射字符串与类型。然后通过反射机制获得字符串对应的对象，然后自动装配已达到易于扩展的目的。 反射作用 获取类型的信息，包括属性、方法动态调用方法动态构造对象从程序集中获得类型 使用场景 序列化（Serialization 数据写磁盘）和数据绑定（Data Binding）远程方法调用（RMI）对象/关系数据映射（O/R mapping） 实现思路 使用map，映射字符串和生产函数每次构造新类型时，将生产函数注册到map中工厂函数通过map获得生产函数，建造不同的对象 code 参考boost qt Mirror C++ reflection library RTTR]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ping的过程]]></title>
    <url>%2F2018%2F12%2F26%2Fping%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对于Ping的过程，你真的了解吗？]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试练习]]></title>
    <url>%2F2018%2F12%2F22%2F%E9%9D%A2%E8%AF%95%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[http://blog.sina.com.cn/s/blog_aeec1b700102uwqb.html linux tsc 分布式锁 osi七层网络模型，五层网络模型，每次层分别有哪些协议死锁产生的条件， 以及如何避免死锁，银行家算法，产生死锁后如何解决如何判断链表有环虚拟机类加载机制，双亲委派模型，以及为什么要实现双亲委派模型虚拟机调优参数拆箱装箱的原理JVM垃圾回收算法CMS G1hashset和hashmap的区别，haspmap的底层实现put操作，扩容机制，currenthashmap如何解决线程安全,1.7版本以及1.8版本的不同md5加密的原理有多少种方法可以让线程阻塞，能说多少说多少synchronized和reetrantlock锁AQS同步器框架，countdowmlatch，cyclebarrier，semaphore，读写锁 02—二面 B-Tree索引，myisam和innodb中索引的区别BIO和NIO的应用场景讲讲threadlocal数据库隔离级别，每层级别分别用什么方法实现，三级封锁协议,共享锁排它锁，mvcc多版本并发控制协议，间隙锁数据库索引？B+树？为什么要建索引？什么样的字段需要建索引，建索引的时候一般考虑什么？索引会不会使插入、删除作效率变低，怎么解决？数据库表怎么设计的？数据库范式？设计的过程中需要注意什么？共享锁与非共享锁、一个事务锁住了一条数据，另一个事务能查吗？Spring bean的生命周期？默认创建的模式是什么？不想单例怎么办？ 03—三面 高并发时怎么限流线程池的拒接任务策略springboot的启动流程集群、负载均衡、分布式、数据一致性的区别与关系数据库如果让你来垂直和水平拆分，谁先拆分，拆分的原则有哪些(单表数据量多大拆)最后谈谈Redis、Kafka、 Dubbo，各自的设计原理和应用场景 头条一面 1.讲讲jvm运行时数据库区2.讲讲你知道的垃圾回收算法3.jvm内存模型jmm4.内存泄漏与内存溢出的区别 select、epool 的区别？底层的数据结构是什么？6.mysql数据库默认存储引擎，有什么优点7.优化数据库的方法，从sql到缓存到cpu到操作系统，知道多少说多少8.什么情景下做分表，什么情景下做分库9.linkedList与arrayList区别 适用场景10.array list是如何扩容的 volatile 关键字的作用？Java 内存模型？12.java lock的实现，公平锁、非公平锁13.悲观锁和乐观锁，应用中的案例，mysql当中怎么实现，java中的实现 02—头条二面 Java 内存分配策略？多个线程同时请求内存，如何分配？Redis 底层用到了哪些数据结构？使用 Redis 的 set 来做过什么？Redis 使用过程中遇到什么问题？搭建过 Redis 集群吗？如何分析“慢查询”日志进行 SQL/索引 优化？MySQL 索引结构解释一下？（B+ 树）MySQL Hash 索引适用情况？举下例子？ 03—头条三面 如何保证数据库与redis缓存一致的Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？如何保证 Redis 高并发、高可用？Redis 的主从复制原理，以及Redis 的哨兵原理？如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。MySQL数据库主从同步怎么实现？秒杀模块怎么设计的，如何压测，抗压手段]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2018%2F12%2F19%2FMakefile%2F</url>
    <content type="text"></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法和数据结构-树]]></title>
    <url>%2F2018%2F12%2F18%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树的类别二叉树、二叉搜索树、平衡二叉树、红黑树、B树、B+树、字典树 二叉树二叉树，插入有序的数据，会退化成链表，需要调整数据均匀分布，保证平衡性(搜索效率)书的查找性能取决于树的高度 二叉搜索树(BST)平衡二叉树(AVL)windows对进程地址空间的管理用到了AVL树 红黑树广泛用在C++的STL中, 如map和set. B树多路搜索树，每个节点可以拥有多于两个孩子节点。M路的B树最多有用M个孩子节点。 设计成多路是为了降低树的高度，但是无限多路时退化成有序数组。一般用于文件索引，为什么不用红黑树和有序数组？文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。B树索引可以每次加载一个节点，一步一步往下找。在内存中黑红树比B树效率高，但涉及到磁盘，B树更优。 B+树在B树基础上进行改造，数据都在叶子结点，同时叶子结点之间用指针形成链表。 为什么要这样设计？这也是和业务场景相关的，数据库中select数据，不一定只选一条，很多时候会选多条，比如按照id排序后选10条。如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。 选出7~19，在叶子节点中就可以找到。 字典树(Trie)用在统计和排序大量字符串，如自动机一个典型应用是前缀匹配，比如在我们输入时，搜索引擎会给予提示字典树]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库水平、垂直拆分]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[水平、垂直分库]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[死锁和银行家算法]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%AD%BB%E9%94%81%E5%92%8C%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MD5加密算法]]></title>
    <url>%2F2018%2F12%2F01%2FMD5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是MD5加密算法MD5消息摘要算法是一种被广泛使用的密码散列函数, 属Hash算法一类, MD5算法对输入任意长度的消息进行运行，产生一个128位(16字节)的散列值(hash value)。 应用场景文件一致性验证MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。 1251_zjdev[/data01/zjgrp/zjdev/users/zhangbb]%md5sum test.cpp 731b8735653acd4c4cdbd05883fe90d1 test.cpp 数字签名MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。 算法原理以下所描述的消息长度、填充数据都以位(Bit)为单位，字节序为小端字节。 数据填充对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满足X mod 512=448。根据此公式得出需要填充的数据长度。填充方法：在消息后面进行填充，填充第一位为1，其余为0。 添加消息长度在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。在此步骤进行完毕后，最终消息长度就是512的整数倍 数据处理准备需要用到的数据： 4个常数： A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476; 4个函数：F(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z); G(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z)); H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z)); 把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行 计算，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个 变量为最后的结果，即MD5值。 具体计算的实现较为复杂，建议查阅相关书籍，下面给出在C++上的实现代码。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#ifndef MD5H#define MD5H#include &lt;math.h&gt;#include &lt;Windows.h&gt;void ROL(unsigned int &amp;s, unsigned short cx); //32位数循环左移实现函数void ltob(unsigned int &amp;i); //B\L互转，接受UINT类型unsigned int* MD5(const char* mStr); //接口函数，并执行数据填充，计算MD5时调用此函数#endif#include &quot;MD5.h&quot;/*4组计算函数*/inline unsigned int F(unsigned int X, unsigned int Y, unsigned int Z)&#123; return (X &amp; Y) | ((~X) &amp; Z);&#125;inline unsigned int G(unsigned int X, unsigned int Y, unsigned int Z)&#123; return (X &amp; Z) | (Y &amp; (~Z));&#125;inline unsigned int H(unsigned int X, unsigned int Y, unsigned int Z)&#123; return X ^ Y ^ Z;&#125;inline unsigned int I(unsigned int X, unsigned int Y, unsigned int Z)&#123; return Y ^ (X | (~Z));&#125;/*4组计算函数结束*//*32位数循环左移实现函数*/void ROL(unsigned int &amp;s, unsigned short cx)&#123; if (cx &gt; 32)cx %= 32; s = (s &lt;&lt; cx) | (s &gt;&gt; (32 - cx)); return;&#125;/*B\L互转，接收UINT类型*/void ltob(unsigned int &amp;i)&#123; unsigned int tmp = i;//保存副本 byte *psour = (byte*)&amp;tmp, *pdes = (byte*)&amp;i; pdes += 3;//调整指针，准备左右调转 for (short i = 3; i &gt;= 0; --i) &#123; CopyMemory(pdes - i, psour + i, 1); &#125; return;&#125;/*MD5循环计算函数，label=第几轮循环（1&lt;=label&lt;=4），lGroup数组=4个种子副本，M=数据（16组32位数指针）种子数组排列方式: --A--D--C--B--，即 lGroup[0]=A; lGroup[1]=D; lGroup[2]=C; lGroup[3]=B;*/void AccLoop(unsigned short label, unsigned int *lGroup, void *M)&#123; unsigned int *i1, *i2, *i3, *i4, TAcc, tmpi = 0; //定义:4个指针； T表累加器； 局部变量 typedef unsigned int(*clac)(unsigned int X, unsigned int Y, unsigned int Z); //定义函数类型 const unsigned int rolarray[4][4] = &#123; &#123; 7, 12, 17, 22 &#125;, &#123; 5, 9, 14, 20 &#125;, &#123; 4, 11, 16, 23 &#125;, &#123; 6, 10, 15, 21 &#125; &#125;;//循环左移-位数表 const unsigned short mN[4][16] = &#123; &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 &#125;, &#123; 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12 &#125;, &#123; 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2 &#125;, &#123; 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9 &#125; &#125;;//数据坐标表 const unsigned int *pM = static_cast&lt;unsigned int*&gt;(M);//转换类型为32位的Uint TAcc = ((label - 1) * 16) + 1; //根据第几轮循环初始化T表累加器 clac clacArr[4] = &#123; F, G, H, I &#125;; //定义并初始化计算函数指针数组 /*一轮循环开始（16组-&gt;16次）*/ for (short i = 0; i &lt; 16; ++i) &#123; /*进行指针自变换*/ i1 = lGroup + ((0 + i) % 4); i2 = lGroup + ((3 + i) % 4); i3 = lGroup + ((2 + i) % 4); i4 = lGroup + ((1 + i) % 4); /*第一步计算开始: A+F(B,C,D)+M[i]+T[i+1] 注:第一步中直接计算T表*/ tmpi = (*i1 + clacArr[label - 1](*i2, *i3, *i4) + pM[(mN[label - 1][i])] + (unsigned int)(0x100000000UL * abs(sin((double)(TAcc + i))))); ROL(tmpi, rolarray[label - 1][i % 4]);//第二步:循环左移 *i1 = *i2 + tmpi;//第三步:相加并赋值到种子 &#125; return;&#125;/*接口函数，并执行数据填充*/unsigned int* MD5(const char* mStr)&#123; unsigned int mLen = strlen(mStr); //计算字符串长度 if (mLen &lt; 0) return 0; unsigned int FillSize = 448 - ((mLen * 8) % 512); //计算需填充的bit数 unsigned int FSbyte = FillSize / 8; //以字节表示的填充数 unsigned int BuffLen = mLen + 8 + FSbyte; //缓冲区长度或者说填充后的长度 unsigned char *md5Buff = new unsigned char[BuffLen]; //分配缓冲区 CopyMemory(md5Buff, mStr, mLen); //复制字符串到缓冲区 /*数据填充开始*/ md5Buff[mLen] = 0x80; //第一个bit填充1 ZeroMemory(&amp;md5Buff[mLen + 1], FSbyte - 1); //其它bit填充0，另一可用函数为FillMemory unsigned long long lenBit = mLen * 8ULL; //计算字符串长度，准备填充 CopyMemory(&amp;md5Buff[mLen + FSbyte], &amp;lenBit, 8); //填充长度 /*数据填充结束*/ /*运算开始*/ unsigned int LoopNumber = BuffLen / 64; //以16个字为一分组，计算分组数量 unsigned int A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;//初始4个种子，小端类型 unsigned int *lGroup = new unsigned int[4]&#123; A, D, C, B&#125;; //种子副本数组,并作为返回值返回 for (unsigned int Bcount = 0; Bcount &lt; LoopNumber; ++Bcount) //分组大循环开始 &#123; /*进入4次计算的小循环*/ for (unsigned short Lcount = 0; Lcount &lt; 4;) &#123; AccLoop(++Lcount, lGroup, &amp;md5Buff[Bcount * 64]); &#125; /*数据相加作为下一轮的种子或者最终输出*/ A = (lGroup[0] += A); B = (lGroup[3] += B); C = (lGroup[2] += C); D = (lGroup[1] += D); &#125; /*转换内存中的布局后才能正常显示*/ ltob(lGroup[0]); ltob(lGroup[1]); ltob(lGroup[2]); ltob(lGroup[3]); delete[] md5Buff; //清除内存并返回 return lGroup;&#125; 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &quot;MD5.h&quot;int main(int argc, char **argv)&#123; char tmpstr[256], buf[4][10]; std::cout &lt;&lt; &quot;请输入要加密的字符串：&quot;; std::cin &gt;&gt; tmpstr; unsigned int* tmpGroup = MD5(tmpstr); sprintf_s(buf[0], &quot;%8X&quot;, tmpGroup[0]); sprintf_s(buf[1], &quot;%8X&quot;, tmpGroup[3]); sprintf_s(buf[2], &quot;%8X&quot;, tmpGroup[2]); sprintf_s(buf[3], &quot;%8X&quot;, tmpGroup[1]); std::cout &lt;&lt;&quot;MD5:&quot;&lt;&lt; buf[0] &lt;&lt; buf[1] &lt;&lt; buf[2] &lt;&lt; buf[3] &lt;&lt; std::endl; delete[] tmpGroup; return 0; //在此下断点才能看到输出的值&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++11特性]]></title>
    <url>%2F2018%2F11%2F28%2Fc-11%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[语法糖关键字auto auto声明的变量必须要初始化，否则编译器不能判断变量的类型auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数不会影响编译、运行效果 decltype类型指示符123int a = 1;int&amp; b = a;decltype(a) c = 2; nullptr 空指针, 类型是指针, 主要用于重载 function123456789101112131415161718192021222324#include &lt;functional&gt;int add(int a, int b)&#123; return a+b;&#125;class Add&#123; public: int operator()(int x,int y) &#123; return x+y; &#125;&#125;;int main()&#123; function&lt;int(int, int)&gt; f1 = add; // 函数 function&lt;int(int, int)&gt; f2 = Add(); // 类对象 function&lt;int(int, int)&gt; f2 = [](int a, int b)&#123; return a+b; &#125;; //lambda表达式 cout&lt;&lt; f1(a,b) &lt;&lt; f2(a,b) &lt;&lt; f3(a,b) &lt;&lt; endl;&#125; 范围for语句123456789vector&lt;int&gt; vct&#123;1,2,3,4,5&#125;;for(auto &amp;num : vct)&#123; num +1;&#125;for(auto num : vct)&#123; cout&lt;&lt; num &lt;&lt; endl;&#125; lambda表达式 text [ capture ] ( params ) mutable exception attribute -&gt; ret { body } [ capture ] ( params ) -&gt; ret { body } [ capture ] ( params ) { body } [ capture ] { body } [ capture ] desc [a,&amp;b] a变量以值的方式呗捕获，b以引用的方式被捕获 [this] 以值的方式捕获 this 指针 [&amp;] 以引用的方式捕获所有的外部自动变量 [=] 以值的方式捕获所有的外部自动变量 [] 不捕获外部的任何变量 123456int main()&#123; int boys=4, girls=3; auto totalChild = [=]()-&gt;int&#123;return boys+grils;&#125;; cout&lt;&lt; totalChild() &lt;&lt; endl;&#125; 右值引用：移动语义与完美转发有指针成员的类，拷贝构造时，会浪费资源。因此引入了移动语义。1234567891011121314&#123;a = b + c;# 等号左边是左值，等号右边是右值# 可以取地址,有名字的就是左值(&amp;a)，反之就是右值(a+b)&#125;MyString(MyString&amp;&amp; str) &#123; std::cout &lt;&lt; &quot;Move Ctor source from &quot; &lt;&lt; str._data &lt;&lt; endl; _len = str._len; _data = str._data; str._len = 0; str._data = NULL;&#125; std::movestl容器智能指针线程]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Big-O]]></title>
    <url>%2F2018%2F11%2F26%2FBig-O%2F</url>
    <content type="text"><![CDATA[from web]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--UnitTest++]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-UnitTest%2F</url>
    <content type="text"></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--sqlite3]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-sqlite3%2F</url>
    <content type="text"><![CDATA[SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。 教程]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--tcmalloc]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-tcmalloc%2F</url>
    <content type="text"><![CDATA[tcmalloctcmalloc是一个内存分配器，管理堆内存，主要影响malloc和free，用于降低频繁分配、释放内存造成的损耗,并且有效的控制内存碎片。 解决了什么问题实现原理]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--libevent]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-libevent%2F</url>
    <content type="text"></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源库应用--boost]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%BC%80%E6%BA%90%E5%BA%93%E5%BA%94%E7%94%A8-boost%2F</url>
    <content type="text"></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式存储简介]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx功能简介]]></title>
    <url>%2F2018%2F11%2F20%2Fnginx%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Nginx功能 反向代理 负载均衡 HTTP服务器 正向代理 反向代理负载均衡HTTP服务器正向代理]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fork/vfork/clone]]></title>
    <url>%2F2018%2F11%2F20%2Ffork-vfork-clone%2F</url>
    <content type="text"><![CDATA[fork/vfork/clone 系统调用 描述 fork fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容 vfork vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行 clone Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone fork12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; int count = 1; int child; child = fork( ); if(child &lt; 0) &#123; perror(&quot;fork error : &quot;); &#125; else if(child == 0) // fork return 0 in the child process because child can get hid PID by getpid( ) &#123; printf(&quot;This is son, his count is: %d (%p). and his pid is: %d\n&quot;, ++count, &amp;count, getpid()); &#125; else // the PID of the child process is returned in the parent’s thread of execution &#123; printf(&quot;This is father, his count is: %d (%p), his pid is: %d\n&quot;, count, &amp;count, getpid()); &#125; return EXIT_SUCCESS;&#125;output:This is father, his count is: 1 (0x7ffe32f99cc8), his pid is: 26649This is son, his count is: 2 (0x7ffe32f99cc8). and his pid is: 26650 父子两个进程的pid不同，堆栈和数据资源都是完全的复制子进程改变了count的值，而父进程中的count没有被改变子进程与父进程count的地址（虚拟地址）是相同的（注意他们在内核中被映射的物理地址不同） 写入时复制(Copy-on-write)完全复制包含4个步骤, 非常耗时 为子进程的页表分配页帧为子进程的页分配页帧初始化子进程的页表把父进程的页复制到子进程相应的页中 写时复制则父进程和子进程共享页帧而不是复制页帧, 页面的访问权限也设成只读, 当发生修改时产生页面出错异常(page_fault int14)中断,此时CPU会执行系统提供的异常处理函数do_wp_page()来解决这个异常. do_wp_page()会对这块导致写入异常中断的物理页面进行取消共享操作,为写进程复制一新的物理页面, 使父进程A和子进程B各自拥有一块内容相同的物理页面. vfork123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; int count = 1; int child; // child = vfork( ); printf(&quot;Before create son, the father&apos;s count is:%d\n&quot;, count); if((child = vfork())&lt; 0) &#123; perror(&quot;fork error : &quot;); &#125; else if(child == 0) // fork return 0 in the child process because child can get hid PID by getpid( ) &#123; printf(&quot;This is son, his count is: %d (%p). and his pid is: %d\n&quot;, ++count, &amp;count, getpid()); exit(0); &#125; else // the PID of the child process is returned in the parent’s thread of execution &#123; printf(&quot;After son, This is father, his count is: %d (%p), his pid is: %d\n&quot;, ++count, &amp;count, getpid()); exit(0); &#125; return EXIT_SUCCESS;&#125;output:Before create son, the father&apos;s count is:1This is son, his count is: 2 (0x7ffe635dbc18). and his pid is: 26921After son, This is father, his count is: 3 (0x7ffe635dbc18), his pid is: 26920 vfork创建出的子进程（线程）共享了父进程的count变量，2者的count指向了同一个内存 注意事项： 由vfork创造出来的子进程还会导致父进程挂起，除非子进程exit或者execve才会唤起父进程由vfok创建出来的子进程共享了父进程的所有内存，包括栈地址，直至子进程使用execve启动新的应用程序为止由vfork创建出来得子进程不应该使用return返回调用者，或者使用exit()退出，但是它可以使用_exit()函数来退出 fork/vfork 区别联系 func copy run fork 子进程拷贝父进程的数据段，代码段 执行次序不确定 vfork 子进程与父进程共享数据段 保证子进程先运行 clone1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int clone(int (fn)(void ), void *child_stack, int flags, void *arg); #include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define FIBER_STACK 8192int a;void * stack;int do_something(void*)&#123; printf(&quot;This is son, the pid is:%d, the a is: %d\n&quot;, getpid(), ++a); free(stack); exit(1);&#125;int main()&#123; void * stack; a = 1; stack = malloc(FIBER_STACK);//为子进程申请系统堆栈 if(!stack) &#123; printf(&quot;The stack failed\n&quot;); exit(0); &#125; printf(&quot;creating son thread!!!\n&quot;); clone(&amp;do_something, (char *)stack + FIBER_STACK, CLONE_VM|CLONE_VFORK, 0);//创建子线程 printf(&quot;This is father, my pid is: %d, the a is: %d\n&quot;, getpid(), a); exit(1);&#125;output:creating son thread!!!This is son, the pid is:27528, the a is: 2This is father, my pid is: 27527, the a is: 2 clone/fork/vfork区别与联系最终都是调用do_fork函数完成, 只是参数不同]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++关键字]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[volatile作用 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile 应用场景并行设备的硬件寄存器（如状态寄存器）12 一个中断服务子程序中访问到的变量12 多线程共享变量12 其他12 explicitextern 被 extern 限定的函数或变量是 extern 类型的 被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和连接的 extern用在变量声明中常常有这样一个作用，你在.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在.h中并用extern来声明。 extern 和 static(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面. static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙, 也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了 static 修改是全局和局部变量只是作用域不同, 生命周期是一样的。 12 typedefconst]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++函数指针]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[函数名到底是什么东西呢？ 常用函数调用1234567891011121314#include &lt;iostream&gt;using namespace std;void Func(int a); // void Func(int); 声明int main()&#123; Func(5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125; 函数指针变量的声明和使用1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void Func(int a); // 或void Func(int);void (*FuncP)(int); // 或void (*FuncP)(int a);int main()&#123; Func(5); (*Func)(5); // 一般不这样写 FuncP = &amp;Func; (*FuncP)(5); FuncP(5); FuncP = Func; FuncP(5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125; 为了书写与数学函数形式一样方便, C语言的设计者允许如下操作: FuncP 和 Func是一样的，都是函数指针 (*Func)(5) = Func(5), 与数学函数形式一样 FunP函数指针变量也可以FunP(10)的形式来调用 赋值时，即可FunP=&amp;Func形式，也可FunP=MyFun 定义函数的指针类型1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef int* INTP; // 定义一个类型void Func(int a); // 声明一个函数typedef void (*FuncType)(int); // 定义一个函数指针类型FuncType FuncP; // 声明一个函数指针变量int main()&#123; FuncP = Func; FuncP(5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125; 函数指针作为参数1234567891011121314151617181920#include &lt;iostream&gt;using namespace std; void Func(int a); typedef void (*FuncType)(int); int int CallFunc(FuncType p, int);(FuncType p, int a);int main()&#123; CallFunc(Func, 5); return 0;&#125;void Func(int a)&#123; cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt;endl;&#125;int CallFunc(FuncType p, int)&#123; p(a);&#125; 地址跳转1(*(void (*)(void))(0x30700000))(); (void ()(void)) 转化为一个函数指针fp, 上面表达式同 (fp)()]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++实现final]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E5%AE%9E%E7%8E%B0final%2F</url>
    <content type="text"><![CDATA[有时候我们希望一个类不能被继承，这种类称为final类，一个类如果有一个虚拟私有继承的基类，那么该类不能被继承。在C++11标准之前要实现这种技术，需要巧妙地利用一些细节首先我们要明确以下几点： 类的构造函数或析析构函数声明为私有的，那么该类不能被继承，但同时该类也不能使用派生类只能访问基类的公有成员和保护成员，如果是私有继承，基类中所有成员到子类中将成为私有的，子类的派生类也即子类的子类只能访问其直接父类的公有成员或保护成员，不能访问最原始基类的任何成员虚继承时, 由最终子类构造基类 123456789101112class FinalBase&#123;protected: //FinalBase()&#123;&#125; //~FinalBase()&#123;&#125;&#125;;class Filal : virtual private FinalBase&#123;public: Filal() &#123; cout&lt;&lt;&quot;final class.&quot;&lt;&lt;endl; &#125;&#125;; Final 就是一个final类, 不能被继承。gcc4.7以前有些版本编译器需要声明保护的基类构造或析构。 在C++11标准中，引入了final关键字，实现就简单多了。 123class Test final&#123;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++菱形继承]]></title>
    <url>%2F2018%2F11%2F19%2Fc-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[菱形继承是什么封装，继承，多态，这是C++语言的三大特性，而每次在谈到继承时不可避免的要谈到一个问题：菱形继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;class Base&#123;public: Base() &#123; cout&lt;&lt;&quot;Base&quot;&lt;&lt;endl; &#125; ~Base() &#123; cout&lt;&lt;&quot;~Base&quot;&lt;&lt;endl; &#125; void show()&#123; cout &lt;&lt; &quot;Base::show a=&quot; &lt;&lt; a &lt;&lt; endl; &#125; int a=0;&#125;;class A : public Base&#123;public: A() &#123; cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;&quot;~A&quot;&lt;&lt;endl; &#125;&#125;;class B : public Base&#123;public: B() &#123; cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; &#125; ~B() &#123; cout&lt;&lt;&quot;~B&quot;&lt;&lt;endl; &#125;&#125;;class C : public A, public B&#123;public: C() &#123; cout&lt;&lt;&quot;C&quot;&lt;&lt;endl; &#125; ~C() &#123; cout&lt;&lt;&quot;~C&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; C c; cout&lt;&lt; &quot;sizeof(Base)=&quot;&lt;&lt; sizeof(Base) &lt;&lt; endl; cout&lt;&lt; &quot;sizeof(C)=&quot;&lt;&lt; sizeof(c) &lt;&lt; endl;&#125;// output: BaseABaseBCsizeof(Base)=4sizeof(C)=8~C~B~Base~A~Base 从输出结果来看, 构造顺序按声明的顺序，C类的大小8是有2个Base对象。当用C对象调用show方法，会产生“二义性”问题。 域限定方式可解决：12C c;c.A::show(); 还有就可以使用虚继承的方式 虚继承虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态。对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象，共享基类子对象称为虚基类。虚基类用virtual声明继承关系就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Base&#123;public: Base() &#123; cout&lt;&lt;&quot;Base&quot;&lt;&lt;endl; &#125; ~Base() &#123; cout&lt;&lt;&quot;~Base&quot;&lt;&lt;endl; &#125; void show()&#123; cout &lt;&lt; &quot;Base::show a=&quot; &lt;&lt; a &lt;&lt; endl; &#125; int a=0;&#125;;class A : virtual public Base&#123;public: A() &#123; cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;&quot;~A&quot;&lt;&lt;endl; &#125;&#125;;class B : virtual public Base&#123;public: B() &#123; cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; &#125; ~B() &#123; cout&lt;&lt;&quot;~B&quot;&lt;&lt;endl; &#125;&#125;;class C : public A, public B&#123;public: C() &#123; cout&lt;&lt;&quot;C&quot;&lt;&lt;endl; &#125; ~C() &#123; cout&lt;&lt;&quot;~C&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; C c; cout&lt;&lt; &quot;sizeof(Base)=&quot;&lt;&lt; sizeof(Base) &lt;&lt; endl; cout&lt;&lt; &quot;sizeof(C)=&quot;&lt;&lt; sizeof(c) &lt;&lt; endl;&#125;// output:BaseABCsizeof(Base)=4sizeof(C)=24~C~B~A~Base 输出24 = (2个8字节的C类虚基指针) + sizeof(A)+sizeof(B) = 16 + 4 + 4 典型应用123class istream : virtual public ios&#123;...&#125;;class ostream : virtual public ios&#123;...&#125;;class iostream : public istream, public ostream&#123;...&#125;; 注意 虚继承只是解决了菱形继承中派生类多个基类内存拷贝的问题，并没有解决多重继承的二义性问题 通常每个类只会初始化自己的直接基类，如果不按虚继承处理，那么在菱形继承中会出现基类被初始多次的情况。在虚继承中，对初始化进行了特殊处理，由最底层派生类的构造函数初始化虚基类]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人能力总结]]></title>
    <url>%2F2018%2F11%2F16%2F%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[优缺点阐述，也作为个人能力提升的计划。 决策能力决策正确与错误, 会达到、超出、背离预期结果，需要提升分析和判断能力。 时间管理合理安排和利用时间，提高工作效率。工作繁琐, 测试问题，需求讨论，代码开发，一天都很忙碌.掌握工作流程，讲究方法。QA：描述清楚背景和目的，很多时候就是低级的配置问题。discuss：不必要的讨论不参加dev：先文档后代码，理清思路，高质量，少bug。 沟通能力简单说先得搞明白对方意思。耐心观察和聆听，从对方表情和言语了解对方思路，再有效沟通。情绪化的负作用很大，影响沟通效果，在突发事件无法分析和决断，最终使工作开展困难。QA：”让我测这测那，我TMD不测了!”, “还没解决，快点快点!”PSO：””DEV：”你们改是最合理的!” “太复杂，影响太大，改不了！”CUST：”为什么不能支持!, 你们这么干这么干…” 激励技巧应变能力驾驭能力组织和协调能力的体现, 为有效完成目标, 需要调动所有成员积极性。首先要提升自己的语言组织和宣导能力，提升自己实操技能，敢于承担和付出， 取得大家认可。 培训能力定期对自己总结和分析，提升自己语言组织和表达能力，将自己知识和经验分享 学习能力自我反思，学习别人优点，更多的技能知识]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[缓存算法]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[LRU算法算法原理全称Least Recently Used, 也就是最近最少使用, 是一种内存管理算法, 最早应用于Linux系统。基于一种假设：长期不被使用的数据, 在未来用到的几率不大。因此当数据占据一定阈值时，移除掉最近最少被使用的数据。 哈希表是由若干个Key-Value所组成。在“逻辑”上，Key-Value是无所谓排列顺序的。在哈希链表当中，这些Key-Value不再是彼此无关的存在，而是被一个链条串了起来。每一个Key-Value都具有它的前驱Key-Value、后继Key-Value，就像双向链表中的节点一样。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库设计三范式]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库设计三范式为了建立冗余小、结构合理的数据库，设计数据库必须遵循一定的原则。实际工最常用的三范式： 第一范式(确保每列保持原子性)第一范式是最基本的范式，表中的所有字段都是不可分割的原子值。 例如将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式 第二范式(确保表中每列都和主键相关)第二范式在第一范式的基础上，确保表中每一列都与主键相关，而不能与主键的某一部分相关(主要针对联合主键)。 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示: 订单编号 商品编号 商品名称 价格 客户 联系方式 001 1 车 10000 张三 88888888 002 2 帽子 5 李四 99999999 这个表中是以订单编号和商品编号作为联合主键。在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关, 所以在这里违反了第二范式的设计原则。 如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美订单信息表 订单编号 客户 联系方式 001 张三 88888888 002 李四 99999999 订单项目表 订单编号 商品编号 数量 001 1 1 002 2 1 商品信息表 商品编号 商品名称 价格 1 车 10000 2 帽子 5 这样设计，在很大程度上减小了数据库的冗余。 第三范式(确保每列都是和主键直接相关，而不是间接相关)第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 传递函数依赖：假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，依赖A-〉C是传递依赖。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 理解 1NF是对属性的原子性约束，要求属性具有原子性，不可再分解。通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计 2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性。数据记录不重复冗余 3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余 其他 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖） 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源协议区别]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[详细区别]]></content>
      <categories>
        <category>3rd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式锁实现]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之CAP理论(1)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8BCAP%E7%90%86%E8%AE%BA-1%2F</url>
    <content type="text"><![CDATA[CAP理论2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。 CAP理论为：一个分布式系统最多只能同时满足一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)这三项中的两项。 Consistency一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。 对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。 一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。 Availability可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间 对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。 Partition tolerance分区容错性指“the system continues to operate despite arbitrary message lossor failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。 简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。 CAP理论中的CA和数据库事务中ACID的CA并完全是同一回事儿. 两者之中的A都是C都是一致性(Consistency).CAP中的A指的是可用性 (Availability),而ACID中的A指的是原子性(Atomicity),切勿混为一谈. CAP权衡CA without P分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。 比如我们熟知的关系型数据库，如My Sql和Oracle就是保证了可用性和数据一致性，但是他并不是个分布式系统。一旦关系型数据库要考虑主备同步、集群部署等就必须要把P也考虑进来。 CP without A如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。 一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况,就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。 设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。 无论是像Redis、HBase这种分布式存储系统，还是像Zookeeper这种分布式协调组件。数据的一致性是他们最最基本的要求。一个连数据一致性都保证不了的分布式存储要他有何用？ 在我的Zookeeper介绍（二）——Zookeeper概述一文中其实介绍过zk关于CAP的思考，这里再简单回顾一下： ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持 同步、一致。所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了。 AP without C要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。 这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。 你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的(但是可能实际已经没票了)，你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。 但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。 对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之一致性算法Raft(6)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Raft-6%2F</url>
    <content type="text"><![CDATA[前言Raft 也是一个 易于理解一致性算法，和 Paxos 目标相同, 区别在于选举的 具体过程 不同。 什么是Raft协议Raft 协议组织的集群中有三类角色： Leader（领袖） Follower（群众） Candidate（候选人） 一个 Server 进程在某一时刻，只能是其中 一种类型，但这不是固定的。不同的时刻，它可能拥有不同的类型，一个 Server 进程的类型是如何改变的，后面会有解释。 就像一个民主社会，领袖由民众投票选出。刚开始没有 领袖，所有集群中的 参与者 都是 群众，那么首先开启一轮大选。在大选期间 所有群众 都能参与竞选，这时所有群众的角色就变成了 候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除 领袖 的 候选人 又变回 群众角色 服从领袖领导。 这里提到一个概念 「任期」，用术语 Term 表达。关于 Raft 协议的核心概念和术语就这么多，而且和现实民主制度非常匹配，所以很容易理解。 三类角色的变迁图如下： Leader选举过程在极简的思维下，一个最小的 Raft 民主集群需要 三个参与者（如下图：A、B、C），这样才可能投出多数票。 初始状态 ABC 都是 Follower，然后发起选举这时有 三种 可能的情形发生。下图中前二种都能选出 Leader，第三种则表明 本轮投票无效（Split Votes）。对于第三种，每方都投给了自己，结果没有任何一方获得多数票。之后 每个参与方 随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。这里的关键就是随机timeout，最先从 timeout 中恢复发起投票的一方，向还在 timeout 中的另外两方 请求投票，这时它就只能投给自己，导致很快达成一致。 选出 Leader 后，Leader 通过 定期 向所有 Follower 发送 心跳信息 维持其统治。若 Follower 一段时间未收到 Leader 的 心跳，则认为 Leader 可能已经挂了，然后再次发起 选举 过程。 Leader对一致性的影响Raft 协议 强依赖 Leader 节点的 可用性，以确保集群 数据的一致性。数据的流向 只能从 Leader 节点向Follower 节点转移。具体过程如下： 当 Client 向集群 Leader 节点 提交数据 后，Leader 节点 接收到的数据 处于 未提交状态（Uncommitted） 接着 Leader 节点会 并发地 向所有 Follower 节点 复制数据 并 等待接收响应 集群中至少 超过半数 的节点 已接收 到数据后， Leader 再向 Client 确认数据 已接收 一旦向 Client 发出数据接收 Ack 响应后，表明此时 数据状态 进入 已提交（Committed），Leader 节点再向 Follower 节点发通知告知该 数据状态已提交 在这个过程中，主节点 可能在 任意阶段 挂掉，看下 Raft 协议如何针对不同阶段保障 数据一致性 的。 情形1数据到达 Leader 节点前，这个阶段 Leader 挂掉不影响一致性，不用多说。 情形2数据到达 Leader 节点，但未复制到 Follower 节点。这个阶段 Leader 挂掉，数据属于 未提交状态，Client 不会收到 Ack 会认为 超时失败 可安全发起 重试。 Follower 节点上没有该数据，重新选主 后 Client 重试 重新提交 可成功。原来的 Leader 节点 恢复 后作为Follower 加入集群，重新从 当前任期 的新 Leader 处 同步数据，强制保持和 Leader 数据一致。 情形3情形4情形5情形6情形7验证结果综上穷举分析了 最小集群（3 节点）面临的所有情况，可以看出 Raft 协议都能很好的应对 一致性问题，并且很容易理解。 小结Paxos 算法是 Leslie Lamport 在 1990 年就公开发表在了自己的网站上，想想我们是什么时候才听说的？什么时候才有一个可用的实现？而 Raft 算法是 2013 年发表的，大家在参考 Raft开源实现库，可以看到有很多基于不同语言的 开源实现库，这就是 可理解性 的重要性。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之一致性算法Paxos(5)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos-5%2F</url>
    <content type="text"><![CDATA[前言世界上只有一种一致性算法, 就是Paxos(帕克索斯), 出自一位 Google 大神之口。 Paxos解决了2PC，3PC中的各种硬伤, 在很多大长都有工程实践。比如阿里的 OceanBase 分布式数据库，底层就是使用的 Paxos 算法。再比如 Google 的 chubby 分布式锁 也是用的这个算法。可见该算法在分布式系统中的地位，甚至于Paxos 就是 分布式一致性 的代名词。 1. Paxos算法是什么Paxos 算法是 基于消息传递 且具有 高效容错特性 的一致性算法，目前公认的解决 分布式一致性问题 最有效 的算法之一。2. 解决了什么问题(产生背景)在常见的 分布式系统 中，总会发生 节点宕机 或 网络异常 (包括消息的 重复、丢失、延迟、乱序、网络分区)等情况。Paxos 算法主要就是解决如何在一个 发生如上故障 的分布式系统中，快速正确的在集群内 对某个值达成一致，并且保证 整个系统的一致性。 3. 算法详解角色 Proposer: Proposer 可以 提出提案 (Proposal)Acceptor: Acceptor 可以 接受提案。一旦接受提案，提案 里面的 value 值就被选定了Leaner: Acceptor 告诉 Learner 哪个提案被选定了，那么 Learner 就学习这个被选择的 value在具体的实现中，一个进程即可能是Proposer,也可能是Acceptor，也可能是Learner。 注意：提案的范围&gt;value.后面会讲到，[提案=编号+Value].也可表示为[M,V].以下描述中暂定: 提案=P，Value=V 问题描述Paxos 算法的核心是 一致性。所以将从一致性问题的描述来讲解该算法怎么解决实际问题。 一致性算法的前置条件 在被提出的 P 中，只有一个 V 被选中如果没有 P 被提出，就没有 V 被选中在 P 被选定后，进程都可以学习被选中的 P 不同角色通过发送消息进行通信 每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个 value 被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值 消息在传递过程中可能出现 任意时长的延迟，可能会 重复，也可能 丢失，但是消息不会被 损坏 推导过程只有一个Acceptor 问题：如果这个 Acceptor 宕机，那么整个系统服务不可用 多个Acceptor 问题：如何在多 Proposer 和多 Acceptor 情况下，选定一个 value？ 讲解步骤分两阶段：约定 P1 和 约定 P2。 约定P1 P1 ：一个 Acceptor 必须接受一个它收到的第一个 P。 如果每个 Proposer 会产生不同的 P，那么多个 Proposer 必定产生多个 P，发给多个 Acceptor。根据 约定 P1，Acceptor 分别接受到 P，就会导致不同的 V 被选定，如下图所示：如上图所示，P1 会产生的问题: v1、v2、v3 都没有被选定，因为他们只有被一个 Acceptor 接受。对于上述问题，我们需要一个额外的约定: P1a : 一个提案 P 被选定，需要被半数以上 Acceptor 接受. 对于 P1a，其实就意味着 一个Acceptor必须接受不止一个提案。显然，这与 P1 相矛盾，所以需要重新设计提案。原来的设计是: [提案P = value]，现在重新设计 [提案P = 提案编号 + value]，可表示为 [M，V]。 新问题：多提案被选定，如何保证被选定的提案 P 具有相同的value? 约定P2 P2 : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且被选定的 P，其 value 的值也是 V0。 对于 P2 中的 “被选定”：一个提案要被选定，首先至少要被一个 Acceptor 批准。因此，可以理解 P2 为： P2a : 如果提案 P[M0,V0] 被选定了，那么所有比 M0 编号更高的，且 [被Acceptor批准] 的P，其 value值也是 V0。 只要满足 P2a，就能满足 P2。多提案被选择 的问题解决了，但是由于 网络不稳定 或者 宕机 的原因(不可避免)会产生新问题： 假设有 5 个 Acceptor。Proposer2 提出 [M1,V1]的提案，Acceptor2~5（半数以上）均接受了该提案，于是对于 Acceptor2~5 和 Proposer2 来讲，它们都认为 V1 被选定。Acceptor1 刚刚从 宕机状态 恢复过来（之前 Acceptor1 没有收到过任何提案），此时 Proposer1 向 Acceptor1 发送了 [M2,V2] 的提案（V2≠V1且M2&gt;M1）。对于 Acceptor1 来讲，这是它收到的 第一个提案。根据 P1（一个 Acceptor 必须接受它收到的 第一个提案），Acceptor1 必须接受该提案。同时 Acceptor1 认为 V2 被选定。 这就出现了两个问题： Acceptor1 认为 V2 被选定，Acceptor2~5 和Proposer2 认为 V1 被选定。出现了不一致。 V1 被选定了，但是 编号更高 的被 Acceptor1 接受的提案 [M2,V2] 的 value 为 V2，且 V2≠V1。这就跟 P2a（如果某个 value 为 v的提案被选定了，那么每个 编号更高 的被 Acceptor 接受的提案的 value必须也是 v）矛盾了 基于以上问题，所有就有了 P2b: P2b : 如果 P[M0,V0] 被选定后，任何 Proposer 产生的 P，其值也是 V0 对于 P2b 中的描述，怎样保证 任何Proposer产生的P，其值也是V0 ？只要满足 P2c 即可： P2c: 对于任意的 M、V，如果 [M,V] 被提出，那么存在一个半数以上的 Acceptor 组成的组合 S，满足以下两个条件中的任何一个： S 中没有一个接受过编号小于 M 的提案。 S 中的 Acceptor 接受过的最大编号的提案的 value 为 V。 算法流程Proposer提出提案(一). 学习阶段：Prepare请求Proposer 选择一个新的提案 P[MN,?] 向 Acceptor 集合 S（数目在半数以上）发送请求，要求 S 中的每一个 Acceptor 做出如下响应: 如果 Acceptor 没有接受过提案，则向 Proposer 保证 不再接受编号小于N的提案 如果 Acceptor 接受过请求，则向 Proposer 返回 已经接受过的编号小于N的编号最大的提案 (二). 接受阶段：Acceptor请求 如果 Proposer 收到 半数以上 的 Acceptor 响应，则 生成编号为 N，value 为 V 的提案[MN,V]，V 为所有响应中 编号最大 的提案的 value 如果 Proposer 收到的响应中 没有提案，那么 value 由 Proposer 自己生成，生成后将此提案发给 S，并期望 Acceptor 能接受此提案 Acceptor接受提案Acceptor 可以忽略任何请求（包括 Prepare 请求和 Accept 请求）而不用担心破坏 算法的安全性。什么时候 Acceptor 可以响应一个请求? P1b：一个 Acceptor 只要尚未响应过任何编号大于 N 的 Prepare 请求，那么就可以接受这个编号为 N 的提案。 如果 Acceptor 收到一个编号为 N 的 Prepare 请求，在此之前它已经 响应过 编号大于 N 的Prepare 请求。根据 P1b，该 Acceptor 不可能接受编号为 N 的提案。因此，该 Acceptor 可以忽略 编号为 N 的 Prepare 请求。当然，也可以回复一个 error，让 Proposer 尽早知道自己的提案 不会被接受。 因此，一个 Acceptor 只需记住: 已接受的编号最大的提案 已响应的请求的最大编号 4. Paxos算法描述5. Learner学习提案6. 如何保证Paxos算法的活性7. 小结Paxos 在 节点宕机恢复、消息无序或丢失、网络分化 的场景下能保证 数据的一致性。而 Paxos的描述侧重于 理论，在实际项目应用中，处理了 N 多实际细节后，可能已经变成了另外一种算法，这时候正确性已经无法得到理论的保证。 要证明分布式一致性算法的正确性通常比实现算法还困难。所以很多系统实际中使用的都是以 Paxos理论 为基础而 衍生 出来的变种和简化版。例如 Google 的 Chubby、MegaStore、Spanner 等系统，ZooKeeper 的 ZAB 协议，还有更加容易理解的 Raft 协议。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之3PC(4)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B3PC-4%2F</url>
    <content type="text"><![CDATA[前言三阶段提交对二阶段提交存在的问题进行了改进： 引入超时机制 - 同时在协调者和参与者中都引入超时机制。 在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。 3PC定义三阶段提交(Three-phase commit), 是二阶段提交的改进版本。所谓的三个阶段分别是：询问，然后再锁资源，最后真正提交。 第一阶段：CanCommit 第二阶段：PreCommit 第三阶段：Do Commit 3PC过程一、CanCommit协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。 事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。 响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态；否则反馈No。 二、PreCommit协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。 执行事务预提交 发送预提交请求 协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态 事务预提交 参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 准备阶段中的“执行事务”，也会 Undo 和 Redo 信息记录到事务日志中 各参与者响应反馈 如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）。 中断事务 发送中断请求 协调者向所有参与者节点发出 abort 请求 中断事务 参与者如果收到 abort 请求或者超时了，都会中断事务 三、DoCommit该阶段进行真正的事务提交，分为执行提交，或中断事务。 执行提交 发送提交请求 协调者接收到各参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。 事务提交 参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。 响应反馈 事务提交完之后，向协调者发送 ACK 响应 完成事务 协调者接收到所有参与者的 ACK 响应之后，完成事务 中断事务协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。 发送中断请求 协调者向所有参与者发送 abort 请求。 事务回滚 参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。 反馈结果 参与者完成事务回滚之后，向协调者发送 ACK 消息。 中断事务 协调者接收到参与者反馈的 ACK 消息之后，完成事务的中断。 优缺点 优点相对于二阶段提交，三阶段提交主要解决的单点故障问题，并减少了阻塞的时间。因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。 缺点三阶段提交也会导致数据一致性问题。由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之2PC(3)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B2PC-3%2F</url>
    <content type="text"><![CDATA[前言由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 PhaseCommitment Protocol）和Paxos算法。 本文要介绍的2PC协议，分为两个阶段提交一个事务。并通过协调者和各个参与者的配合，实现分布式一致性。 角色 XA概念 作用 协调者 事务管理器 协调各个参与者,对分布式事务进行提交或回滚 参与者 资源管理器 分布式集群中的节点 分布式事务分布式事务是指会涉及到操作多个数据库的事务。目的是为了保证分布式系统中的数据一致性关键： 需要记录事务在任何节点所做的所有动作 事务进行的所有操作要么全部提交，要么全部回滚 XA规范XA规范是由 X/Open组织（即现在的 Open Group ）定义的分布式事务处理模型。 X/Open DTP模型（ 1994 ）包括： 应用程序（ AP ） 事务管理器（ TM ）：交易中间件等 资源管理器（ RM ）：关系型数据库等 通信资源管理器（ CRM ）：消息中间件等 XA规范定义了交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而XA接口函数由数据库厂商提供 二阶提交协议和三阶提交协议就是基于XA规范提出的其中，二阶段提交就是实现XA分布式事务的关键。 XA规范的流程，大致如图所示： 2PC定义每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是中止操作。 准备阶段准备阶段分为三个步骤： 事务询问协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。 执行事务各参与者节点执行事务操作。如果本地事务成功，将Undo和Redo信息记入事务日志中，但不提交；否则，直接返回失败，退出执行。 各参与者向协调者反馈事务询问响应如果参与者成功执行了事务操作，那么就反馈给协调者 Yes响应，表示事务可以执行提交；如果参与者没有成功执行事务，就返回No给协调者，表示事务不可以执行提交。 提交阶段根据准备阶段的投票结果执行2种操作:提交事务或中断事务 提交事务过程 发送提交请求协调者向所有参与者发出commit请求。 事务提交参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后，释放整个事务执行期间占用的事务资源。 反馈事务提交结果参与者在完成事务提交之后，向协调者发送Ack信息。 事务提交确认协调者接收到所有参与者反馈的Ack信息后，完成事务。 中断事务过程 发送回滚请求协调者向所有参与者发出Rollback请求。 反馈事务回滚结果参与者在完成事务回滚之后，想协调者发送Ack信息。 事务回滚参与者接收到Rollback请求后，会利用其在提交阶段种记录的Undo信息，来执行事务回滚操作。在完成回滚之后，释放在整个事务执行期间占用的资源。 事务中断确认协调者接收到所有参与者反馈的Ack信息后，完成事务中断。 优缺点 优点：原理简单，实现方便。 缺点：同步阻塞，单点问题，数据不一致，容错性不好。 同步阻塞所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。(mapreduce里面是顺序执行) 单点问题协调者是个单点, 如果协调者在提交阶段出现问题，那么整个流程将无法运转 数据不一致协调者向所有的参与者发送commit请求之后，发生了局部网络异常，或者是协调者在尚未发送完所有 commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求。 容错性不好如果在二阶段提交的提交询问阶段中，参与者出现故障，导致协调者始终无法获取到所有参与者的确认信息，这时协调者只能依靠其自身的超时机制，判断是否需要中断事务。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式系统之BASE理论(2)]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8BBASE%E7%90%86%E8%AE%BA-2%2F</url>
    <content type="text"><![CDATA[前言BASE理论是由eBay架构师提出的. BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结, 是基于CAP定律逐步演化而来. 其核心思想是即使无法做到强一致性, 但每个应用都可以根据自身业务特点，才用适当的方式来使系统达到最终一致性 BASE理论简介BASE理论是Basically Available(基本可用), Soft State(软状态), Eventually Consistent(最终一致性)三个短语的缩写 其核心思想是： 既是无法做到强一致性, 但每个应用可以根据自身的业务特点, 采用适当的方式来是系统达到最终一致性 BASE理论的内容基本可用当系统出现了不可预知故障, 但还是能用, 就是基本可用。。。 响应时间的止损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。 软状态相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。 软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。 最终一致性在一定期限后，应当保证所有副本数据一致性，从而达到数据的最终一致性。时间期限取决于网络延迟、系统负载、数据复制方案设计等 在实际工程实践中，最终一致性分为5种： 因果一致性（Causal consistency）如果节点A在更新了数据后通知了B，那么B对该数据的访问都是基于A更新修改后的值。与此同时,和节点A无因果关系的节点C的数据访问没有这样的限制 读己之所写（Read your writes）节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性 会话一致性（Session consistency）对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。 单调读一致性（Monotonic read consistency）如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。 单调写一致性（Monotonic write consistency）一个系统要能够保证来自同一个节点的写操作被顺序的执行。 在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。 实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。 小结总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法图解笔记]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 绪论冒泡排序 遍历A[0, n] 依次比较相邻两个数, 若A[i-1]小于A[i], 则交换, 并设置循环遍历标记; 一次循环必然可确定一个最大值, n递减; 1234567891011121314151617void bubble_sort(int A[], n)&#123; bool bSort = false; while(bSort) &#123; bSort = false; for(int i=1; i&lt;n; i++) &#123; if(A[i-1]&gt;A[i]) &#123; swap(A[i-1], A[i]); bSort = true; &#125; &#125; n--; &#125;&#125; 复杂度度量大O记号性质a) 对于任意常数c&gt;0, 有$ O(f(n)) = O(c*f(n)) $b) 对于任意常数a&gt;b&gt;0, $ 有O(n^a + n^b) = O(n^a) $冒泡时间复杂度: $ T(n)=O(2(n-1)^2) = O(2n^2 + 4n + 2) = O(2n^2) = O(n^2) $ $ \Omega $ 标记为最乐观的下限复杂度, $ \Theta $ 上限复杂度 复杂度分析常数：$ T(n) = O(3) + O(2) + O(1) = O(7) = O(1) $对数：$ O(\log_2 n) = O(\log n) $指数：$ O(a^n) $ 1234567891011// 统计整数n二进制展开中数位1的个数int countOnes(unsigned int n)&#123; int num = 0; while(n&gt;0) &#123; num += (1&amp;n); n &gt;&gt; 1; &#125; return num;&#125; 递归(recursive)线性递归二分递归多分支递归ADT第二章 向量从数组到向量前驱(prefix)，后继(suffix)向量(vector)是线性数组的抽象和泛化。各元素的秩(rank)互异, 且均为[0, n) 内的整数。需要考虑扩容(expand不够用成倍扩展)和缩容(shrink小于25%较少1/2空间) 归并排序比较两个待归并的向量的首元素，取小的追加到输出向量末尾时间复杂度$ O(\log n) $12345678910111213141516template &lt;class T&gt;void mergeSort(Rank lo, Rand hi)&#123; if(hi - lo &lt; 2) return; int mi = (lo + hi) &gt;&gt; 1; mergeSort(lo, mi); mergeSort(mi, hi); merge(lo, mi, hi);&#125;template &lt;class T&gt;void merge(Rank lo, Rank mi, Rank hi)&#123; &#125; 第三章 列表插入排序, 选择排序, 归并排序1234567891011template &lt;class T&gt;void list&lt;T&gt;::init()&#123; header = new ListNode&lt;T&gt;; trailer = new listNode&lt;T&gt;; header-&gt;pred = NULL; header-&gt;succ = trailer; trailer-&gt;pred = header; trailer-&gt;succ = NULL; _size = 0 // 记录规模&#125; 第4章 栈与队列典型应用: 逆序输出(进制转换), 递归嵌套(栈混洗复制一个栈,括号匹配), 延迟缓冲, 逆波兰表达式 1234567891011121314151617char digit[] = &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;;void convert(stack&lt;char&gt;&amp; out, __int64 n, int base)&#123; if(n &gt; 0) &#123; convert(out, n/base, base); // 递归得到所有高位 out.push(digit[n%base]); // 输出低位 &#125; /* while(n&gt;0) &#123; int pos = n%base; out.push(digit[pos]); n /= base; &#125; */&#125;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[失败是成功他妈]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A4%B1%E8%B4%A5%E6%98%AF%E6%88%90%E5%8A%9F%E4%BB%96%E5%A6%88%2F</url>
    <content type="text"><![CDATA[必须刷一遍思路清奇小土刀 剑指Offer名企面试官精讲经典型编程大海捞针找到的c++面试技术面试必备的基础知识徐刘根的JAVA面试大杂烩Google的面试Java后端知识体系总结系统设计入门x86-64体系下一个奇怪问题的定位2018/2019/校招/春招/秋招/自然语言处理(NLP)/深度学习(Deep Learning)/机器学习(Machine Learning)/C/C++/Python/面试笔记]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程实践]]></title>
    <url>%2F2018%2F11%2F01%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[参考文章select1234567891011121314#include &lt;sys/select.h&gt;int select(int fd, fd_set* read, fd_set* write, fd_set* excp, struct timeval* tm);// 返回值：就绪描述符的数目，超时返回0，出错返回-1FD_ZERO(fd_set* fds);FD_SET(int fd, fd_set* fds);FD_CLR(int fd, fd_set* fds);FD_ISSET(int fd, fd_set* fds);#include &lt;sys/time.h&gt;struct timeval&#123;__time_t tv_sec; /* Seconds. */__suseconds_t tv_usec; /* Microseconds. */&#125;; 123456789101112131415while(1)&#123; fd_set fds; FD_ZERO(&amp;fds); FD_SET(sock, &amp;fds); int ret = select(fd+1, &amp;fds, 0, 0, NULL); /*NULL一直阻塞*/ if(FD_ISSET(sock, &amp;fds)) &#123; //read &#125;&#125;// 套接字的阻塞非阻塞不影响select ， 只会影响read/write. poll123456789101112131415161718#include &lt;poll.h&gt;int poll(struct pollfd fds[], unsigned int nfds, int timeout);param: fds 数组 nfds 描述符个数，无限制 timeout 阻塞时间，单位msreturn: 返回值 &gt;0 实际发生事件描述符总数 , ==0 超时, -1 失败 设置errno struct pollfd&#123; int fd; // 文件描述符 short events; // 等待事件 short revevents; // 实际发生事件&#125;;POLLIN | POLLPRI 读, POLLOUT | POLLWRBAND 写 123456789101112131415161718192021struct pollfd fds[OPEN_MAX];fds[0].events = POLLIN | POLLPRI;for(;;)&#123; switch(poll(&amp;fds, 1, timeout)) &#123; case 0: printf(&quot;timeout \n&quot;); case -1: printf(&quot;poll error \n&quot;); default: &#123; printf(&quot;some events \n&quot;); if(fds[0].revevents &amp; POLLIN) &#123; // accept and put into fds &#125; &#125; break; &#125;&#125; epoll1234567891011121314151617#include &lt;sys/epoll.h&gt;int epoll_create(int size); // 监听数量int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);struct epoll_event&#123; __uint32_t events; epoll_data_t data;&#125;EPOLLIN/EPOLLOUT/EPOLLPRI/EPOLLERR/EPOLLHUP/EPOLLLET/EPOLLONESHOT工作模式： LT:应用程序可以不处理，下次还会再响应。 ET:需要立即处理，下次不会响应，默认ET，只响应一次。 必须使用非阻塞套接口，避免饿死其他套接口。 1234567891011121314151617181920212223242526272829void do_epool()&#123; int epollfd; struct epoll_event events[10]; epollfd = epoll_create(1024); events[0].events = EPOLLIN; events[0].data.fd = fd; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;(events[0])); for(;;) &#123; struct epoll_event eventArr[100]; // epoll_wait成功之后，储存所有的读写事件 num = epoll_wait(epollfd, eventArr, 1024, -1); for(int = 0; i&lt;num; ++i) &#123; if(eventArr[i].data.fd == lintenfd &amp;&amp;eventArr[i].events &amp; EPOLLIN) // accept else if(eventArr[i].events &amp; EPOLLIN) // 可读，有数据到来 // read else if(eventArr[i].events &amp; EPOLLOUT) // 可写，缓冲区从满==&gt;未满 // write else if(&amp; EPOLLHUP) //RST响应,在epoll上会响应为EPOLLHUP // do something &#125; &#125; close(epollfd); // &#125; 总结select的几大缺点： 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大select支持的文件描述符数量太小了，默认是1024 差异select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。 select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。 这也能节省不少的开销。阻塞/非阻塞设置12345#include &lt;fcntl.h&gt;fcntl(FD, F_SETFL, O_NONBLOCK);iFlag = 0;if( ioctl( nSock, FIONBIO, &amp;iFlag) &lt; 0) read123456789101112131415161718192021222324252627int readN(char* pBuf, int nByte)&#123; int nLeft = nByte; int nRead = 0; while(nLeft &gt; 0) &#123; nRead = read( m_nSock, pBuf, nLeft); if(nRead &lt; 0) // &#123; if(errno == EINTR) // 收到信号并从信号处理函数返回时，慢系统调用会返回并设 continue; if(errno == EAGAIN) // 示当前暂时没有数据可读，应该稍后读取 continue; &#125; else if(nRead == 0) //接收到对端发送的FIN，表示对端的写端关闭。 &#123; break; &#125; else //读取数据的长度 &#123; nLeft -= nRead; pBuf += nRead; &#125; &#125; reutrn nByte - nLeft;&#125; write12345678910111213141516171819202122232425int writeN(char* pBuf, int nByte)&#123; int nLeft = nByte; int nWrite = 0; while(nLeft &gt; 0) &#123; nWrite = write(m_nSock, pBuf, nLeft); if(nWrite &lt;=0) &#123; if(errno == EINTR) continue; if(errno == EAGAIN) // 水平模式下,如果返回EAGAIN，把socket加入epoll， // 在epoll的驱动下写数据，全部数据发送完毕后，再移出epoll //do something return nWrite; &#125; nLeft -= nWrite; pBuf += nWrite;s &#125; reutrn nByte - nLeft;&#125;//如果向已经关闭的对端调用write, 系统会向程序发送SIGPIPE信号 ET模式下，EPOLLOUT触发条件有：1.缓冲区满–&gt;缓冲区非满；2.同时监听EPOLLOUT和EPOLLIN事件 时，当有IN 事件发生，都会顺带一个OUT事件； 3.一个客户端connect过来，accept成功后会触发一次OUT事件。踩过的坑errnoerrno是线程安全的, 在一个线程中设置它, 不会影响别的线程对它的使用如果你的程序对它有依赖, 需要开发人员在接口错误处理中手工设置 粘包客户端没有收完整, 导致收下一个包core]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络模型概念]]></title>
    <url>%2F2018%2F11%2F01%2F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[在Linux中，对于一次读取IO的操作, 包含两个阶段 1 Waiting for the data to be ready(等待数据到达内核缓冲区)2 Copying the data from the kernel to the process(从内核缓冲区拷贝数据到程序缓冲区) 对于同步、异步IO, Stevens给的定义 A synchronous I/O operation causes the requesting process to beblocked until that I/O operation completes; An asynchronous I/O operation does not cause the requesting process to be blocked; 根据IO操作和进程的关系，分为五种模型 阻塞IOIO操作的两个阶段都阻塞, 用户进程一直等待系统调用返回 非阻塞IO前三次调用立即返回, 第四次调用内核数据已经准备好, 但是从内核缓冲区拷贝数据到程序缓冲区时用户进程会等待系统调用返回 IO复用select等待数据到达内核缓冲区(或超时), recvfrom从内核缓冲区拷贝数据到程序缓冲区, 两个过程用户进程分别会阻塞等待调用返回 信号驱动设置socket为一个信号驱动IO, 内核数据准备好后通知用户进程.用户进程调用recform, 等待从内核缓冲区拷贝数据到程序缓冲区, 这个过程用户进程阻塞等待 异步IO用户进程调用aio_read后, 可以继续执行, 等待IO操作两个阶段完成收到信号通知, 读取数据 总结前四种都是同步型IO操作, 只有异步IO才是异步型IO操作。]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一致性hash算法]]></title>
    <url>%2F2018%2F10%2F30%2F%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常规思路： 1.是什么2.解决了什么问题3.是怎么实现的 hash问题数据库中分库分表规则，按照hash取值、取模、按类别、按某一个字段。例如redis集群使用hash的方式，对图片缓存, 对服务器的数量进行取模hash(a.png)%4 = 2 当我们增加或减少一台服务器时，hash(a.png)%5=? hash(a.png)%3=？redis缓存的图片就找不到了，都会想后端数据库直请求，引发缓存雪崩 一致性hash一致性Hash算法是对2^32取模, 整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形）整个哈希环如下: 整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1，0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： 将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！ 例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下： 根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 一致性Hash算法的容错性和可扩展性一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。 Hash环的数据倾斜问题一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： 此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。 同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，使很少的服务节点也能做到相对均匀的数据分布]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[准备好吹牛B]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%87%86%E5%A4%87%E5%A5%BD%E5%90%B9%E7%89%9BB%2F</url>
    <content type="text"><![CDATA[BOSS系统介绍 整体功能架构计费功能架构计费技术架构计费对外接口设计部署方案(接入/应用/数据) (集群、负载均衡、分布式、数据一致性的区别与关系)高可用及容灾设计和测试(mdb) 两个机房, A/B/C/D 4个业务中心,| 流程 | 部署 | 事务数/秒(TPS) | 查询次数/秒(QPS) | 总量/天 ||:-|:-|:-|:-|:-|:-|:-|| 计费查询代理 | A/B/C/D 每个中心多个端口 | | | | || 计费MDB | 主/备(同机房)/容(异地机房), A/B/C/D 每个中心2个 | || GSM长流程 | 按需部署 || GPRS长流程 | 按需部署 || 告警导出 | 按需部署 || 在线计费 | 按需部署 || 资料上发 | 按需部署 | || XC本地容器 | 每个应用主机一个 | | 遇到过的问题 网络粘包, errno交叉死锁, 锁顺序不一致binlog乱序, 索引优化内存泄漏(lua,new/del, 最近比较少)性能优化, 主机问题(linux时钟源, ssd调度方式cfq/deadline, ck和binglog文件rename, 自旋锁占CPU过高, 存储变为只读)咪咕在线流程超时(kpi数据分析, sock日志, 冲销节点慢，但是在整个批价节点的占比变化不大，因此判断是网络/CPU等原因导致乐观锁优化 介绍 最得意的事]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP协议相关概念]]></title>
    <url>%2F2018%2F10%2F29%2FTCP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. TCP协议头部格式 DNS在应用层, TCP/UDP/PORT在传输层, IP在网络层, ARP在数据链路层去掉没有协议的表示层和会话层，就是TCP/IP五层网络模型OSI是Open System Interconnect的缩写，意为开放式系统互联 为什么需要2MSL？ Maximum Segment Lifetime 报文最大生存时间, 保证最后发送的ACK报文对端可以收到, 不然对端会重发FIN. 所以TIME_WAIT用来重发可能丢失的ACK 2. 三次握手四次分手 为什么需要三次握手？ 全双工, 告诉对方 发送/接受数据 能力OK 为什么需要四次分手？ 为了确保数据能够完成传输(确保对端收完数据) 3. TCP状态转换 4. TCP如何保证可靠传输三次握手, seq+ack, 超时重传, 流量控制, 拥塞控制 超时重传流量控制拥塞控制5. TCP粘包TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包, 从接收缓冲区看,后一包数据的头紧接着前一包数据的尾 产生原因 发送方 TCP默认会使用Nagle算法: 只有上一个分组得到确认，才会发送下一个分组; 收集多个小分组，在一个确认到来时一起发送接受方 没有立即处理, TCP将收到的分组保存至接收缓存里, 缓冲区会存在多个包 解决办法 发送发关闭Nagle算法, TCP_NODELAY选项接受方 TCP协议没有处理机制, 通过应用层来处理应用层 定义消息包头(len+type)和包体(data), 收包时循环处理 6. TCP的四种定时器 重传计时器：Retransmission Timer坚持计时器：Persistent Timer保活计时器：Keeplive Timer时间等待计时器：Timer_Wait Timer 7. TIME_WAIT太多压测工具主动关闭链接，产生TIME_WAIT将近3W，导致后续链接失败 产生原因TIME_WAIT停留2MSL(max segment lifetime)时间 解决办法1234567891011121314151617181920#统计TCP套接字状态netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;#表示开启SYN cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭net.ipv4.tcp_syncookies = 1#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭net.ipv4.tcp_tw_recycle = 1#修改系統默认的 TIMEOUT 时间net.ipv4.tcp_fin_timeout = 30#查看系统本地可用端口极限值cat /proc/sys/net/ipv4/ip_local_port_range51_zjdev[/data01/zjgrp/zjdev]%cat /proc/sys/net/ipv4/ip_local_port_range32768 61000本地能向外连接61000-32768=28232个连接 8. TCP队列在Linux内核2.2之后，分离为两个backlog来分别限制半连接(SYN_RCVD状态)队列大小和全连接(ESTABLISHED状态)队列大小。 半连接状态为：服务器处于Listen状态时收到客户端SYN报文时放入半连接队列中，即SYN queue(服务器端口状态为：SYN_RCVD) 全连接状态为：TCP的连接状态从服务器（SYN+ACK）响应客户端后，到客户端的ACK报文到达服务器之前，则一直保留在半连接状态中；当服务器接收到客户端的ACK报文后，该条目将从半连接队列搬到全连接队列尾部，即 accept queue (服务器端口状态为：ESTABLISHED) 1234567891011121314151617181920212223242526# SYN queue 队列长度51_zjdev[/data01/zjgrp/zjdev]%cat /proc/sys/net/ipv4/tcp_max_syn_backlog2048# Accept queue 队列长度51_zjdev[/data01/zjgrp/zjdev]%cat /proc/sys/net/core/somaxconn128/*最终取min(128, 使用listen函数时传入的参数)。在Linux内核2.4.25之前，是写死在代码常量 SOMAXCONN ，在Linux内核2.4.25之后，在配置文件 /proc/sys/net/core/somaxconn 中直接修改， 或者在/etc/sysctl.conf 中配置 net.core.somaxconn = 128*/# 查看SYN queue 溢出[root@localhost ~]# netstat -s | grep LISTEN102324 SYNs to LISTEN sockets dropped# 查看Accept queue 溢出[root@localhost ~]# netstat -s | grep TCPBacklogDropTCPBacklogDrop: 2334# 查看Accept queue[root@zhangbb ~]# ss -lntState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 50 *:3306 *:* /*在LISTEN状态，其中 Send-Q 即为Accept queue的最大值，Recv-Q 则表示Accept queue中等待被服务器accept()*/]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++类型转换]]></title>
    <url>%2F2018%2F10%2F28%2Fc-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[四种类型转换 const_cast 修改类型的const或volatile属性 static_cast 通常用于转换数值类型, 进行非多态的类型转换, 编译时检查 dynamic_cast 基类转换成子类, 基类必须要有虚函数 reinterpret_cast 比较底层的转换, 在非相关的类型之间转换; 操作结果只是简单的从一个指针到别的指针的值的二进制拷贝;在类型之间指向的内容不做任何类型的检查和转换 语法 xxx_cast (expression)]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++智能指针]]></title>
    <url>%2F2018%2F10%2F28%2Fc-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[智能指针 (头文件memory) auto_ptr c++11已摒弃, 所有权控制不够严格, 没有避免潜在的内存崩溃问题 shared_ptr 采用引用计数, 将一个原始指针分配给多个所有者; 大小为两个指针,一个用于对象，另一个用于包含引用计数的共享控制块(strong ref/weak ref) weak_ptr 提供对一个或多个shared_ptr实例拥有的对象的访问, 但不参与引用计数; 用于观察某个对象但不需要其保持活动状态 unique_ptr 只允许基础指针的一个所有者, 可移动, 但不可复制; 大小等同于一个指针且支持 rvalue 引用 auto_ptr废弃原因： 当把一个auto_ptr赋给另外一个auto_ptr时, 原指针变为野指针, 不安全 1234567891011void Fun(auto_ptr&lt;Test&gt; p1 )&#123; cout&lt;&lt;p1-&gt;m_a&lt;&lt;endl;&#125;void main( )&#123; std::auto_ptr&lt;Test&gt; p( new Test(5) ); Fun(p); cout&lt;&lt;p-&gt;m_a&lt;&lt;endl;&#125; auto_ptr不能指向一组对象, 不能和操作符new[]一起用, 会产生一个运行时错误 1234void main( )&#123; std::auto_ptr&lt;Test&gt; p(new Test[5]);&#125; auto_ptr不能和标准容器（vector,list,map….)一起使用 shared_ptr使用方式 为什么要尽量使用 make_shared为了节省一次内存分配, 原来 shared_ptr x(new Foo); 需要为 Foo 和 ref_count各分配一次内存, 现在用 make_shared()的话, 可以一次分配一块足够大的内存, 供 Foo和 ref_count 对象容身, 数据结构是： explicit构造函数, 不允许隐式转换 123456shared_ptr&lt;double&gt; pd; double *p_reg = new double;pd = p_reg; // not allowed (implicit conversion)pd = shared_ptr&lt;double&gt;(p_reg); // allowed (explicit conversion)shared_ptr&lt;double&gt; pshared = p_reg; // not allowed (implicit conversion)shared_ptr&lt;double&gt; pshared(p_reg); // allowed (explicit conversion) 方法 get(): 获取shared_ptr绑定的资源. reset(): 释放关联内存块的所有权，如果是最后一个指向该资源的shared_ptr,就释放这块内存 unique: 判断是否是唯一指向当前内存的shared_ptr operator bool : 判断当前的shared_ptr是否指向一个内存块，可以用if 表达式判断 存在问题 多个shared_ptrs对象用一个普通指针构造, 析构时core 123456void main( )&#123; int* p = new int; shared_ptr&lt;int&gt; sptr1( p); shared_ptr&lt;int&gt; sptr2( p );&#125; 用指针去创建shared_ptr, 不小心删除指针, 析构时core 循环引用, 资源都不会正常释放 12345678910void main( )&#123; shared_ptr&lt;B&gt; sptrB( new B ); shared_ptr&lt;A&gt; sptrA( new A ); // sptrB-&gt;m_sptrA shared_ptr sptrB-&gt;m_sptrA = sptrA; sptrA-&gt;m_sptrB = sptrB;&#125;4. 读线程不安全, 写线程不安全 weak_ptr使用方式 方法 调用lock()可以得到shared_ptr或者直接将weak_ptr转型为shared_ptr 调用use_count()去获取引用计数，该方法只返回强引用计数，并不返回弱引用计数 调用expired()方法。比调用use_count()方法速度更快 解决循环引用内存不会释放问题123456789void main( )&#123; shared_ptr&lt;B&gt; sptrB( new B ); shared_ptr&lt;A&gt; sptrA( new A ); // sptrB-&gt;m_sptrA weak_ptr sptrB-&gt;m_sptrA = sptrA; sptrA-&gt;m_sptrB = sptrB; sptrA-&gt;PrintSpB( ); &#125; unique_ptr优点 将一个unique_ptr赋值给另一个时, 如果源 unique_ptr是个临时右值, 编译器允许这么做 1234567unique_ptr&lt;string&gt; demo(const char * s)&#123; unique_ptr&lt;string&gt; temp (new string (s))； return temp；&#125;unique_ptr&lt;string&gt; ps;ps = demo(&apos;Uniquely special&quot;)； 无法赋值, 可以移动; 或者release释放后reset转移 12unique_ptr&lt;Foo&gt; ptr = make_unique&lt;Foo&gt;();Foo* p = ptr.release();]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gstack]]></title>
    <url>%2F2018%2F10%2F25%2Fgstack%2F</url>
    <content type="text"><![CDATA[123456#!bin/shwhile( true )do gstack $1&gt;&gt;gstack_$1.txtsleep 1done]]></content>
      <categories>
        <category>gdb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Posix线程编程指南]]></title>
    <url>%2F2018%2F10%2F24%2FPosix%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[摘自 IBM developerWorks 图书频道 Posix线程编程指南线程创建与取消 线程私有数据线程同步线程终止杂项 通用线程：POSIX 线程详解一种支持内存共享的简捷工具称作互斥对象的小玩意使用条件变量提高效率 线程池的介绍及简单实现c++ 内存池]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信]]></title>
    <url>%2F2018%2F10%2F24%2FLinux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[摘自 IBM developerworks 郑彦兴 深刻理解Linux进程间通信(IPC) Linux环境进程间通信（一）Linux环境进程间通信（二）信号（上）Linux环境进程间通信（二）信号（下）Linux环境进程间通信（三）消息队列Linux环境进程间通信（四）信号灯Linux环境进程间通信（五）共享内存（上）Linux环境进程间通信（五）共享内存（下）Linux 环境进程间通信（六）套接口小结 管道及有名管道: 具有亲缘关系的进程间通信, 有名管道克服了管道没有名字的限制, 可用于无亲缘关系进程间通信 信号: 通知某进程某个事件发生, 可发送给自身。 报文队列(消息队列): 消息队列是消息的链接, 随内核持续; 克服了信号承载信息少, 管道只能承载无格式字节流以及缓冲区大小受限制缺点 信号量(semaphore): 进程间及同一进程不同线程间的同步手段。 共享内存: 使多个进程可以访问同一块内存, 是最快的可用IPC形式。针对其他通信机制运行效率低设计。可与信号量配合使用,达到进程间的同步和互斥 套接口(socket): 用于不同机器之间的进程间通信。 管道及有名管道123456#include &lt;unistd.h&gt;int pipe(int fd[2])#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char * pathname, mode_t mode) 写端依赖读端, 读端关闭, SIGPIPE信号默认停止 信号信号本质信号是对软中断机制的模拟, 信号是异步的 信号种类可靠信号和不可靠信号, 可靠信号支持排队不会丢失(信号值位于SIGRTMIN及SIGRTMAX之间);实时信号和非实时信号, 实时信号都是可靠信号, 支持排队, 非实时信号都是不可靠信号 信号安装sigaction比signal 多了一个信息传递 进程对信号响应忽略/捕捉/默认缺省操作, 其中SIGSTOP/SIGKILL不能忽略 信号发送发送信号的主要函数有：kill()、raise()、 sigqueue()、alarm()、setitimer()以及abort()。 信号安装123456#include &lt;signal.h&gt; typedef void (*sighandler_t)(int)； sighandler_t signal(int signum, sighandler_t handler)); #include &lt;signal.h&gt; int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact)); 信号阻塞和信号未决1234#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oldset))；int sigpending(sigset_t *set));int sigsuspend(const sigset_t *mask))； 信号生命周期信号的诞生-&gt;信号在进程中注册-&gt;信号在进程中注销-&gt;信号处理函数执行完毕 在进程的task_struct中有信号链表, 注册就是将信号加入到链表中。可靠信号一定会加入, 不可靠信号如有同一信号注册, 只会注册一次。 信号编程注意事项 为增强程序稳定性, 信号处理程序中应当使用可重入函数, 避免信号处理执行函数执行后修改数据导致出现不可预料结果。 满足下列要求的基本是不可再入: 使用静态数据结构, 如getlogin()，gmtime()，getgrgid()，getgrnam()，getpwuid()以及getpwnam()等等 函数实现时，调用了malloc() 或者free()函数 实现使用了标准I/O函数， 如printf是可不再入 read/write/_exit/open 等是可再入函数 消息队列基本概念消息队列是随内核持续的一个消息链表(struct ipc_ids msg_ids) 消息队列操作1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;key_t ftok (char*pathname, char proj)；// 不够直观int ipc(unsigned int call, int first, int second, int third, void * ptr, long fifth);// 获取消息队列描述符int msgget(key_t key, int msgflg)// 读取一个消息, 存储在msgbuf中int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg);// 向队列发送一个消息, 发送消息+队列中消息&gt;=容量时会阻塞int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, int msgflg);// 设置属性或删除消息队列int msgctl(int msqid, int cmd, struct msqid_ds *buf); 信号量概念随内核持续, 进程间的同步手段(struct ipc_ids sem_ids) 操作1234567891011121314#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;// 文件名到键值映射key_t ftok (char*pathname, char proj)// key 键值, nsems 信号量个数, int semget(key_t key, int nsems, int semflg)// sops指向数组的每一个sembuf结构, nsops为sops指向数组的大小int semop(int semid, struct sembuf *sops, unsigned nsops)int semctl(int semid，int semnum，int cmd，union semun arg) 共享内存1234567// 建立和解除映射关系void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset ) int munmap( void * addr, size_t len ) #include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;API：shmget()、shmat()、shmdt()及shmctl() 区别是随进程和随内核 套接口123456789101112131415161718192021222324252627282930313233343536373839404142// 套接口是由socket数据结构代表的struct socket&#123;socket_state state; /* 指明套接口的连接状态，一个套接口的连接状态可以有以下几种套接口是空闲的，还没有进行相应的端口及地址的绑定；还没有连接；正在连接中；已经连接；正在解除连接。 */ unsigned long flags; struct proto_ops ops; /* 指明可对套接口进行的各种操作 */ struct inode inode; /* 指向sockfs文件系统中的相应inode */ struct fasync_struct *fasync_list; /* Asynchronous wake up list */ struct file *file; /* 指向sockfs文件系统中的相应文件 */struct sock sk; /* 任何协议族都有其特定的套接口特性，该域就指向特定协议族的套接口对象。 */ wait_queue_head_t wait; short type; unsigned char passcred;&#125;;// 描述套接口通用地址的数据结构struct sockaddr// 由于历史的缘故，在bind、connect等系统调用中, 地址都需要强转struct sockaddr &#123; sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */&#125;;// 描述因特网地址结构的数据结构struct sockaddr_instruct sockaddr_in &#123; __SOCKADDR_COMMON (sin_); /* 描述协议族 */ in_port_t sin_port; /* 端口号 */ struct in_addr sin_addr; /* 因特网地址 */ /* Pad to size of `struct sockaddr&apos;. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; &#125;;// 接口int socket( int domain, int type, int ptotocol)int bind( int sockfd, const struct sockaddr * my_addr, socklen_t my_addr_len)int connect( int sockfd, const struct sockaddr * servaddr, socklen_t addrlen)int accept( int sockfd, struct sockaddr * cliaddr, socklen_t * addrlen) 补充12345678910111213ipcs用法 ipcs -a 是默认的输出信息 打印出当前系统中所有的进程间通信方式的信息ipcs -m 打印出使用共享内存进行进程间通信的信息ipcs -q 打印出使用消息队列进行进程间通信的信息ipcs -s 打印出使用信号进行进程间通信的信息ipcrm用法 ipcrm -M shmkey 移除用shmkey创建的共享内存段ipcrm -m shmid 移除用shmid标识的共享内存段ipcrm -Q msgkey 移除用msqkey创建的消息队列ipcrm -q msqid 移除用msqid标识的消息队列ipcrm -S semkey 移除用semkey创建的信号ipcrm -s semid 移除用semid标识的信号]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zk原理和实践]]></title>
    <url>%2F2018%2F10%2F24%2Fzk%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[透彻的学习笔记ZooKeeper学习第一期—Zookeeper简单介绍ZooKeeper学习第二期–ZooKeeper安装配置ZooKeeper学习第三期—Zookeeper命令操作ZooKeeper学习第四期—构建ZooKeeper应用ZooKeeper学习第五期–ZooKeeper管理分布式环境中的数据ZooKeeper学习第六期—ZooKeeper机制架构ZooKeeper学习第七期–ZooKeeper一致性原理ZooKeeper学习第八期——ZooKeeper伸缩性实践]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[UML关系图 关系 描述 箭头 补充 依赖 use a 虚线+箭头 工厂模式 关联 has a 实线+箭头 一个类作为参数 聚合 has a 实线+空心菱形 例如指针成员 组合 contains a 实线+实心菱形 一个整体 继承 泛化 实线+空心三角 指向基类 接口实现 虚线+空心三角 指向基类 调用 实线+实心三角 指向接口 聚合和组合生命周期不一样: 聚合对象删除, 部分对象还存在; 组合对象删除, 部分事物对象全部删除 设计模式 创建模式 功能 约束 factory 定义创建一个对象接口,封装对象的创建,在子类中创建对象(延迟实例化) 新增一个procudct就要新加接口，factory接口永远不封闭 abstractFactory 将一组对象创建封装到一个类中, abstactFactory是为一组相关或依赖的对象提供创建接口或延迟对象创建到子类中 新增一个product对应新增一个concreteFactory类 singleton static成员变量记录实例, 提供一个static的接口Instance()来获得唯一的实例 对象构造函数为private或proctected builder 将一个复杂对象的构建和表示分离, 同样的构建过程可以创建不同的表示 实际也是定义一个创建对象接口, 使用多个简单的对象一步一步构建成一个复杂的对象 prototype 自我复制自己创建的对象 c++通过拷贝构造实现 结构模式 功能 约束 adapter 将一个类的接口变换成客户端期待的, 使原本因接口不匹配无法在一起工作的两个类能够一起工作 复用接口或对象实现 bridge 使用组合方式将抽象和实现分离 调整实现逻辑, 外部调用没有变化 composite 提供对子类的管理策略，重在对象 递归构建树状组织, 组合模式让客户可以一致地使用组合结构和单个对象 decorater 添加职责，重在职责 职责管理, 例如批价process flyweight 享元模式, 为共享对象提供一个仓库 对象池 facade 外观模式 在高层提供统一的接口 隐藏系统的复杂性, 并向客户端提供了一个客户端可以访问系统的接口 proxy 请求实际提交给其他类处理，逻辑和实现彻底解构 创建具有现有对象的对象，以便向外界提供功能接口 通过private, 接口继承, 就是派生类只继承函数的接口，也就是声明通过public, 实现继承, 就是派生类同时继承函数的接口和实现组合和装饰模式在实现上完全不同 行为模式 功能 约束 template 算法由子类去实现, 实现和抽象接口解耦 继承实现 strategy 将算法封装到到一个类中 组合实现 state 将状态和动作实现分离 条件分支语句的代替者 observer 对MVC是该模式的一个实例 memento 备忘录模式 不破坏封装, 获取和保存一个类的内部状态, 用来恢复; 通过friend class实现 Mediator 中介者模式 将对象间的交互和通讯封装到一个类中 command 命令模式 将”行为请求者”与”行为实现者”解耦 visitor 访问者模式,将变更封装到一个类中, 由待更改类提供一个接口 符合单一原则,易扩展,但依赖了具体类 chain of responsibility 职责链模式 一个请求指定一组对象处理 Iterator 迭代器 将对象遍历封装到一个类中 Interpreter 解释器 模式 解决问题 优点 缺点 应用场景 参考设计模式菜鸟教程]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[性能之巅 笔记]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 绪论系统性能上对整个系统的研究，包括了所有硬件组件和整个软件栈。所有数据路径上和软硬件上发生的事情都包括在内，因为这些可能都影响性能。 性能领域包括以下事情： 1. 设置性能目标和建立性能模型 2. 基于软件或硬件原型进行性能特征归纳 3. 对开发的代码进行性能测试(软件整合之前) 4. 执行软件的非回归性测试(软件发布前或发布后) 5. 针对软件发布的基准测试 6. 目标环境中的概念验证测试 7. 生产环境的部署的配置优化 8. 监控生产环境中运行的软件 9. 特定问题的性能分析 术语容量规划是指一系列事前行动。在计划阶段，通过研究开发软件的资源占用情况，来得知原有设计在多大程度上能满足目标需求。在部署后，这样的问题在出现之前就能被预测。 性能分析必须量化问题的重要程度， 有一个指标非常合适，延时。 动态跟踪技术把所有的软件变得可以监控，而且能用在真实的生产环境中。这项技术利用内存中的CPU指令并在这些指令上动态构建检测数据。这样能从任何运行的软件中获得定制化的性能统计数据，从而提供了远超系统的自带的统计所能给予的观测性。 DTrace对用户态和内核态的软件都提供了静态跟踪和动态跟踪，并且数据是实时产生的。 第二章 方法术语：IOPS：每秒输入/输出的操作次数，是数据传输的一个度量方法。对于磁盘，就是每秒读和写的次数。吞吐量：数据传输或操作的速度响应时间：一次操作完成的时间延时: 操作里用来等待服务的时间使用率：对于服务所请求的资源，描述在给定的时间区间内资源的繁忙程度饱和度: 某一资源无法满足服务的排队工作量/瓶颈/工作负载/缓存 模型：第三章 操作系统了解操作系统和内核对于系统性能分析是至关重要的。会经常需要针对系统行为的开发和测试，如系统调用是如何执行的、CPU是如何调度线程的、有限大小的内存是如何影响性能的、或者文件系统是如何处理I/O的。 基本概念介绍，最好结合《深入理解计算机系统》： 内核：内核的执行/时钟/内核态栈：用户栈和内核栈; 用函数和寄存器的方式记录了线程的执行历史中断和中断线程进程：进程的创建、进程的生命周期、进程环境系统调用虚拟内存内存管理调度器文件系统：VFS、I/O栈缓存（括号内为例子）：应用程序缓存、服务器缓存(apache缓存)、缓存服务器(redis)、数据库缓存(mysql缓冲区高速缓存)、 目录缓存(DNLC)、文件元数据缓存(inode 缓存)、 操作系统缓存区高速缓存(segvn)、文件系统主缓存(ZFS ARC) 文件系统次缓存(ZFS L2ARC)、设备缓存(ZFS vdev)、 块缓存(缓冲区高速缓存)、磁盘控制器缓存(RAID卡缓存) 存储阵列缓存、磁盘内置缓存网络设备驱动多处理器：CPU交叉调用抢占资源管理观测性 第四章 观测工具工具可以按照系统级别和进程级别来分类，多数工具要么基于计数器要么基于跟踪。 系统级 | vmstat/iostat| mpstat/sar | dtrace/tcpdump |计数器——————-跟踪 pmap | ps | gdb/strace top | 进程级 计数器： 内核维护了各种统计数据，称为计数器，用于对事件的计数。通常计数器实现为无符号整形，发生事件时递增。 系统级别的计数器： vmstat: 虚拟内存和物理内存的统计 mpstat: 每个CPU的使用情况 iostat: 每个磁盘 I/O 的使用情况，由块设备接口报告 netstat: 网络接口统计 sar: 各种各样统计，能归档历史数据 iftop: 用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等 进程级别： ps：进程状态，显示进程的各种统计信息，包括内存和CPU的使用 top：按一个统计数据排序，显示排名高的进程 pmap：将进程的内存和使用统计一起列出 iotop: 进程的I/O速度 pidstat：每个进程/线程CPU使用量 一般来说，上述工具从/proc 文件系统里读取统计信息。 跟踪：系统级别： tcpdump：网络抓包(libpcap) bltrace: 块I/O 跟踪 dtrace: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态跟踪 perf: linux 性能事件，跟踪静态和动态的指针 进程级别： strace: 系统调用跟踪 gdb: 调式源码 网络工具： nethogs: 按进程查看流量占用 iptraf: 按连接/端口查看流量 ifstat: 按设备查看流量 ethtool: 诊断工具 tcpdump: 抓包工具 ss: 连接查看工具, 比netstat更快速更高效 其他: dstat, slurm, nload, bmon 第五章 应用程序性能调整离执行的地方越近越好：最好在应用程序里，包括web服务器、应用服务器、负载均衡、文件服务器等等 设立性能目标能为你的性能分析工作指明方向，并帮助你选择要做的事情。没有目标，性能分析容易沦为随机的[钓鱼探险]。常见目标： 延时 吞吐量 资源使用率 应用程序性能技术：选择I/O尺寸、缓存、缓冲区、轮询、并发和并行、非阻塞I/O、处理器绑定 编程语言相关：编译器优化、解释语言一般不是首选、虚拟机、垃圾回收 第六章 CPU 第七章 内存背景：内存相关术语架构：内存软硬件架构方法：内存分析的方法分析：分析内存性能工具调优：性能调优和可调参数范例 1.背景主存：物理内存，高速数据存储区域，动态随机访问内存(DRAM)虚拟内存: 一个抽象的主存概念，无限和非竞争性，虚拟内存不是真实的内存常驻内存：当前处于主存中的内存匿名内存: 无文件系统位置或者路径名的内存。包括进程地址空间的工作数据，称作堆。地址空间：内存上下文。每个进程和内核都有对应的虚拟内存空间段：标记为特殊用途的一块内存区域，例如用来存储可执行或者可写的页OOM：内存耗尽，内核检测到可用内存低页：操作系统和CPU使用的内存单位。一直以来都是4KB或8KB，现代处理器允许多种页大小。缺页：无效内存。使用按虚拟内存，这是正常事件。交换：将整个进程从主存转移到交换设备。交换(空间)：存放换页的匿名数据和交换进程的磁盘空间。可以是存储设备的一块空间， 也称为物理交换设备，或者是文件系统，称作交换文件。 换页：页面换入和调出主存。包含文件系统换页(mmap), 匿名换页(进程堆和栈) 按需换页：将虚拟内存映射到物理内存。CPU创建映射的开销延迟到实际需要或者访问。 过度换页：支持按需换页操作系统，malloc可以申请大于物理内存和交换设备的总和。 文件系统缓占用：应用进程需要时会释放 2.架构硬件：主存，总线，CPU缓存，MMU(内存管理单元)软件： 3.方法 第八章 文件系统 第九章 磁盘 第十章 网络]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++ 编程思想 笔记]]></title>
    <url>%2F2018%2F10%2F24%2Fc-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPC框架原理和实践]]></title>
    <url>%2F2018%2F10%2F24%2FRPC%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[简单的RPC框架有三部分组成： 1 服务提供者，运行在服务端，负责提供服务接口定义和服务实现类2 服务发布者，运行在RPC服务端，负责将本地服务发布成远程服务，供其他消费者调用3 本地服务代理，运行在RPC客户端，通过代理调用远程服务提供者，然后将结果进行封返回给本地消费者 RPC框架的调用原理如图： 服务治理问题在大规模服务化之前，应用可能只是通过RPC框架，简单的暴露和引用远程服务，通过配置URL地址进行远程服务调用，路由则通过F5负载均衡器等进行简单的负载均衡。 当服务越来越多的时候，服务的URL配置管理变得更加困难。单纯的使用RPC就有点吃不消。所以在大规模分布式集群中，RPC只是作为集群的一个方法调用手段。 RPC框架实现的几个核心技术点： 远程服务提供者 需要以某种形式(url/idl)提供给服务调用者 远程代理对象 服务调用者调用的服务实际是远程服务的本地代理 通信： 与具体协议无关 序列化：远程通信需要将对象转成二进制进行传输，不同序列化框架，支持的数据类型数据包大小，及性能差异很大 PRC框架高性能设计 I/O调度模型：同步阻塞(BIO) 还是非阻塞(NIO) 序列化框架的选择：文本协议、二进制协议、压缩后的二进制协议 线程调度模型： 串行或是并行调度，锁竞争还是无锁化 实践消息定义Header: TaskCreateTime/TaskTimeOut/SessionId/TenantldBody: Session String/SDL stream/ErrorInfo 序列化根据不同的序列化框架做比对测试 框架版本 测试内容 处理次数 耗时(us) 每秒处理次数 每次耗时(us) 1.8.x SJSON序列化 10000 416,225 24,025 41.62 1.8.x SJSON反序列化 10000 581,872 17,185 58.19 2.1.0 SCDR序列化 500000 2,716,170 184,083 5.43 2.1.0 SCDR反序列化 500000 3,409,015 146,670 6.82 2.1.0 SJSON序列化 10000 1,145,281 8,731 115 2.1.0 SJSON反序列化 10000 954,927 10,472 95.5 2.2.0 SJSON序列化 10000 427225 23,407 42.72 2.2.0 SJSON反序列化 10000 505211 19,794 50.52 RPC服务端模型设计1 纯粹单线程模型 所有工作在一个线程里实现采用非阻塞I/O实现单线程处理能力最大化，但没有扩展能力适用于连接数少、负载轻的服务场景 2 独立事件轮询线程 + 工作线程组模型 独立的事件轮询线程工作线程可水平扩展（性能非线性扩展）线程间频繁数据交换需要同步机制影响性能工作线程一次只处理一个连接的任务，对于慢速连接效率不高（可能会被阻塞）适用于任务量不大但业务处理耗时较大、网速快且稳定等场景 3 独立端口监听 + I/O及工作线程组模型 独立端口监听线程，获取的新连接转发给指定的工作线程工作线程负责socket连接的I/O时间轮询，以及后续的消息I/O和业务处理采用非阻塞I/O，处理能力随工作线程的扩展而线性扩展适用于连接数大、任务量大但业务处理耗时较小的场景 4 独立端口监听 + I/O线程 + BIZ线程分组模型 I/O事件轮询和消息收发由独立I/O线程执行业务处理由独立线程执行并可扩展一个I/O线程和若干和BIZ线程组成一个线程组，并可按组横向扩展适用于连接数多，任务量大，任务处理耗时大的场景]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux 常用命令]]></title>
    <url>%2F2018%2F10%2F24%2Flinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[系统级计数器vmstat查看整个机器的CPU,内存,IO的使用情况, 如间隔2秒采集3次1234567891011121314151617181920212223242526272829303132333435363738394041424352_zjdev[/data01/zjgrp/zjdev]%vmstat 2 3procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 2103292 2772856 570784 44911892 0 0 11 314 0 0 22 4 73 1 0 8 0 2103292 2772972 570784 44912092 0 0 0 66 45187 109175 2 3 94 0 0 6 0 2103292 2772476 570784 44912340 0 0 0 500 41664 105258 2 3 94 1 0进程：r 运行队列(CPU正在执行或正在等待CPU的进程数)b 阻塞进程,等待IO的进程数量(不可中断)内存：swpd 虚拟内存已使用大小, 如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能free 空闲物理内存大小buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用500多Mcache cache直接用来记忆我们打开的文件,给文件做缓冲(Linux/Unix的聪明之处，把空闲的物理内存 的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用)Swap：si: 每秒从交换区写到内存的大小，由磁盘调入内存so: 每秒写入交换区的内存大小，由内存调入磁盘注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源 都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点， 还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会 受到影响的IO(现在的Linux版本块的大小为1kb):bi: 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024bytebo: 每秒写入的块数随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大system(系统):in: 每秒中断数，包括时钟中断cs: 每秒上下文切换数上面2个值越大，会看到由内核消耗的CPU时间会越大CPU(以百分比表示):us: 用户进程执行时间百分比(us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用， 那么我们就该考虑优化程序算法或者进行加速)sy: 内核系统进程执行时间百分比(sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因)id: 空闲时间百分比wa: IO等待时间百分比(wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈,块操作)st: iostat查看磁盘I/O使用和CPU情况1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@zhangbb ~]# iostat -d vda 3 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.36 0.07 3.26 1000024 46518530Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 1.01 0.00 4.04 0 12Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.67 0.00 20.20 0 60tps：该设备每秒的传输次数&quot;一次传输&quot;意思是&quot;一次I/O请求&quot;。多个逻辑请求可能会被合并为&quot;一次I/O请求&quot;。&quot;一次传输&quot;请求的大小是未知的。kB_read/s：每秒从设备（drive expressed）读取的数据量kB_wrtn/s：每秒向设备（drive expressed）写入的数据量kB_read：读取的总数据量kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes-x：显示扩展状态[root@zhangbb ~]# iostat -d -x 1 3Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.44 0.00 0.35 0.07 3.26 18.71 0.00 0.40 1.34 0.39 0.21 0.01Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00&gt; rrqm/s: 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并&gt; wrqm/s: 每秒对该设备的写请求被合并次数&gt; r/s: 每秒完成的读次数&gt; w/s: 每秒完成的写次数&gt; rkB/s: 每秒读数据量(kB为单位)&gt; wkB/s: 每秒写数据量(kB为单位)&gt; avgrq-sz:平均每次IO操作的数据量(扇区数为单位)&gt; avgqu-sz: 平均等待处理的IO请求队列长度&gt; await: 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)&gt; svctm: 平均每次IO请求的处理时间(毫秒为单位)&gt; %util: 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率util = (r/s+w/s) * (svctm/1000) mpstat每个CPU的使用情况123456789101112131415161718192021从/proc/stat获得数据[root@zhangbb ~]# mpstat 3 5Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)03:18:09 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle03:18:12 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.33 0.00 0.00 99.6703:18:15 PM all 0.34 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 99.6603:18:18 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.0003:18:21 PM all 0.33 0.00 0.33 0.00 0.00 0.00 0.33 0.00 0.00 99.0003:18:24 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.34 0.00 0.00 99.66Average: all 0.13 0.00 0.07 0.00 0.00 0.00 0.20 0.00 0.00 99.60CPU 处理器IDuser 在时间段里，用户态的CPU时间(%)，不包含 nice值为负 进程 (usr/total)*100 nice 在时间段里，nice值为负进程的CPU时间(%) (nice/total)*100 system 在时间段里，核心时间(%) (system/total)*100iowait 在时间段里，硬盘IO等待时间(%) (iowait/total)*100irq 在时间段里，硬中断时间(%) (irq/total)*100soft 在时间段里，软中断时间(%) (softirq/total)*100idle 在时间段里，CPU除去等待磁盘IO操作外的因为任何原因而空闲的时间闲置时间(%)(idle/total)*100intr/s 在时间段里，每秒CPU接收的中断的次数intr/total)*100 free12345678952_zjdev[/data01/zjgrp/zjdev]%free -h total used free shared buffers cachedMem: 63G 61G 1.8G 21G 567M 43G-/+ buffers/cache: 17G 45GSwap: 2.0G 2.0G 32K(-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached(+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached可见-buffers/cache反映的是被程序实实在在吃掉的内存，而+buffers/cache反映的是可以挪用的内存总数 sar1234567891011121314151617181920212223sar -u 1 2 //体CPU使用统计sar -P ALL 1 1 //各个CPU使用统计sar -r 1 2 //内存使用情况统计sar -b 1 2 //整体I/O情况sar -d -p 1 1 //各个I/O设备情况sar -n DEV 1 1 //网络统计[root@zhangbb ~]# sar -n DEV 1 1Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/08/2019 _x86_64_ (1 CPU)07:59:15 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s07:59:16 PM eth0 6.12 5.10 0.59 0.95 0.00 0.00 0.0007:59:16 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0007:59:16 PM ip_vti0 0.00 0.00 0.00 0.00 0.00 0.00 0.0007:59:16 PM docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00IFACE: 网络接口名称rxpck/s: 每秒收包的数量txpck/s: 每秒发包的数量rxkB/s: 每秒收的数据量(kB为单位)txkB/s: 每秒发的数据量(kB为单位)sar日志保存(-o) 进程级计数器top按一个统计数据排序，显示排名高的进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646552_zjdev[/data01/zjgrp/zjdev]%top -u zjv8cs -d 3top - 14:16:50 up 168 days, 17:39, 34 users, load average: 0.95, 0.74, 0.66Tasks: 418 total, 1 running, 417 sleeping, 0 stopped, 0 zombie%Cpu(s): 22.1 us, 3.3 sy, 0.0 ni, 73.6 id, 0.7 wa, 0.0 hi, 0.3 si, 0.0 stKiB Mem: 66109508 total, 65616660 used, 492848 free, 321260 buffersKiB Swap: 2103292 total, 2103292 used, 0 free. 47138260 cached Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3869 zjv8cs 20 0 26.460g 504060 16484 S 6.250 0.762 124:55.11 sframe 6343 zjv8cs 20 0 19.333g 332120 7328 S 0.000 0.502 20:45.48 java 6369 zjv8cs 20 0 2921872 224360 26232 S 0.000 0.339 77:42.57 odframe 6480 zjv8cs 20 0 23.116g 102460 90296 S 0.000 0.155 1:11.94 sframe 6482 zjv8cs 20 0 23.064g 27784 16352 S 0.000 0.042 1:09.05 sframe 6484 zjv8cs 20 0 23.062g 28872 15584 S 0.000 0.044 1:08.88 sframe 6503 zjv8cs 20 0 23.116g 59680 47540 S 0.000 0.090 1:10.93 sframe 6511 zjv8cs 20 0 23.119g 358908 336920 S 0.000 0.543 1:22.49 sframe 6520 zjv8cs 20 0 23.116g 1.069g 1.056g S 0.000 1.696 1:45.00 sframe 6536 zjv8cs 20 0 23.066g 27624 15596 S 0.000 0.042 1:09.88 sframe 6543 zjv8cs 20 0 23.288g 2.963g 2.820g S 0.000 4.700 3:10.91 sframe 6552 zjv8cs 20 0 23.118g 369656 356788 S 0.000 0.559 1:22.45 sframe 6554 zjv8cs 20 0 23.116g 29924 17728 S 0.000 0.045 1:11.02 sframe 6567 zjv8cs 20 0 23.061g 26992 15396 S 0.000 0.041 1:09.80 sframe 7061 zjv8cs 20 0 31968 1244 736 S 0.000 0.002 0:01.24 systemd 7062 zjv8cs 20 0 63640 40 0 S 0.000 0.000 0:00.00 (sd-pam) 7492 zjv8cs 20 0 24.637g 62640 7180 S 0.000 0.095 38:41.25 sframe 8069 zjv8cs 20 0 23.476g 30552 17872 S 0.000 0.046 9:14.04 odframe 8101 zjv8cs 20 0 23.116g 89672 77504 S 0.000 0.136 1:13.43 sframe 8156 zjv8cs 20 0 24.643g 68264 6964 S 0.000 0.103 34:18.32 sframe 8683 zjv8cs 20 0 23.136g 18508 8916 S 0.000 0.028 1:04.60 sframe 14603 zjv8cs 20 0 23.003g 28440 16644 S 0.000 0.043 0:24.28 sframe 14838 zjv8cs 20 0 25.779g 437940 21188 S 0.000 0.662 124:05.00 sframe 17791 zjv8cs 20 0 87688 1800 904 S 0.000 0.003 0:00.03 sshd 17792 zjv8cs 20 0 16824 3376 1452 S 0.000 0.005 0:00.15 csh上半部分：top一行：从左到右依次为当前系统时间，系统运行的时间，系统在之前1min、5min和15min内cpu的平均负载值Tasks一行：该行给出进程整体的统计信息，包括统计周期内进程总数、运行状态进程数、休眠状态进程数、停止状态进程数和僵死状态进程数Cpu(s)一行：cpu整体统计信息，包括用户态下进程、系统态下进程占用cpu时间比，nice值大于0的进程在用户态下占用cpu时间比，cpu处于idle状态、wait状态的时间比，以及处理硬中断、软中断的时间比Mem一行：该行提供了内存统计信息，包括物理内存总量、已用内存、空闲内存以及用作缓冲区的内存量Swap一行：虚存统计信息，包括交换空间总量、已用交换区大小、空闲交换区大小以及用作缓存的交换空间大小下半部：PID: 进程pidUSER: 拉起进程的用户PR: 该列值加100为进程优先级，若优先级小于100，则该进程为实时(real-time)进程， 否则为普通(normal)进程，实时进程的优先级更高，更容易获得cpu调度，以上输出结果中， java进程优先级为120，是普通进程，had进程优先级为2，为实时进程，migration 进程的优先级RT对应于0，为最高优先级NI: 进程的nice优先级值，该列中，实时进程的nice值为0，普通进程的nice值范围为-20~19VIRT: 进程所占虚拟内存大小（默认单位kB）RES: 进程所占物理内存大小（默认单位kB）SHR: 进程所占共享内存大小（默认单位kB）S: 进程的运行状态%CPU: 采样周期内进程所占cpu百分比(-d 3)%MEM: 采样周期内进程所占内存百分比TIME+: 进程使用的cpu时间总计COMMAND: 拉起进程的命令# 可以按照不同的指标排序显示，按对应键即可# P 按照 CPU 使用率排序# T 按照 MITE+ 排序# M 按内存使用占比排序# 按”d”可以更新top更新频率, 按空格键可以手动更新输出# 按”c”快捷键，将显示命令的全路径以及命令参数# 按”k”快捷键，可向指定进程发送信号，默认信号为SIGTERM，该信号可中止进程# 按”r”快捷键，可以修改指定进程的nice优先级 ps1234567891011121314151617181920212223242526272829303132333435363738[root@zhangbb ~]# ps -o pid,ppid,lwp,comm PID PPID LWP COMMAND 4981 4975 4981 bash 7792 4981 7792 ps 进程状态，显示进程的各种统计信息，包括内存和CPU的使用host-10-19-14-51:/data01/zjgrp/zjv8cs/sqlite&gt; ps -eLo pid,lwp,pcpu | grep 1256712567 12567 0.012567 12568 0.012567 12569 0.012567 12575 0.012567 12576 0.012567 12577 0.012567 12579 0.0linux上进程有5种状态: 1. 运行(正在运行或在运行队列中等待) 2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process [root@zhangbb ~]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.4 54384 4916 ? Ss 2018 85:05 /usr/lib/systemd/systemd --system --deserialize 22root 2 0.0 0.0 0 0 ? S 2018 0:03 [kthreadd]root 3 0.0 0.0 0 0 ? S 2018 3:55 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; 2018 0:00 [kworker/0:0H]TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?， 另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序 pmap将进程的内存和使用统计一起列出12345678910111213141516171819202122232425262728293031323334353637host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; pmap -d 6480START SIZE RSS PSS DIRTY SWAP PERM OFFSET DEVICE MAPPING0000000000400000 28K 24K 1K 0K 0K r-xp 0000000000000000 fd:00 /data01/zjgrp/zjdev/ob_rel/bin/sframe.2.3.0.8111240000000000606000 4K 4K 4K 4K 0K r--p 0000000000006000 fd:00 /data01/zjgrp/zjdev/ob_rel/bin/sframe.2.3.0.8111240000000000607000 4K 4K 4K 4K 0K rw-p 0000000000007000 fd:00 /data01/zjgrp/zjdev/ob_rel/bin/sframe.2.3.0.8111240000000000fbf000 596K 532K 532K 532K 0K rw-p 0000000000000000 00:00 [heap]0000000001054000 2420K 1980K 1980K 1980K 0K rw-p 0000000000000000 00:00 [heap]00002ac54f4c6000 132K 96K 0K 0K 0K r-xp 0000000000000000 00:23 /lib64/ld-2.19.so...00007f4300ffe000 768064K 72592K 72527K 72592K 0K r--s 0000000000000000 00:05 /SYSV0108cd2600007f432fe0e000 67528K 12K 0K 12K 0K r--s 0000000000000000 00:05 /SYSV0108ccd500007fff0738e000 136K 108K 108K 108K 0K rw-p 0000000000000000 00:00 [stack]00007fff073b6000 8K 4K 0K 0K 0K r-xp 0000000000000000 00:00 [vdso]ffffffffff600000 4K 0K 0K 0K 0K r-xp 0000000000000000 00:00 [vsyscall]Total: 24239152K 102676K 85374K 84936K 0K49996K writable-private, 1075844K readonly-private, 23113312K shared, and 98852K referenced [root@zhangbb ~]# pmap -d 16631663: /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/var/zhangbb.err --open-files-limit=65535 --pid-file=/usr/local/mysql/var/zhangbb.pid --socket=/tmp/mysql.sock --port=3306Address Kbytes Mode Offset Device Mapping0000000000400000 8852 r-x-- 0000000000000000 0fd:00001 mysqld0000000000ea5000 8 r---- 00000000008a5000 0fd:00001 mysqld0000000000ea7000 660 rw--- 00000000008a7000 0fd:00001 mysqld0000000000f4c000 160 rw--- 0000000000000000 000:00000 [ anon ]0000000001f85000 24832 rw--- 0000000000000000 000:00000 [ anon ]......00007f0bd867b000 4 rw--- 0000000000022000 0fd:00001 ld-2.17.so00007f0bd867c000 4 rw--- 0000000000000000 000:00000 [ anon ]00007ffc301f0000 132 rw--- 0000000000000000 000:00000 [ stack ]00007ffc3025b000 8 r-x-- 0000000000000000 000:00000 [ anon ]ffffffffff600000 4 r-x-- 0000000000000000 000:00000 [ anon ]mapped: 434848K writeable/private: 204948K shared: 0Kmapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vszwriteable/private 表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小 shared 表示进程和其他进程共享的内存大小 iotop进程的I/O速度123456789101112[root@zhangbb ~]# iotop -p 29215Total DISK READ : 0.00 B/s | Total DISK WRITE : 0.00 B/sActual DISK READ: 0.00 B/s | Actual DISK WRITE: 0.00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; COMMAND 29215 be/4 root 0.00 B/s 0.00 B/s ?unavailable? docker-containerd -l uni~him --runtime docker左右箭头：改变排序方式，默认是按IO排序。r：改变排序顺序。o：只显示有IO输出的进程。p：进程/线程的显示方式的切换。a：显示累积使用量。q：退出。 pidstat查看进程I/O , 内存, CPU123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# cpu使用情况统计(-u)# 使用-u选项，pidstat将显示各活动进程的cpu使用统计，执行”pidstat -u”与单独执行”pidstat”的效果一样[root@zhangbb ~]# pidstatLinux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/09/2019 _x86_64_ (1 CPU)03:11:40 PM UID PID %usr %system %guest %CPU CPU Command03:11:40 PM 0 1 0.01 0.02 0.00 0.03 0 systemd03:11:40 PM 0 2 0.00 0.00 0.00 0.00 0 kthreadd03:11:40 PM 0 3 0.00 0.00 0.00 0.00 0 ksoftirqd/003:11:40 PM 0 9 0.00 0.01 0.00 0.01 0 rcu_sched03:11:40: pidstat获取信息时间点PID: 进程pid%usr: 进程在用户态运行所占cpu时间比率%system: 进程在内核态运行所占cpu时间比率%CPU: 进程运行所占cpu时间比率CPU: 指示进程在哪个核运行Command: 拉起进程对应的命令# 内存使用情况统计(-r)[root@zhangbb ~]# pidstat -r -p 31846Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/14/2019 _x86_64_ (1 CPU)02:46:04 PM UID PID minflt/s majflt/s VSZ RSS %MEM Command02:46:04 PM 0 31846 0.00 0.00 216704 2924 0.29 osquerydminflt/s: 每秒次缺页错误次数(minor page faults)，次缺页错误次数意即虚拟内存地址映射成物理内存地址产生的page fault次数majflt/s: 每秒主缺页错误次数(major page faults)，当虚拟内存地址映射成物理内存地址时，相应的page在swap中，这样的page fault为major page fault，一般在内存使用紧张时产生VSZ: 该进程使用的虚拟内存(以kB为单位)RSS: 该进程使用的物理内存(以kB为单位)%MEM: 该进程使用内存的百分比Command: 拉起进程对应的命令# IO情况统计(-d)[root@zhangbb ~]# pidstat -d 1 2Linux 3.10.0-693.11.6.el7.x86_64 (zhangbb) 01/14/2019 _x86_64_ (1 CPU)02:47:23 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command02:47:24 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s CommandAverage: UID PID kB_rd/s kB_wr/s kB_ccwr/s CommandkB_rd/s: 每秒进程从磁盘读取的数据量(以kB为单位)kB_wr/s: 每秒进程向磁盘写的数据量(以kB为单位)Command: 拉起进程对应的命令# 针对特定进程统计(-p)pidstat -T CHILD -C mysql // 显示所有mysql服务器的子进程pidstat -urd -h // 将所有的统计数据结合到一个便于阅读的单一报告中 fuser常用命令查询给定文件或目录的用户或进程信息123456789101112131415161718192021[root@zhangbb ~]# fuser -v /root USER PID ACCESS COMMAND/root: root 7944 ..c.. bash root 9847 ..c.. bash root 25352 ..c.. bash PID后跟的字符说明了进程以何种方式与该目录/文件关联，有以下关联方式： c 指示进程的工作目录 e 指示该文件为进程的可执行文件(即进程由该文件拉起) f 指示该文件被进程打开，默认情况下f字符不显示 F 指示该文件被进程打开进行写入，默认情况下F字符不显示 r 指示该目录为进程的根目录 m 指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存[root@zhangbb ~]# fuser -v -n tcp 3306 USER PID ACCESS COMMAND3306/tcp: mysql 1663 F.... mysqld查询socket 端口占用进程fuser -v -k mysqld关闭进程 网络工具netstat1234567891011netstat -a #列出所有端口netstat -at #列出所有tcp端口netstat -au #列出所有udp端口 netstat -l #只显示监听端口netstat -lt #只列出所有监听 tcp 端口netstat -lu #只列出所有监听 udp 端口netstat -pt #显示 PID 和进程名称netstat -n #显示IPnetstat -c #每隔一秒输出网络信息 ss1234567891011121314151617181920212223比netstat 效率高, 可以用time来比较-a, --all display all sockets-l, --listening display listening sockets-p, --processes show process using socket-s, --summary show socket usage summary-t, --tcp display only TCP sockets-u, --udp display only UDP sockets#列出来至120.33.31.1,80端口的连接ss src 120.33.31.1:httpss src 120.33.31.1:80host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ss -sTotal: 2701 (kernel 0)TCP: 2018 (estab 785, closed 1049, orphaned 0, synrecv 0, timewait 16/0), ports 0Transport Total IP IPv6* 0 - - RAW 0 0 0 UDP 1 1 0 TCP 969 831 138 INET 970 832 138 FRAG 0 0 0 iftop12345678910111213141516171819202122232425262728293031323334353637383940414243用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等 12.5Kb 25.0Kb 37.5Kb 50.0Kb 62.5Kb+---------------------+---------------------+---------------------+---------------------+---------------------45.32.49.180.vultr.com =&gt; 218.205.54.1 6.88Kb 5.00Kb 5.00Kb &lt;= 528b 424b 424b 45.32.49.180.vultr.com =&gt; 108.61.10.10.choopa.net 472b 2.36Kb 2.36Kb &lt;= 0b 2.80Kb 2.80Kbzhangbb =&gt; 2605:a000:1620:43be:bc3d:cf55:9cc5:c949 1.67Kb 856b 856b &lt;= 608b 304b 304bzhangbb =&gt; 2605:a000:1102:c230:b272:bfff:fe82:223f 0b 856b 856b &lt;= 0b 304b 304bzhangbb =&gt; 2001:b011:200b:1d2c:cdd3:eb53:ee38:be79 1.63Kb 834b 834b &lt;= 584b 292b 292bzhangbb =&gt; 2001:e68:541b:b09:ddb2:79ab:d9f2:a2fb 1.63Kb 834b 834b &lt;= 584b 292b 292b45.32.49.180.vultr.com =&gt; 212.92.105.127 640b 320b 320b &lt;= 528b 264b 264b45.32.49.180.vultr.com =&gt; 188.168.215.41 0b 308b 308b &lt;= 0b 252b 252b45.32.49.180.vultr.com =&gt; m5673.contaboserver.net 0b 306b 306b &lt;= 0b 250b 250b45.32.49.180.vultr.com =&gt; ip-187-44-249-173.static.contabo.net 0b 302b 302b &lt;= 0b 246b 246bzhangbb =&gt; 2a01:c50f:8c01:2700:8cfe:47e7:f6f3:41c 0b 202b 202b &lt;= 0b 238b 238bzhangbb =&gt; 2400:2412:8720:2800:7603:bdff:fe96:676b 424b 212b 212b &lt;= 388b 194b 194bzhangbb =&gt; 2607:5300:60:5e6e::33c:e975 424b 212b 212b &lt;= 388b 194b 194bzhangbb =&gt; 240d:1a:700:e900:211:32ff:fe69:b9be 0b 194b 194b &lt;= 0b 212b 212b--------------------------------------------------------------------------------------------------------------TX: cum: 6.56KB peak: 14.4Kb rates: 14.4Kb 13.1Kb 13.1KbRX: 3.19KB 9.05Kb 3.71Kb 6.38Kb 6.38KbTOTAL: 9.76KB 20.9Kb 18.1Kb 19.5Kb 19.5KbTX：发送流量RX：接收流量TOTAL：总流量Cumm：运行iftop到目前时间的总流量peak：流量峰值rates：分别表示过去 2s 10s 40s 的平均流量 nethogs一个小型的net top工具, 按进程或程序实时统计网络带宽使用率123456789101112131415[root@zhangbb ~]# nethogsEthernet link detected Waiting for first packet to arrive (see sourceforge.net bug 1019381)NetHogs version 0.8.5 PID USER PROGRAM DEV SENT RECEIVED 2790 root sshd: root@pts/0,pts/1 eth0 1.419 0.555 KB/sec ? root unknown TCP 0.000 0.000 KB/sec TOTAL 1.419 0.555 KB/secm : Cycle between display modes (kb/s, kb, b, mb) 切换网速显示单位r : Sort by received. 按接收流量排序s : Sort by sent. 按发送流量排序q : Quit and return to the shell prompt. 退出NetHogs命令工具 tpcdump123456789101112131415161718192021222324252627282930// 监视指定网络接口的数据包tcpdump -i eth1// 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) // 取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包tcpdump ip host 210.27.48.1 and ! 210.27.48.2// 截获主机hostname发送的所有数据tcpdump -i eth0 src host hostname// 监视所有送到主机hostname的数据包tcpdump -i eth0 dst host hostname// 监视指定主机和端口的数据包tcpdump tcp port 23 and host 210.27.48.1tcpdump udp port 123 // 监视指定协议的数据包// 打印TCP会话中的的开始和结束数据包, 并且数据包的源或目的不是本地网络上的主机.tcpdump &apos;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet&apos;......// 保存到文件用wireshark分析tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型(2)-i eth1 : 只抓经过接口eth1的包(3)-t : 不显示时间戳(4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包(5)-c 100 : 只抓取100个数据包(6)dst port ! 22 : 不抓取目标端口是22的数据包(7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24(8)-w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析 Linux tcpdump命令详解 其他命令tar使用 tar 命令只要记得参数是[必选+自选+f]:必选： -c 意为 create，表示创建压缩包 -x 意为 extract，表示解压 -t 表示查看内容 -r 给压缩包追加文件 -u 意为 update，更新压缩包中的文件 自选： -z 使用 gzip 属性 -j 使用 bz2 属性 -Z 使用 compress 属性 -v 意为 verbose，显示详细的操作过程 -O 将文件输出到标准输出 遇到不同类型的文件，请用不同的套路来应对： .tar -&gt; tar -xf .tar.gz -&gt; tar -xzf.tar.bz2 -&gt; tar -xjf .tar.Z -&gt; tar -xZf.gz -&gt; gzip -d .rar -&gt; unrar e*.zip -&gt; unzip find12345678910111213141516171819202122232425262728# 找出七天前的文件# / 表示从根目录中查找# -type f 表示找出系统普通文件，不包含目录# -mtime +n 表示寻找 n 天前的数据# -print 打印文件名称find / -type f -mtime +7 -print# 找出并删除七天前的文件find /temp/ -type f -mtime +7 -print -exec rm -f &#123;&#125; \;# -exec 表示后面执行系统命令# &#123;&#125; 只有该符号能跟在命令你后面# \; 结束符号find /temp/ -type f -mtime +7 -print | xargs rm -f# 使用管道和 xargs = -exec# 查找 /var 下最大的十个文件find /var -type f -ls | sort -k 7 -r -n | head# 查找 /var/log 下大于 5GB 的文件find /var/log/ -type f -size +5120M -exec ls -lh &#123;&#125; \;# 找出今天所有文件并将它们拷贝到另一个目录find . -ctime 0 -print -exec cp &#123;&#125; /mnt/backup/&#123;&#125; \;# 找出2天内的修改文件, 删除前询问find /var/log -type f -mtime -2 -ok rm &#123;&#125; \;#-cmin +10: 在10分钟前被修改过的 du1234#显示当前文件下 Top 10 空间占用的文件/目录，#s 表示不显示每个子目录或文件的大小#h 表示用更加自然的方式显示（比如 K/M/G 这样）du -sh * | sort -nr | head dd测试磁盘读写速度, 备份或恢复磁盘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152参数：b=512, c=1, k=1024, w=2, xm=number m 指定数字的地方若以下列字符结尾乘以相应的数字if=file 输入文件名，缺省为标准输入of=file 输出文件名，缺省为标准输出ibs=bytes 一次读入 bytes 个字节(即一个块大小为 bytes 个字节obs=bytes 一次写 bytes 个字节(即一个块大小为 bytes 个字节bs=bytes 同时设置读写块的大小为 bytes ，可代替 ibs 和 obscbs=bytes 一次转换 bytes 个字节，即转换缓冲区大小skip=blocks 从输入文件开头跳过 blocks 个块后再开始复制seek=blocks 从输出文件开头跳过 blocks 个块后再开始复制count=blocks 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数应用：// 将/dev/hdx全盘数据备份到指定路径的image文件dd if=/dev/hdx of=/path/to/image// 备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径dd if=/dev/hdx | gzip &gt;/path/to/image.gz// 拷贝内存资料到硬盘, 将内存里的数据拷贝到root目录下的mem.bin文件dd if=/dev/mem of=/root/mem.bin bs=1024// 从光盘拷贝iso镜像, 从光盘拷贝iso镜像dd if=/dev/cdrom of=/root/cd.iso// 备份文件恢复到指定盘dd if=/path/to/image of=/dev/hdxgzip -dc /path/to/image.gz | dd of=/dev/hdx// 备份MBRdd if=/dev/hdx of=/path/to/image count=1 bs=512// 将内存里的数据拷贝到root目录下的mem.bin文件dd if=/dev/mem of=/root/mem.bin bs=1024// 拷贝光盘数据到root文件夹下，并保存为cd.iso文件dd if=/dev/cdrom of=/root/cd.iso// 利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据dd if=/dev/urandom of=/dev/hda1// 得到最恰当的block sizedd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.filedd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.filedd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file// 测试硬盘读写速度dd if=/root/1Gb.file bs=64k | dd of=/dev/nulldd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000[root@zhangbb ~]# dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file1000000+0 records in1000000+0 records out1024000000 bytes (1.0 GB) copied, 4.31042 s, 238 MB/s[root@zhangbb ~]# dd if=/root/1Gb.file bs=64k | dd of=/dev/null15625+0 records in15625+0 records out1024000000 bytes (1.0 GB) copied2000000+0 records in2000000+0 records out1024000000 bytes (1.0 GB) copied, 3.08384 s, 332 MB/s, 3.08522 s, 332 MB/s lsof12345678910111213141516171819202122# 查看进程打开文件lsof -p pid[root@zhangbb ~]# lsof -p `pgrep pritunl-web`COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEpritunl-w 28661 root cwd DIR 253,1 4096 2 /pritunl-w 28661 root rtd DIR 253,1 4096 2 /pritunl-w 28661 root txt REG 253,1 13205960 46464 /usr/bin/pritunl-webpritunl-w 28661 root mem REG 253,1 2151672 4698 /usr/lib64/libc-2.17.sopritunl-w 28661 root mem REG 253,1 141968 4724 /usr/lib64/libpthread-2.17.sopritunl-w 28661 root mem REG 253,1 163400 4690 /usr/lib64/ld-2.17.sopritunl-w 28661 root 0r CHR 1,3 0t0 4856 /dev/nullpritunl-w 28661 root 1w FIFO 0,8 0t0 62148038 pipepritunl-w 28661 root 2w FIFO 0,8 0t0 62148039 pipepritunl-w 28661 root 3w REG 253,1 141 46468 /var/log/pritunl.logpritunl-w 28661 root 4u IPv6 62148054 0t0 TCP *:https (LISTEN)pritunl-w 28661 root 5u a_inode 0,9 0 4852 [eventpoll]pritunl-w 28661 root 10r FIFO 0,8 0t0 62147876 pipepritunl-w 28661 root 11r CHR 1,9 0t0 4861 /dev/urandompritunl-w 28661 root 12w CHR 1,3 0t0 4856 /dev/nullpritunl-w 28661 root 13w FIFO 0,8 0t0 62147876 pipepritunl-w 28661 root 14u sock 0,7 0t0 62147877 protocol: NETLINK curliptablesipcs用于显示进程间通信信息的命令，其可列出进程间的共享内存、消息队列、信号信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -a--------- 消息队列 -----------键 msqid 拥有者 权限 已用字节数 消息 0x0000bff0 688128 zjv8cs2 666 0 0 0x000cd141 1605633 zjdev 666 0 0 ------------ 共享内存段 --------------键 shmid 拥有者 权限 字节 连接数 状态 0x0100cd0c 55115778 zjv8cs 666 1761104 44 0x0108ccd5 55148547 zjv8cs 666 69145336 21 0x0108cd26 55181317 zjv8cs 666 786497536 21 0x0108ca0b 55214104 zjv8cs 666 786497536 21 0x0108ca30 55246915 zjv8cs 666 786497536 21 0x0108ca3c 55279684 zjv8cs 666 786497536 21 0x0108cbe2 55312453 zjv8cs 666 786497536 21 0x0108cd4a 55345222 zjv8cs 666 786497536 21 0x0108ce69 55377991 zjv8cs 666 786497536 21 0x0108cf7d 55410760 zjv8cs 666 786497536 21 0x0108d3ea 55443529 zjv8cs 666 786497536 21 0x0108d4f2 55476298 zjv8cs 666 786497536 21 0x0108d4f3 55509067 zjv8cs 666 786497536 21 0x0108d4f4 55541836 zjv8cs 666 786497536 21 0x0108d4f5 55574627 zjv8cs 666 786497536 21 0x0108d4f6 55607396 zjv8cs 666 786497536 21 0x0108d4f7 55640165 zjv8cs 666 786497536 21 0x0108d4f8 55672946 zjv8cs 666 786497536 21 0x0108d4f9 55705715 zjv8cs 666 786497536 21 0x0108d4fa 55738484 zjv8cs 666 786497536 21 0x0108d4fb 55771253 zjv8cs 666 786497536 21 0x0108d4fc 55804022 zjv8cs 666 786497536 21 0x0108d4fd 55836791 zjv8cs 666 786497536 21 0x0108d4fe 55869560 zjv8cs 666 786497536 21 0x0108d4ff 55902329 zjv8cs 666 786497536 21 0x0108d500 55935098 zjv8cs 666 786497536 21 0x0108d501 55967867 zjv8cs 666 786497536 21 0x0108d502 56000636 zjv8cs 666 786497536 21 0x0108d503 56033405 zjv8cs 666 786497536 21 0x0108d504 56066174 zjv8cs 666 786497536 21 0x0108d505 56098943 zjv8cs 666 786497536 21 0x0108d506 56131712 zjv8cs 666 786497536 21 --------- 信号量数组 -----------键 semid 拥有者 权限 nsems 0x0108cd24 3571715 zjv8cs 666 100 # 查看ipc限制# -m选项单独列出共享内存信息，-s选项单独列出信号信息，-q选项单独列出消息队列信息host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -m -l---------- 同享内存限制 ------------最大段数 = 4096最大段大小 (千字节) = 18014398509481983最大总共享内存 (千字节) = 18014398509480960最小段大小 (字节) = 1# 显示ipc信息详情host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -m -i 55115778共享内存段 shmid=55115778uid=1002 gid=1002 cuid=1002 cgid=100模式=0666 访问权限=0666字节数=1761104 lpid=7279 cpid=6369 nattch=48附加时间=Wed Jan 16 11:38:29 2019 脱离时间=Wed Jan 16 11:38:29 2019 更改时间=Wed Jan 2 10:09:05 2019 # 显示ipc创建者与拥有者详情# 显示最近访问ipc的进程pidhost-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -m -p -------- 共享内存 创建者/上次修改者 PID ----------shmid 拥有者 cpid lpid 0 zjdev 3140 3783 6979585 zjcccs 20087 3047 55115778 zjv8cs 6369 8573 55148547 zjv8cs 6367 9191 # 显示最近访问时间点host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -s -t------------ 信号量 操作/更改 时间 -------------semid 拥有者 上一操作 上次更改 3538944 zjv8cs2 Wed Jan 16 14:00:16 2019 Wed Jan 16 13:15:46 2019 524289 zjcccs Mon Nov 19 14:29:06 2018 Thu Jul 26 17:01:22 2018 393218 zjdev Tue Jan 8 16:21:57 2019 Thu Nov 15 18:00:31 2018 3571715 zjv8cs Wed Jan 16 14:00:15 2019 Wed Jan 2 10:25:00 2019 589828 zjv5cs Wed Jan 9 10:57:59 2019 Thu Jul 26 20:42:16 2018 950277 zjcccs2 Sun Jan 13 17:08:26 2019 Tue Aug 7 15:35:27 2018 2228230 zjdev Thu Oct 25 11:40:30 2018 Thu Oct 25 11:39:07 2018 2031623 zjcccs3 Wed Jan 16 12:49:44 2019 Thu Sep 27 11:25:15 2018 # 显示当前使用状态host-10-19-14-51:/data01/zjgrp/zjv8cs&gt; ipcs -u---------- 消息状态 -----------已分配队列数 = 2已用消息头(header)数 = 0已用空间 = 0 字节---------- 共享内存状态 ------------段已分配 135页已分配 31145111页驻留 5595656页交换 108302交换性能：0 次尝试 0 次成功--------- 信号量状态 -----------已使用数组 = 8已分配信号量数 = 561# 删除ipcrm用法 ipcrm -M shmkey 移除用shmkey创建的共享内存段ipcrm -m shmid 移除用shmid标识的共享内存段ipcrm -Q msgkey 移除用msqkey创建的消息队列ipcrm -q msqid 移除用msqid标识的消息队列ipcrm -S semkey 移除用semkey创建的信号ipcrm -s semid 移除用semid标识的信号 teetee命令用于将数据重定向到文件 12345678910111213141516sudo tee /etc/yum.repos.d/mongodb-org-4.0.repo &lt;&lt; EOF[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.ascEOF[root@zhangbb ~]# cat /etc/yum.repos.d/mongodb-org-4.0.repo[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc 常用技巧：1234567891011121314151617cat file1 file2 &gt;file3 #合并文件tac file #以行为单位，倒序显示head -n 100 file #显示file的前100行head -n -100 file #显示file的除最后100行以外的内容。 tail -100 file #显示file最后100行内容tail -n +100 file #从第100行开始显示file内容 sed -n &apos;1,100p&apos; file &gt; file2 #截取file中1到100行到file2sed -n &quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&quot; file #显示包含&quot;&amp;&amp;&amp;&amp;&amp;&quot;行sort/uniq #文本排序date +%s #将当前时间转成Unix时间戳date -d &apos;2013-2-22 22:14&apos; +%s #指定日期转成Unix时间戳date -d @1361542596 +&quot;%Y-%m-%d %H:%M:%S&quot; #指定格式输出grep &apos;aaa\|bbb&apos; file #查询&amp;&amp;&amp;或$$$grep -v &apos;root&apos; file #查询不包含root的行ps -ef | grep gmake | grep –v root | awk &apos;&#123;print $2&#125;&apos; | xargs kill -9 # 杀进程echo &quot;password&quot; | passwd testuser --stdin # linux用shell修改密码cut -d &quot; &quot; -f 2,3 1.txt # 用空格分隔, 显示第二、三个字段列]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker实践]]></title>
    <url>%2F2018%2F10%2F24%2FDocker%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Docker 简介Docker 是什么 Docker 最初是dotCloud公司的一个内部项目 Docker 使用go语言开发实现 Docker 是操作系统层面的虚拟化技术 Docker 是在操作系统层面进行虚拟化, 直接复用本地主机操作系统; 而传统方式是在硬件层面实现。 为什么用 Docker优势 1更高效的利用系统资源(额外系统消耗忽略不计) 2更快速的启动时间(秒级启动, 比传统虚拟机快) 3一致的运行环境(开发、测试、生产环境一样) 4持续交付和部署(Docker构建镜像, 快速部署) 5更轻松的迁移(平台迁移方便) 6更轻松的维护和扩展(分层存储以及镜像技术, 复用和维护简单) 容器基本不消化额外的系统资源, 秒级启动, 性能很高. 启动十个进程, 需要启动10台虚拟机, 但Docker只需要启动十个隔离的应用即可。 基本概念 镜像(Image) 一个特殊的文件系统, 包含程序,库,配置文件 利用Union FS技术分层存储, 由多层文件系统联合组成, Dockerfile会一层层的构建 容器(Container) 容器是从镜像运行时的实例, 会在镜像基础上创建一个存储层用于读写, 生命周期和容器一样 可以启、停止、删除、暂停等。容器内的进程是隔离的, 容器有自己的网络,文件系统, 进程空间, 用户空间 仓库(Registy) 存放镜像的场所, 可以是公有仓库或者私有仓库 官方Docker Hub , 用阿里云加速, DaoCloud 等加速器下载更快 安装将Docker的用户加入到Docker用户组 $ groupadd docker$ usermod -aG docker $USER 使用镜像1 获取镜像 docker pull 2 列出镜像123456789101112131415161718192021222324252627billing-csv-jfzx08%docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE20.26.38.47:5000/redo_java v27 90afb9850803 2 hours ago 2.85GB20.26.38.47:5000/suse12.2-jf 1.8.6 3c7f01d195d9 3 hours ago 9.14GB20.26.38.47:5000/suse12.2-zc 1.7.6 b9afcd1d062b 4 hours ago 12.3GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 18a1b4e851ba 6 hours ago 9.14GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; c9ff12f7c392 6 hours ago 9.13GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 86973ecd7035 7 hours ago 9.13GB20.26.38.47:5000/suse12.2-zc &lt;none&gt; a6a565cc7cd5 2 days ago 12.3GB20.26.38.47:5000/redo_java v26 71f5c0a56a15 3 days ago 2.85GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 87bed11aa735 3 days ago 9.11GB20.26.38.47:5000/dse-suse-12.2 latest 9930a53d9861 3 days ago 4.9GB20.26.38.47:5000/suse12.2-inputxdr test5 17c4f034235b 4 days ago 3.45GB20.26.38.47:5000/inputxdr v69.17 3ea2e49542c6 4 days ago 1.65GB20.26.38.47:5000/suse12.2-decode 1.7.6 791cb433e4d0 5 days ago 5.5GB20.26.38.47:5000/suse12.2-xc 1.3.6 5e0f0814a1b4 5 days ago 5.29GB20.26.38.47:5000/suse12.2-csf 2.1 2542b7237ccb 6 days ago 3.57GB20.26.38.47:5000/suse12.2-zc 1.7.4 1ab625d2ea97 7 days ago 10.7GB20.26.38.47:5000/dse-suse-12.2 &lt;none&gt; b293ed18bbef 11 days ago 4.74GB20.26.38.47:5000/suse12.2-decode 1.7.4 b867b33eca4e 13 days ago 5.36GB20.26.38.47:5000/suse12.2-xc 1.3.4 5f7c56b09631 13 days ago 5.15GB20.26.38.47:5000/suse12.2-jf 1.8.4 c60a266497d9 13 days ago 7.66GB20.26.38.47:5000/dse-suse-12.2 &lt;none&gt; 67e18d4bf990 2 weeks ago 4.89GB20.26.28.55/acam/tomcat 8.5.29-jre8-alpine d6c75482e065 8 months ago 106MB20.26.28.55/acam/tomcat v1 d6c75482e065 8 months ago 106MB20.26.28.55/platformv8/tomcat 8.5.29-jre8-alpine d6c75482e065 8 months ago 106MBregistry.yw.zj.chinamobile.com/dcos/df-client 1.9 8f7837553678 10 months ago 276MB 包含了仓库, 标签, 镜像ID, 创建时间, 占用空间 镜像体积：上面命令显示的是展开后各层总和, 实际硬盘占用会小很多 123456billing-csv-jfzx08%docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 23 16 30.06GB 25.58GB (85%)Containers 132 25 10.66MB 1.174MB (11%)Local Volumes 0 0 0B 0BBuild Cache 0B 0B 虚悬镜像： 旧版本被覆盖， docker image prune 删除 中间层镜像：docker image ls -a 列出部分或指定镜像:1234567891011121314151617billing-csv-jfzx08%docker image ls 20.26.38.47:5000/suse12.2-jf:1.8.4REPOSITORY TAG IMAGE ID CREATED SIZE20.26.38.47:5000/suse12.2-jf 1.8.4 c60a266497d9 13 days ago 7.66GBbilling-csv-jfzx08%docker image ls -f since=20.26.38.47:5000/redo_java:v26REPOSITORY TAG IMAGE ID CREATED SIZE20.26.38.47:5000/redo_java v27 90afb9850803 4 hours ago 2.85GB20.26.38.47:5000/suse12.2-jf 1.8.6 3c7f01d195d9 5 hours ago 9.14GB20.26.38.47:5000/suse12.2-zc 1.7.6 b9afcd1d062b 6 hours ago 12.3GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 18a1b4e851ba 7 hours ago 9.14GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; c9ff12f7c392 8 hours ago 9.13GB20.26.38.47:5000/suse12.2-jf &lt;none&gt; 86973ecd7035 9 hours ago 9.13GB20.26.38.47:5000/suse12.2-zc &lt;none&gt; a6a565cc7cd5 2 days ago 12.3GB// 某个镜像之前的镜像, since 改成beforedocker imgae ls -qdocker image ls --format &quot;&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Respository&#125;&#125;&quot; 3 删除本地镜像docker image rm $(docker image ls -q -f since=20.26.38.47:5000/redo_java:v26)docker ls –digests Dockerfile 实现原理 操作容器访问仓库数据管理网络]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式服务框架原理和实践]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库事务及锁]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81%2F</url>
    <content type="text"><![CDATA[事务的四个特性 原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability) 原子性一个事务中的全部操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会回滚到事务开始前的状态，不会对数据库有任何影响。 一致性在事务开始之前和事务结束以后，数据库的完整性没有被破坏。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性数据库允许多个并发事务对数据进行读写和修改，防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交(Read uncommitted)、读提交(read committed)、可重复读(repeatable read)和串行化（Serializable）。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务隔离级别如果不考虑事务的隔离性，会发生的几种问题: 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。(读未提交) 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 虚读(幻读)幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户, 如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体(比如数据的个数)。 串行化(Serializable)在串行化隔离模式下，消除了脏读，幻象，但事务并发度急剧下降，事务的隔离级别与事务的并发度成反比，隔离级别越高，事务的并发度越低。实际生产环境下，dba会在并发和满足业务需求之间作权衡，选择合适的隔离级别 现在来看看MySQL数据库为我们提供的四种隔离级别： ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 ③ Read committed (读已提交)：可避免脏读的发生。 ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别 事务隔离的实现——锁 共享锁(S锁) [] 用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。 更新锁(U锁) [] 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。 独占锁(X锁，也叫排他锁) [] 一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。 Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。 Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。 Serializable 读加共享锁，写加排他锁，读写互斥。 三级封锁协议mvcc多版本并发控制协议间隙锁]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>ACID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux知识体系]]></title>
    <url>%2F2018%2F10%2F19%2Flinux%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++知识体系]]></title>
    <url>%2F2018%2F10%2F19%2Fc-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gdb多线程调试]]></title>
    <url>%2F2018%2F10%2F15%2Fgdb%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95-1%2F</url>
    <content type="text"><![CDATA[all-stop mode: 默认模式, 有一个线程在断点处停止，其他所有线程也会停止 non-stop mode: 某一个线程停止时，其他线程会继续运行 Background Execution：异步运行程序 Thread-Specific Breakpoints: 控制断点 Interrupted System Calls: gdb会干扰系统调用 Observer Mode：gdb不影响程序执行 all-stop mode当进程在gdb下停止时，所有的线程都停止运行。当用单步调试命令“step或next”，所有的线程开始执行。由于执行线程调度的是操作系统不是gdb，单步调试命令不能让所有的线程都单步。当前线程执行了一步，其他线程可能执行了N步。当执行next/step/continue时，当前线程完成单步运行前，其他线程运行遇到断点/信号/异常，gdb会选择一个遇到短信或信号中断的线程，切换线程时会提示“[Switching to Thread n]” set scheduler-locking设置调度锁定模式，在一些系统中，gdb可以通过锁定操作系统线程调度，只允许一个线程运行。如果是on,单步调试命令会阻止其他线程抢占, 其他线程不会运行。如果是off，所有线程线程都会运行。当执行continue/util/finish 时，其他进程会恢复运行. show scheduler-locking显示当前线程调度锁定状态 set schedule-multiple当执行continue/next/step时，gdb只允许当前进程下的线程恢复运行(fork出过个进程)。on: 所有进程下的线程恢复运行off: 当前进程下的线程恢复运行 show schedule-multiple显示多进程恢复模式 non-stop mode在一些多线程的应用中，gdb支持只停止需要调试的线程，其他线程可运行不受影响。例如某些线程具有实时约束或必须继续响应外部事件，这是最小化的实时调试。称为不间断模式。在non-stop mode中，当一个线程因为断点停止时，其他线程正常运行，continue/step 只适用于当前线程。一般情况下在gdb启动或attach 一个进程时设置non-stop mode, 顺序执行如下命令，进入non-stop mode: Enable the async interface. set target-async 1 If using the CLI, pagination breaks non-stop. set pagination off Finally, turn it on! set non-stop on continue -a, 让所有线程都继续执行, continue 只能让当前线程继续执行interrupt -a, 停止整个程序, interrupt/Ctrl-c 只能让当前线程挂起, 其他命令不支持-a. Background Execution基本上用不到 Thread-Specific Breakpointsbreak linespec thread threadnobreak linespec thread threadno if ..threadno 从 info threads 中得到.比如(gdb) break frik.c:13 thread 28 if bartab &gt; lim [ ] Interrupted System Calls在使用gdb调试多线程程序时，有一个副作用。如果一个线程因断点或其他原因而停止，而另一个线程在系统调用中被阻塞，那么系统调用可能会提前返回。这是多线程和gdb用来实现断点和其他停止执行的事件的信号之间交互的结果。例如： sleep (10); 如果不同的线程在断点处或出于其他原因停止，则调用sleep将提前返回。 int unslept = 10; while (unslept &gt; 0) unslept = sleep (unslept); 允许系统调用提前返回，因此系统仍然符合其规范。但是gdb确实会导致多线程程序的行为与没有gdb时不同。另外，gdb在线程库中使用内部断点来监视某些事件，例如线程创建和线程销毁。当这样的事件发生时，另一个线程中的系统调用可能会提前返回，即使您的程序似乎没有停止. Observer Mode略]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
</search>
